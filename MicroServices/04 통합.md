# 통합

## 이상적인 통합 기술 모색
- 마이크로서비스끼리 통신하는 다양한 방법들로 우리가 바라는 것에 대하여
1. 호환성을 깨트리는 변경 피하기
    * 서비스의 일부가 바뀌더라도 기존 서비스에는 영향이 없어야 함
2. 기술 중립적인 API 생성
    * IT 산업은 끊임없이 변화함
    * 통신 API가 특정 기술에 종속되지 않도록 할 것
3. 소비자를 위한 서비스 단순화
    * 아름다운 구조보다 서비스 consumer가 쉽게 사용할 수 있는 서비스가 우선
4. 내부 구현 상세 감추기
    * 서비스 consumer가 내부에 종속되면, 결합도가 높아지고, 변경이 양쪽에서 이루어져야 해서 변경이 어려워진다.


## 고객과의 인터페이싱
- 고객 등록, 변경, 삭제 등에는 별개의 프로세스가 따를 수 있다


## 공유 데이터베이스
- 가장 일반적인 현업에서의 통합 형태
- 예상 가능한 문제점들
    * 외부에서 내부 구조(DB 스키마 등)를 알 수 있다
    * 서비스 consumer가 더 나은 기술적 선택을 하기 어렵게 한다
    * 공유 DB를 사용하기 위한 공유 로직이 서비스 consumer들에 퍼져 있으므로 응집력이 떨어진다


## 동기와 비동기
- 통신 방식에 의해 세부 구현이 달라지므로 통신 방식을 먼저 정해야 한다
- 동기 방식
    * 호출이 완료될 때까지 연산 중단
    * 완료 시점을 쉽게 파악할 수 있음
- 비동기 방식
    * 완료 여부와 무관
    * 클라이언트-서버 간 오랜 접속을 유지하기 어려운 장기 작업, 완료를 대기하느라 성능 저하를 일으키는 작업에 적합
- request-response 모델
    * 동기 방식과 명확히 일치
    * 비동기 방식으로는 콜백 등록으로 가능
- event driven 모델
    * 요청 X, 알림 O
    * 서비스 consumer를 쉽게 추가할 수 있음


## 오케스트레이션과 코레오그래피
1. 오케스트레이션
    - 프로세스를 안내하고 구동하는 하나의 중앙 두뇌에 의존
    - 하나의 모듈에 지나치게 많은 중앙 관리 권한 부여
2. 코레오그래피
    - 시스템 각 부분에 작업 내용을 알리고 세부 사항을 수행하게 함
    - 알림을 받으면 적절한 대처를 시작하면 되므로, 느슨한 결합
    - 모든 일이 제대로 수행되는지에 대한 모니터링 필요


## 원격 프로시저 호출 (RPC)
- 지역 호출(local call)로 원격 서비스를 실행하는 기술
- 유명 인터페이스: SOAP, Thrift, protocal buffer
    * 사용 이유: 다른 기술 스택에 대한 클라이언트와 서버 stub 생성이 쉬움
    * 장점
        - 쉬운 사용성 (평범한 메서드 호출처럼 사용)
    * 단점
        - 기술 결합
            + 일부 RPC 매커니즘은 특정 기술과 지나치게 엮여 있음
            + 어떤 RPC을 사용하는 것이 클라이언트와 서버의 기술 스펙을 노출할 수 있음 
        - 지역 호출은 원격 호출과 다르다
            + 원격 호출의 복잡성을 지나치게 은폐함
            + 네트워크 통신 비용 > marshalling, unmarshalling
            + 네트워크는 신뢰할 수 없다 -> 회복력(chap.11)
        - 취성(쉽게 깨지거나 부서지는 성질)
            + 대중적인 RPC 구현체도 깨지기 쉽다
            + 클라, 서버의 stub 변경이 빈번하다. 코드 변경과 배포 모두에 주의 필요.
        - RPC는 형편없는가?
            + 많은 작업에 적합한 경우가 있고, 현대 매커니즘은 단점을 보완하고 있음
            + 단, 잠재적 함정들을 알아야 한다
                1. 네트워크가 완전히 은폐될 정도로 원격 호출을 추상화하지 말라
                2. 서버와 보조를 맞춘 클라이언트의 업그레이드 없이도 서버 인터페이스를 발전시킬 수 있는지 확인하라
                3. 클라이언트가 네트워크 호출을 할 수 있음을 기억하라 (구조 문제)


## REST
- 웹에서 영향 받은 아키텍처 방식. `cf. Richardson Maturity Model`
- resource의 개념
    * 서비스 스스로 알고 있는 것
    * 외부에 보여지는 방식, 내부에 저장되는 방식은 분리됨
- REST와 HTTP
    * HTTP 통신 방식과 REST 아키텍처 방식이 흡사함
    * HTTP가 제공하는 생태계: 캐시 프록시(ex. Varnish), 로드밸런서(ex. mod_proxy), 모니터링 도구들
    * RPC 구현에 쓰일 수 있다 (ex. SOAP)
- 애플리케이션 상태 엔진으로서의 하이퍼미디어
    * 클라이언트와 서버가 결합하지 않게 도와주는 또 다른 원칙
    * 사용자는 원하는 API를 찾기 위해 주소를 직접 파악할 필요가 없고, 하이퍼링크를 타고 이동하며 발견한다.
- JSON, XML, ...
    * JSON은 단순하고 대중적임
    * XML에 비해 단점?
        + JSON 표준은 링크와 관련한 표준이 없으므로, 자체적인 방식 필요 
        + 일부 데이터 추출의 경우 xml이 훨씬 편리한 면이 있음
- 지나친 편의 주의
    * RESTful 웹 서비스를 위한 프레임워크들은 작업 속도를 빠르게 하지만, 외부에 내부 구현을 노출하는 위험을 갖고 있다
- HTTP 기반 REST의 단점
    * 일부 웹 서버 프레임워크가 HTTP의 모든 메서드를 제대로 지원하지 않는다
    * 대규모 트래픽에는 HTTP가 적합할 수 있지만, 낮은 지연 시간을 요구한다면 TCP/UDP/웹소켓 등을 고려하자.


## 비동기 이벤트 기반의 협업 구현
- 기술 선택
    * 고려해야 할 것: 마이크로서비스가 이벤트를 `발산`하는 방법, 소비자가 생성된 이벤트를 `찾는` 방법
    * 대안 1. 메시지 브로커 - RabbitMQ
        + 장점: 고려할 요소 두가지를 한번에 처리
        + 단점: 개발 과정의 복잡성 
    * 대안 2. HTTP를 사용 - ATOM
- 비동기 아키텍처의 복잡성