# 대규모 데이터 처리를 지탱하는 서버/인프라
- 대규모 환경에서 고려해야 할 요소들
    * 확장성
    * 다중화
    * 효율 향상
    * 네트워크
- 웹 서비스 인프라: 서비스의 특성에 따라 추구하는 성격이 다르다.
    * 저비용 고효율 => 100% 신뢰성 보장하지는 않음
    * 확장성, 응답성이 중요한 설계
    * 유연하게 대처할 수 있는 개발 속도
- 클라우드 vs 자체구축 서버
    * 클라우드
        + 장점: 확장의 유연성
        + 단점: 획일적인 호스트 사양, 애매한 로드밸런서, 2010년 기준 때때로 멈춤
    * 자체구축
        + 장점: 유연한 서버 구성, 서비스 요청에 유연한 대응, 병목현상 제어 용이


## 확장성
- 계층과 확장성: 애플리케이션 서버는 확장하기 쉽지만, 데이터 소스는 read의 분산은 용이하나 write는 어렵다.
- 부하 파악과 튜닝: 부하 파악 & 상태 감시용 툴로 병목현상/이상현상 파악이 용이하게 하기 + OS 동작원리를 알고 서버 성능을 올바르게 이끌어내기

## 다중성 확보
- 시스템을 얼마나 멈추지 않을 수 있는가? = SPOF(단일장애점)를 가능한 없애기
- 서버를 여러대 늘어놓는다 = 1~2대 정지해도 충분히 처리할 수 있음
- 로드밸런서로 failover(문제 서버로 요청을 안 보냄), failback(장애가 해결되어 정상이 되면 복구)
- DB의 경우, **멀티 마스터**: Active/StandBy 구성으로 상호 레플리케이션, 문제 발생시 수동 복구

### 시스템 안정화
- 시스템 안정화는 트레이드 오프 관계
    * 안정성 <-> 자원효율
    * 안정성 <-> 속도
    * 한계에 이를 때까지 메모리를 튜닝하면 성능 저하로 장애 발생 가능
    * 한계에 이를 때까지 CPU를 사용하게 하면 서버 한 대가 다운되어도 전체 처리량을 오버하게 되어 장애 발생 가능
- 시스템의 불안정 요인은 수도 없이 많을 수 있다.
    1. 애플리케이션/서비스 레벨: 부하 증가
       * 기능 추가
       * 메모리 누수
       * 지뢰: 문제가 발생하는 프로그램 내의 엔트리 포인트
       * 사용자의 액세스 패턴: 문제가 발생 가능한 사용자의 엔트리 포인트
       * 데이터량 증가
       * 외부연계 추가: 타사 API를 추가하는 경우, 해당 API에 영향받아 다운되지 않게 관리
    2. 하드웨어 레벨: 처리능력 저하: 적절한 헬스 체크 필요
       * 메모리, HDD 장애
       * NIC(네트워크 인터페이스 카드) 장애
- 시스템 안정화 대책
    1. 적절한 버퍼 유지
       * 한계의 70%를 상한선으로 해서 서버 추가/메모리 늘리기 등 대응 
    2. 불안정 요인의 제거
       * SQL 부하 대책: 부하가 높아질 법한 SQL은 격리
       * 메모리 누수 줄이기
       * 비정상 동작 시 자율제어
           + 자동 DoS 판정: 비정상 요청이 너무 많으면 403 페이지 리턴
           + 자동 재시작: 리소스가 지나치게 사용되면 서버 재시작 / 이상이 없어도 2-3일에 한번 자동 재시작
           + 자동 쿼리 제거: 주기적으로 실행중 쿼리를 보고 너무 오래 걸리는 걸 강제로 kill 


## 효율 향상
- 하드웨어 효율 (다중화를 추진하면 이용 효율은 저하)
1. 가상화 기술 (호스트 집적도 상승)
2. 자체제작 서버 (이중화 사양을 가볍게 해서 전체적으로 저비용화)


### 가상화 기술
- 주요 목적: 하드웨어 이용 효율 향상
    * 남은 리소스를 사용하는 게스트 OS 투입
    * ex. CPU 남음 -> 웹서버, IO 남음 -> DB서버, 메모리 남음 -> 캐시서버
    * 유사한 리소스 소비 형태를 보이는 서버는 같이 두지 않음
- 장점
    * 물리적인 리소스 제약에서 해방 & 리소스 동적 변경 & VM 마이그레이션, 복제 용이 => `서버 증설 용이`, `확장성 확보`
    * 소프트웨어 레벨에서 호스트 제어 가능 => `비정상 동작 시 문제 국소화`, `운용 비용 저하`, `고가용성 확보`
- 단점
    * 성능상 오버헤드 (용도에 따라 치명적인 병목이 발생 가능하므로, 검토 필요)
    * 구현상 결함으로 갑자기 네트워크가 단절되는 경우 일부 있음

### 하드웨어
- 무어의 법칙
- 저가 하드웨어를 유용하게 이용 가능 (관리기능 최소화, 다중코어, 대량 메모리, 높은 IO성능)


## 네트워크
### 네트워크 분기점
1. 라우터의 한계
    - 1Gpbs(=평균 패킷 길이가 300바이트이므로 30만pps)의 한계
    - 대책: PC 라우터를 나열(병렬)하거나, 박스형 라우터를 사용하기
2. 1서브넷당 500호스트의 한계
    - 하나의 서브넷에 배치 가능한 호스트가 약 500개
    - 서브넷 내에 호스트가 많을수록 브로드캐스팅 패킷도 늘어나 CPU 부하
* 최선의 대책: **네트워크 구조 계층화**
    - 가장 작은 것은 액세스 계층
    - 그 다음은 디스트리뷰션 계층
    - 가장 위가 코어 계층/OSPF 영역
    - => 가장 작은 서브넷에서 100~200대로 억제하고 그 위로 약 10배씩 다룸
3. 글로벌화
    - 대용량 미디어 전송을 위해서는 하나의 데이터 센터로는 모자라다
    - CDN을 두고 사용하면 응답 속도가 크게 개선됨

### 1Gpbs 이상의 세계
- [AS 번호](https://xn--3e0bx5euxnjje69i70af08bea817g.xn--3e0b707e/jsp/resources/asInfo.jsp)(망식별번호) 보유
    * 인터넷의 확산으로 네트워크의 크기가 커지고 라우팅 정보가 방대해지자, 전체 네트워크를 하나의 라우팅 프로토콜로 관리하는 것이 불가능해짐.
    * 네트워크의 관리범위를 계층적으로 체계화하고 단위 별로 라우팅 정보를 효율적으로 관리하기 위하여 AS(자율 시스템)가 도입됨.
    * AS가 도입되면서 라우터는 인터넷에 있는 모든 네트워크의 도달가능정보를 가질 필요 없이 자신의 AS 내에 있는 라우터에 대한 도달가능정보만을 가짐.
    * 라우팅 프로토콜은 AS 내부에서 도달가능정보를 주고받기 위해 사용하는 프로토콜(IGP), 외부의 AS와 통신을 하고자 할 때 도달가능정보를 교환하기 위해 사용하는 프로토콜(EGP)로 나뉘게 되었고, EGP에는 BGP 등이 있음.
- [IX](https://www.datanet.co.kr/news/articleView.html?idxno=40659)(인터넷 교환 노드) 에 접속해서 트래픽 교환
    * ISP는 인터넷 사용자에게 서비스를 제공함
    * NSP는 ISP들에게 고속 인터넷 회선을 제공함
    * IX는 ISP와 NSP의 인터넷 트래픽을 상호 교환해줌. 즉 인터넷 계층구조의 최상부끼리 접속이 용이하게 트래픽을 교환해주는 것
- BGP로 라우팅 제어