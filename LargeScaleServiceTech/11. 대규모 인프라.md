# 대규모 데이터 처리를 지탱하는 서버/인프라
- 대규모 환경에서 고려해야 할 요소들
    * 확장성
    * 다중화
    * 효율 향상
    * 네트워크
- 웹 서비스 인프라: 서비스의 특성에 따라 추구하는 성격이 다르다.
    * 저비용 고효율 => 100% 신뢰성 보장하지는 않음
    * 확장성, 응답성이 중요한 설계
    * 유연하게 대처할 수 있는 개발 속도
- 클라우드 vs 자체구축 서버
    * 클라우드
        + 장점: 확장의 유연성
        + 단점: 획일적인 호스트 사양, 애매한 로드밸런서, 2010년 기준 때때로 멈춤
    * 자체구축
        + 장점: 유연한 서버 구성, 서비스 요청에 유연한 대응, 병목현상 제어 용이


## 확장성
- 계층과 확장성: 애플리케이션 서버는 확장하기 쉽지만, 데이터 소스는 read의 분산은 용이하나 write는 어렵다.
- 부하 파악과 튜닝: 부하 파악 & 상태 감시용 툴로 병목현상/이상현상 파악이 용이하게 하기 + OS 동작원리를 알고 서버 성능을 올바르게 이끌어내기

## 다중성 확보
- 시스템을 얼마나 멈추지 않을 수 있는가? = SPOF(단일장애점)를 가능한 없애기
- 서버를 여러대 늘어놓는다 = 1~2대 정지해도 충분히 처리할 수 있음
- 로드밸런서로 failover(문제 서버로 요청을 안 보냄), failback(장애가 해결되어 정상이 되면 복구)
- DB의 경우, **멀티 마스터**: Active/StandBy 구성으로 상호 레플리케이션, 문제 발생시 수동 복구

## 시스템 안정화
- 시스템 안정화는 트레이드 오프 관계
    * 안정성 <-> 자원효율
    * 안정성 <-> 속도
    * 한계에 이를 때까지 메모리를 튜닝하면 성능 저하로 장애 발생 가능
    * 한계에 이를 때까지 CPU를 사용하게 하면 서버 한 대가 다운되어도 전체 처리량을 오버하게 되어 장애 발생 가능
- 시스템의 불안정 요인은 수도 없이 많을 수 있다.
    1. 애플리케이션/서비스 레벨: 부하 증가
       * 기능 추가
       * 메모리 누수
       * 지뢰: 문제가 발생하는 프로그램 내의 엔트리 포인트
       * 사용자의 액세스 패턴: 문제가 발생 가능한 사용자의 엔트리 포인트
       * 데이터량 증가
       * 외부연계 추가: 타사 API를 추가하는 경우, 해당 API에 영향받아 다운되지 않게 관리
    2. 하드웨어 레벨: 처리능력 저하: 적절한 헬스 체크 필요
       * 메모리, HDD 장애
       * NIC(네트워크 인터페이스 카드) 장애
- 시스템 안정화 대책
    1. 적절한 버퍼 유지
       * 한계의 70%를 상한선으로 해서 서버 추가/메모리 늘리기 등 대응 
    2. 불안정 요인의 제거
       * SQL 부하 대책: 부하가 높아질 법한 SQL은 격리
       * 메모리 누수 줄이기
       * 비정상 동작 시 자율제어
           + 자동 DoS 판정: 비정상 요청이 너무 많으면 403 페이지 리턴
           + 자동 재시작: 리소스가 지나치게 사용되면 서버 재시작 / 이상이 없어도 2-3일에 한번 자동 재시작
           + 자동 쿼리 제거: 주기적으로 실행중 쿼리를 보고 너무 오래 걸리는 걸 강제로 kill 