# 알고리즘 실용화

## 알고리즘과 평가
- 유한한 컴퓨터 자원을 효율적으로 사용하기 위함
- 엔지니어 간 공통 언어
- Order 표기로 성능을 평가함 (ex. O(1) < O(logn) < O(nlongn) < O(n^2) < O(n^k) < O(2^n))
- 시간계산량(실행시간, 단계, 횟수), 공간계산량(메모리 사용량)
- 알고리즘에서 자주 사용하는 조작에 맞춘 데이터 구조 선택의 필요
- 구현을 생각하면 Order 표기가 전부가 아니다.
    * 간단할 경우에는 상수항 무시 가능 but 복잡해지면 캐시 올리기 쉬운지, 분기 예측이 발생하지 않는지 등을 고려해야 함
    * ex. 퀵소트는 알고리즘 특성상 cpu 캐시 히트가 잘되어 다른 정렬보다 유리
    * 참고. 분기 예측: 다음 실행될 조건문이 어떤 곳으로 분기할 것인지를 확실히 알게 되기 전에 미리 추측하는 CPU 기술
- 최적화는 문제가 무엇인지 파악한 후에 하기
    * 상수항을 줄이는 노력보다 알고리즘 자체를 개선하는 게 나은 경우
    * 물리적 리소스가 절대적으로 부족한 경우
    * 복잡한 알고리즘이 오버인 경우
        + 데이터가 그렇게 많지 않아서 등 (건수가 '적다'는 것 역시 사람의 직감보다는 측정해보는 게 좋음)
        + ex. 하테나 북마크: 증분 검색에 suffix array를 사용하면 전처리하는 데 시간이 오래 걸려서 속도 면에서 별로였는데, 내장 SQLite에 like 검색을 하니 간단했다. 브라우저 성능이 좋아져서 수만 건 정도의 처리가 가능했기 때문.
    * CPU가 여유 있고 I/O가 바쁜 경우는 많으므로, 압축으로 I/O 부하를 줄여주고 CPU에 압축 일을 떠맡겨 처리량을 높일 수 있다.
    * ...
- 구현에 라이브러리를 사용한다면, 사용할 경우에 따라 적합한 알고리즘이 다를 수 있으므로 구현을 확인해보기


## 키워드 링크
1. 모든 단어의 정규식 패턴 매칭
    * 정규표현 컴파일 처리 문제 -> 캐싱으로 회피
    * 패턴 매칭 처리 문제 -> 캐싱으로 해결이 어려움
        + 패턴매칭은 NFA엔진을 사용하는데, 이게 앞에서부터 계속 시도하는 단순한 방법이라서
2. Trie 로 매칭 구현 변경
    * 트리구조의 일종
    * 공통 접두사를 모아서 구조를 이루어 불필요한 것을 배제함
    * 문자열 집합을 트리 구조로 효율적으로 저장
    * 이 경우, 매칭이 안 되면 패턴을 다 보는 게 아니라 처음부터 실패
3. AC법 도입
    * Trie에 failure link를 추가해서 다음 패턴을 찾는 것을 빠르게 함
    * 계산량이 사전 크기에 의존하지 않음
4. RegExp:List로의 치환
    * Trie와 유사한 관점으로 공통 접두사/접미사를 정리한 정규표현 사용
    * 개발자가 사용하던 언어적 장점 & 유연성
- 고찰
    * 초기에 심플한 구현으로 시작해서 요구사항에 따른 변경 추가
    * 문제의 회피는 가능하나 어느 순간에는 근본적인 문제 해결 필요


## 북마크 기사 분류
- 나이브 베이즈: 특정 문서 D가 확률적으로 어떤 카테고리 C에 속하는 게 그럴듯한가? 
- P(C|D) = `P(D|C)` `P(C)` / P(D)
    * P(D|C): D를 단어로 나눠서 단어마다 어느 카테고리로 분류됐는가 횟수 저장 -> 근사값 계산
    * P(C): 학습 데이터에서 여러 데이터가 어떤 카테고리로 분류됐는가 저장
- 대규모 데이터에서 의미 있는 데이터를 일괄 추출하거나, 특징을 간단하게 가지고 있다가 나중에 이용할 수 있다.
    * 참고. 오타 수정 제안: 단어 목록간 distance를 구해 짧은 순으로 정렬