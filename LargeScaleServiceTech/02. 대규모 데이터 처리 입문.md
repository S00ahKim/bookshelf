# 02. 대규모 데이터 처리 입문
> 대규모 데이터란 무엇인가?

### 대규모 데이터의 어려운 점
> 너무 많은 데이터가 있는 경우에는 id를 지정해서 검색해도 인덱스를 타지 않으면 **시간이 너무 오래 걸린다**.
1. [탐색 속도가 느리다] 메모리 내에서 계산할 수 없다.
    * 디스크를 읽는 것은 메모리에 비해 10만~100만 배 정도의 차이가 난다. (마이크로초 vs 수 밀리초)
    * 메모리는 전기적 부품이지만, 디스크는 원반을 회전하는 등 물리적 동작을 요하기 때문이다. (ㄱ-ㄴ-ㄷ 있을 때, ㄴ 찾고 ㄱ 찾으려면 한바퀴 돌아야 함)
2. [전송 속도도 느리다]
    * 메모리든 디스크든 CPU와 버스로 연결됨
    * 메모리-CPU 간 버스는 빠른 속도 / 디스크-CPU 간 버스는 느린 속도 (100배 이상 차이)
    * 회전하지 않는 SSD의 경우 탐색은 좀 빠르지만, 전송 속도 때문에 메모리만큼의 속도가 안 나옴
- 단일 서버에서 효율적으로 운용한 뒤에 다중 서버의 부하 분산이 의미를 가짐
- 병목 규명은 load average 확인 -> CPU와 I/O 중 병목 원인을 조사
    * CPU 병목
        + 다른 부분은 문제가 없는데 CPU 처리량이 많음 -> `서버 증설` / `로직 개선`
        + 프로그램이 폭주해서 필요 이상의 부하가 발생  -> `오류 제거`
    * I/O 병목
        + 입출력이 많음
        + 스왑 발생으로 디스크 액세스 [참고](https://github.com/S00ahKim/Skill-Inventory/blob/master/OS/09%20Main%20Memory.md#%EC%8A%A4%EC%99%80%ED%95%91)
        + 스왑 없이 디스크 입출력이 많음 = 캐시의 메모리 부족 
        + -> `메모리 증설` / `데이터 분산` / `캐시서버 도입` / `프로그램 개선`
        + 프로그램 오류로 메모리를 지나치게 사용 -> `프로그램 개선`
- 튜닝이란 원래 성능 이상을 내는 것이 아니라, 병목을 제거하여 최대한의 성능을 내게 하는 것


### 서버 규모 확장하기
- 스케일 아웃 > 스케일 업
    * 웹 서비스에 적합한 형태
    * 비용이 저렴
    * 시스템 구성에 유연성이 있음 (필요할 때 적절하게 늘리고 줄이는 빠른 상황 대처 가능)
- 프록시 ---(요청)---> 웹 애플리케이션 `[CPU 부하]` --(요청)--> DB `[I/O 부하]`
    * 애플리케이션 서버는 데이터를 분산해서 갖고 있지 않으므로, 서버들 구성만 동일하면 분산 가능
    * DB 서버는 동기화에 대한 문제가 있기 때문에 간단하게는 분산이 어려움


### 대규모 데이터를 다루는 방법
1. 프로그램을 작성할 때의 요령
    1. 메모리에서 처리를 마치게 하기
        * 디스크 탐색 최소화
        * 국소성 활용 분산 실현
    2. 데이터량 증가에 강한 **알고리즘** 사용하기
        * O(n) -> O(logn)
    3. 데이터 **압축**, **검색** 기술 등 테크닉 활용
        * parquet로 저장할 때 데이터량이 줄었음 -> 탐색 횟수 감소
        * 데이터가 압축되면 메모리에 캐싱하기 쉽다
        * DB에만 검색을 맡길 수 없다면, 특수 목적으로 검색 엔진 개발하기
2. 프로그램 개발의 기초 전제
    1. OS 캐시
    2. 분산을 고려한 RDBMS 운용
    3. 대규모 환경에서의 알고리즘과 데이터 구조 사용