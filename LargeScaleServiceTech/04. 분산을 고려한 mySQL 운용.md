# 분산을 고려한 mySQL 운용

### 1. OS 캐시 활용
- 전체 데이터 크기에 유의 (물리 메모리보다 가능한 작게 & 메모리 증설)
- 스키마 설계가 데이터 크기에 미치는 영향 고려 필요
- 정규화는 데이터 용량을 줄이는 데 도움이 되지만, 쿼리 복잡성으로 속도가 떨어질 우려가 있다

### 2. 인덱스를 적절하게 설정
- mySQL 인덱스의 데이터 구조는 기본적으로 B+ Tree
- B Tree에서 파생된 구조
    * 삽입과 삭제를 반복해도 치우침이 없음 (평형 트리)
    * 하드 디스크 상에 구축하기에 알맞은 구조 (노드 크기를 디스크의 1블록만큼 지정해서 seek 최소화)
- 각 노드 내에 자식 노드로의 포인터만 갖고, 실제 값은 리프 노드에만 있음. 데이터 저장에 최적화
- 인덱스 효과: O(logn)의 계산량 + 적은 디스크 seek 횟수
- 데이터 크기가 너무 커지면 인덱스 없이는 결과 반환이 어려움 (크기가 작은 경우에는 mySQL 자체적으로 최적화)
- 인덱스가 적용되는 칼럼
    * where, order by, group by에 지정된 칼럼에 사용됨
    * 단, 한 번의 쿼리에는 하나의 인덱스만 사용한다. 두 개 칼럼에 인덱스를 태우려고 하면 복합 인덱스 설정 필요.
    * 명시적으로 추가한 인덱스, 기본키, 유니크 제약이 걸린 칼럼 (`show index`)
    * `explain SQL` 명령어로 인덱스가 작용하는지 확인할 수 있다.
        + rows: 쿼리가 탐색하는 행수
        + Extra: 보통 using where이지만, 이외의 경우 레코드 정렬에 외부정렬/임시테이블 사용이 필요하다는 의미로, 튜닝 필요

### 3. 확장을 전제로 시스템 설계
- replication
    * mySQL에서 기본으로 지원하는 복제 기능
    * 마스터에 쓴 내용을 슬레이브가 폴링해서 동일한 내용으로 자신을 갱신하는 기능
    * 갱신 쿼리는 마스터에, 참조 쿼리는 로드밸런서->슬레이브에
    * 마스터는 확장하지 않지만, 갱신 쿼리가 많아지면 테이블 분할/키밸류 스토어 등으로 구현 변경
        + RDB의 장점은 복잡한 통계 처리, 범용 정렬 처리 등이 가능
        + 키밸류 스토어는 오버헤드가 적고 빠르고 확장하기 쉬움
    * 슬레이브는 확장하면 됨 (단, 서버 대수보다 메모리에 중점)
- 스케일 아웃과 파티셔닝
    * 파티셔닝
        + 테이블 둘을 서로 다른 서버에 놓아서 분산
        + 메모리 증설이 불가능할 경우 선택하는 전략
        + 장: 부하가 내려가고, 국소성이 증가해서 캐시 효과가 높아진다.
        + 단: 운용이 복잡해지고, 고장 확률이 증가하고, 비용이 증가할 수 있다.
    * mySQL에는 서로 다른 서버에 있는 테이블을 join할 수 없다
        + 서버 분할이 없을 것으로 예상되는 테이블 간에만 조인 쿼리 사용
    * 분할된 서버 각각의 역할을 파악하고 있지 않으면 복구에 시간이 더 걸림
    * 서버 A 4대를 2개로 분할하면 8대가 된다. 서버가 늘어나면 고장 횟수도 늘어난다.
    * 서버 4대 = 마스터, 슬레이브, 고장 대비 백업 슬레이브, 고장 시 데이터 복사할 슬레이브(for 무정지 복구)
    * 무엇이 더 저렴하고, 편할까?

### cf. mySQL failover

### cf. mySQL engine
- 여러 스토리지 엔진이 존재하나, 가장 많이 사용하는 것은 MyISAM과 InnoDB
- MyISAM
    * 단순한 구조 -> 전체적으로 속도가 더 빠름 (특히 select 작업)
    * Full-text 인덱싱 가능
    * Table Level-Lock (쓰기 작업 느림)
    * 복구 능력 나쁨 (무결성 보장 X)
- InnoDB
    * 복잡한 구조
    * 외래키, 제약조건, 동시성 제어 등 다양한 기능 지원
    * Row Level-Lock
    * 복구 능력 좋음