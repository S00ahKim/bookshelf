# 오브젝트와 의존관계
- 스프링의 관심: 객체지향 프로그래밍
- 오브젝트: 생성, 관계, 사용, 소멸 `cycle` + `설계`, `구현` 방법 + `단위` + `등장` etc.
- 스프링이 제공하는 것: (오브젝트를 다루는 기준, 실용적인 전략, 검증된 베스트 프랙티스) as 프레임워크

## 1.1 초난감 DAO
> - Data Access Object: DB를 사용해 데이터 조회/조작하기 위한 오브젝트
> - cf. Data Transfer Object: 계층 간 데이터 교환을 하기 위한 순수한 데이터 오브젝트 (getter, setter만 가짐)

### User
> 만든 목적: 사용자 정보를 저장하는 오브젝트
- **자바빈 규약**을 따르는 오브젝트를 이용하면 편리
    1. defulat 패키지가 아닌 패키지 하위에 있는 클래스
    2. 기본 생성자가 존재 (no-arg constructor)
        + 툴/프레임워크에서 **리플렉션**을 이용해 오브젝트를 생성하기 때문에 필요
            * 구체적인 클래스 타입을 알지 못해도, 그 클래스의 메소드/타입/변수들에 접근할 수 있도록 해주는 자바 API
            * 대개 프레임워크 단에서 런타임 때 동적으로 정보를 가져오기 위해 사용함 ex. `DI`, `어노테이션`
    3. property는 모두 private으로 선언
    4. getter/setter를 통해서 properties를 조작
    5. Serializable을 implement 하여 직렬화 가능

### UserDao
> 만든 목적: 사용자 정보를 DB에 쿼리할 수 있는 오브젝트
- DB와 커넥션을 맺고 질의하고 오브젝트에 세팅하고 리소스를 반환하는 등의 작업을 함
- 자신을 엔트리 포인트로 설정해 직접 실행이 가능하게 해주는 스태틱 메소드 main을 사용해서 검증하면 동작에는 문제 없음
- 그럼에도 이 코드는 개선해야 하는 **초난감 DAO**다. 스프링은 개선 과정을 돕는 매개체다.


## 1.2 DAO의 분리

### 관심사의 분리
> 관심이 같은 것은 모으고, 관심이 다른 것은 떨어뜨리자
- 오브젝트에 대한 설계와 이를 구현한 코드는 끊임없이 변한다.
    * 고로 개발자는 반드시 **미래의 변화를 고려해야** 한다.
    * 미래의 변화를 잘 준비하면 수정 요청에 대해 **수정 부분은 작고**, **변경이 나머지 기능에 문제를 일으키지 않는다**는 것을 빠르게 검증할 수 있다.
    * **변화는 한 번에 한 가지 관심사항에 집중해서 일어난다**.
- 객체지향 기술은 추상세계를 효과적으로 구성하고, 자유롭고 편리하게 **변경, 발전, 확장**할 수 있다는 장점이 있다.

### UserDao에 적용한다면?
- UserDao는 크게 `커넥션 획득`, `질의 실행`, `리소스 반환`으로 관심사를 나눌 수 있다.
- 리팩토링의 필요
    * 리팩토링? 나쁜 냄새가 나는 기존의 코드를 외부의 동작 방식에 변화 없이 내부 구조를 변경해서 재구성하는 작업
        + 정말 동작 방식에 변화가 없었는지 테스트 코드로 검증해야 한다.
    * 중복 코드가 많은 경우 => `메소드 추출`
    * 구현 방법이 사용처마다 달라질 수 있는 경우 => `템플릿 메소드 패턴` (상위 클래스로 분리해서 그 안에 기본적 로직의 흐름을 두고 일부 구현을 하위 클래스에 위임), `팩토리 메소드 패턴` (하위 클래스가 구체적인 오브젝트 생성 방법을 결정)
- 디자인 패턴의 필요
    * 디자인 패턴? 자주 맞닥뜨리는 문제 해결을 위한 재사용 가능한 솔루션
    * 경제적 커뮤니케이션: 간결하게 설계의 의도와 해결책을 함께 설명 가능
    * 대개의 확장성 추구 방법이 `클래스 상속` or `오브젝트 합성`
    * 패턴을 적용할 상황, 해결해야 하는 문제, 솔루션의 구조, 요소들의 역할, 핵심 의도 등 파악하면 좋음
- **상속**을 사용한 관심사 분리의 한계점
    * 이미 상속을 하고 있는 경우 & 나중에 상속 적용하기 어려움
    * 상속은 여전히 긴밀한 결합인 편임 (상위 클래스 수정 -> 모든 하위 클래스 수정 ㅠㅠ)
    * 상위 클래스가 많은 하위 클래스에 적용 가능한 부분과 특정 하위 클래스에만 적용 가능한 부분을 모두 포함함


## 1.3 DAO의 확장
- 변화의 성격이 다른 관심: 변화의 이유, 시기, 주기 등이 다르다
    * ex. A는 쿼리문이 바뀔 때, B는 사용하는 DB가 바뀔 때 변경된다면 변화의 성격이 다르다.
- 또 다른 관심사의 분리 방법: **클래스 분리**
    * 특정 관심사와 관련한 부분을 완전히 독립적인 별도의 클래스로 만들기
    * 그렇게 만든 클래스를 필요한 곳에서 이용하게 하기
    * ex. `UserDao` 와 `DbConnectionMaker` 의 분리
- 클래스를 분리하면 분리된 클래스에 종속되기 때문에 상속이 제공했던 유연한 변경과 확장이 어려워진다.
    * 왜? *종속된 클래스에 대해 너~무 많이 알고 있어서*!
    * ex. 메소드 이름이 분리된 클래스의 관심사를 가진 다른 클래스와 다르다면?
    * ex. 아예 클래스의 관심사를 가진 다른 클래스에 종속되게 하고 싶다면?
- 해결책 1: 분리된 클래스끼리 긴밀하게 연결되지 않도록 추상적인 느슨한 연결고리 `인터페이스`를 만든다.
    * 추상화? 어떤 것들의 공통적인 성격을 뽑아내서 이를 따로 분리하는 작업
    * 인터페이스로 기본적인 명세만 정의해두고, 구현 내용을 필요에 따라 변경해서 사용
- 해결책 2: `관계 설정의 책임`을 분리한다.
    * 종속될 클래스를 결정하는 것 역시 관계를 설정해주는 것에 관한 관심이므로, 분리한다.
    * 관계 설정이란 인터페이스 없이 다른 클래스를 직접 사용한다는 것 => 오브젝트와 오브젝트의 관계를 설정
    * 관계 설정 책임을 클라이언트에게 넘기고, 다형성을 활용하여 관계 설정한다.
      ```java
      // UserDao 바깥, 즉 UserDao를 사용하는 측에서 관계를 설정한다.
      // UserDao의 생성자의 파라미터가 ConnectionMaker 인터페이스 타입이고
      // fooConnectionMaker는 ConnectionMaker를 구현한 FooConnectionMaker의 인스턴스
      UserDao user = new UserDao(fooConnectionMaker);
      ```

### 원칙과 패턴
- 개방 폐쇄 원칙
    * 객체지향 설계 원칙 중 하나 (cf. `SOLID`)
    * 클래스나 모듈은 확장에는 열려 있고 (자신의 관심사와 무관한) 변경에는 닫혀 있어야 한다.
- 높은 응집도와 낮은 결합도
    * 응집도가 높다 = 변화가 있을 때 모듈에서 많은 부분이 변한다.
    * 결합도가 낮다 = 변화가 있을 때 외부에 변화를 요구하는 정도가 낮다.
- 전략 패턴
    * 변경이 필요한 부분을 분리하여 필요에 따라 바꿔서 사용할 수 있도록 하는 디자인 패턴


## 1.4 제어의 역전 (IoC)
- UserDao의 클라이언트를 UserDaoTest에 두었는데, 이는 `테스트` + `관계 설정` 이라는 2개 책임을 가진 것.
- 객체의 생성 방법을 결정하고 만들어진 오브젝트를 돌려주는 역할을 하는 `팩토리` 를 만들어 책임을 분리할 수 있다.
- 팩토리는 실제 로직을 가진 오브젝트들의 관계를 설정하는 **설계도**의 역할을 한다.
- 일반적으로 프로그램의 흐름은 자신이 사용할 오브젝트를 스스로 선택/생성하는 것이다. (사용자가 제어하는 구조)
- 제어의 역전이란 오브젝트 자신은 어디서 사용되는지 모른 채 제어 권한을 다른 대상에 위임하는 것이다. (특별한 오브젝트가 제어하는 구조)
    * ex. 컨테이너 안에서 동작하는 구조들 (서블릿, JSP, EJB)
    * ex. 상위 템플릿 메소드가 필요할 때 기능을 호출하는 템플릿 메소드 패턴
    * ex. 프레임워크 (애플리케이션 코드는 라이브러리를 사용하고, 프레임워크는 애플리케이션 코드를 사용한다.)
- 제어의 역전에서는 프레임워크/컨테이너와 같이 **컴포넌트의 생성, 관계설정, 사용, 생명주기 관리 등을 담당하는 오브젝트**가 필요하다. 하나하나 만들기에는 규모가 커질수록 어렵기 때문에, 애플리케이션 전반에 걸쳐 IoC를 본격적으로 사용하려면 프레임워크의 도움을 받는 것이 유리하다.


## 1.5 스프링의 IoC
> - 스프링에서는 애플리케이션 컨텍스트가 IoC를 담당한다.
> - 스프링 애플리케이션은 애플리케이션 컨텍스트와 설정 정보를 따라 만들어지고 구성된다.
- 빈
    * 스프링이 IoC 방식으로 직접 관리하는 오브젝트
    * 애플리케이션의 모든 오브젝트가 아니라, 스프링이 직접 생성/제어를 담당하는 오브젝트만 빈이라고 부른다!
- 빈 팩토리
    * a.k.a. IoC 컨테이너
    * IoC를 담당하는 핵심 컨테이너 (등록, 생성, 조회, 제공, 관리 등)
    * 일반적으로 빈 팩토리를 바로 사용하기보다 이를 확장한 애플리케이션 컨텍스트를 이용함
- 애플리케이션 컨텍스트
    * a.k.a. 컨테이너, 스프링 컨테이너, 스프링
    * 빈 팩토리를 **확장**한 IoC 컨테이너 (`BeanFactory` 인터페이스를 상속)
    * 각종 부가 서비스 추가 제공
    * 설정 정보를 담고 있는 무언가를 가져와 활용하는 범용 IoC 엔진
        + 직접 오브젝트를 생성하고 관계를 맺어주는 코드는 없다.
        + 생성 정보와 연관관계 정보는 별도의 설정 정보에서 얻어온다.
        + 때로 외부의 오브젝트 팩토리에 그 작업을 위임하고 결과를 갖다 사용하기도 한다.
    * ApplicationContext 타입의 오브젝트
        + 구현은 여러 가지가 있을 수 있다.
        + `@Configuration`이 붙은 자바 코드를 설정 정보로 사용하는 경우엔 AnnotationConfigApplicationContext를 이용
    * 사용 방식
        1. 애플리케이션 콘텍스트가 설정 정보에 정의된 빈 생성 메소드를 호출해서 오브젝트를 가져온다.
        2. 클라이언트(사용처)가 애플리케이션 콘텍스트에서 getBean()으로 호출한다.
        3. 애플리케이션 콘텍스트가 가지고 있던 빈을 전달한다.
    * 장점
        + 클라이언트가 구체적인 팩토리 클래스를 몰라도 된다.
        + 관계 설정 외에도 오브젝트 생성 방식/시점/전략 설정, 자동생성, 후처리, 조합, 인터셉팅 등 다양한 기능을 제공한다.
        + 빈을 검색하는 다양한 방법(메소드, 타입, 애노테이션 설정 등)을 제공한다.
- 설정 정보/설정 메타정보
    * 설정 정보 클래스에 `@Configuration` 애노테이션을 붙이고, IoC용 메소드에 `@Bean` 애노테이션을 붙인다.
    * 스프링 컨테이너가 IoC를 적용하기 위해 사용하는 메타 정보


## 1.6 싱글톤 레지스트리와 오브젝트 스코프
- 동일성(identity)과 동등성(equality)
    * 동일성: == 비교, 실제로 하나의 오브젝트만 존재
    * 동등성: .equals() 비교, 실제로 두 개의 오브젝트가 존재
- 스프링의 애플리케이션 컨텍스트는 **싱글톤 레지스트리**다.
    * 즉 (별다른 설정을 하지 않으면) 오브젝트는 모두 싱글톤으로 만들어지고, 매 요청에 같은 오브젝트를 리턴한다.
    * 서블릿은 대부분 멀티스레드 환경에서 싱글톤으로 동작한다. => **무상태**`stateless` 여야 한다!
        + cf. 메소드 안의 로컬 변수는 매번 독립적 공간이 생기므로 멀티 스레드가 값을 덮어쓰지 않음
        + `읽기 전용 정보`나 `자신이 사용하는 다른 싱글톤 빈`만 인스턴스 변수에 저장한다.
    * 왜? 스프링으로 개발하는 시스템은 서버환경에서 초당 수십~수백 개의 요청을 처리하는 계층형 구조의 복잡한 로직을 가진 애플리케이션이기 때문에 성능 보장을 위해
- 디자인 패턴으로서의 싱글톤의 한계
    * 안티패턴?!
    * 보통 private 생성자를 두는 식으로 구현하는데, 그러면 상속할 수 없다.
    * mock 오브젝트로 만들어 테스트하기 어렵다.
    * 서버환경에서 싱글톤을 보장하지 못한다.
    * 전역 상태로 사용되어 바람직하지 못하다. (휴먼 에러 유발, 동시성 문제 등)
- 스프링은 직접 싱글톤 형태의 오브젝트를 만들고 관리하는 기능을 제공한다.
    * 스태틱 메소드와 private 생성자를 두는 비정상 클래스가 아니라 **평범한 자바 클래스를 싱글톤으로 활용**하게 해준다.
    * 왜? 오브젝트 생성 권한이 모두 애플리케이션 컨텍스트에게 있기 때문
    * 싱글톤 한계 극복: 객체지향 설계 적용 가능, 자유로운 테스트 등
- 빈의 스코프(생성, 존재, 적용되는 범위)
    * 싱글톤 스코프: 기본 스코프. 컨테이너 내에 한 개의 오브젝트만 만들어짐. 스프링 컨테이너가 존재하는 동안 유지됨.
    * 프로토타입 스코프: 컨테이너에 빈을 요청할 때마다 새로운 오브젝트를 만들어줌.
    * 요청(request) 스코프: 새로운 HTTP 요청이 생길 때마다 생성.
    * 세션 스코프: 웹의 세션과 유사.


## 1.7 의존관계 주입(Dependency Injection)
> 오브젝트 레퍼런스를 외부로부터 주입받아 여타 오브젝트와 **다이나믹한** 의존관계를 만듦.
- DI는 스프링 IoC 방식의 명확한 의도 표현
    * 자신이 사용할 오브젝트에 대한 선택, 생성 제어권을 외부에 넘김
    * 자신은 수동적으로 주입받은 오브젝트를 사용함 
- 의존관계
    * 방향성 필요 (ex. A -> B; A가 B에 의존한다.)
    * 의존함은 의존 대상의 **변경**이 사용하는 쪽에 **영향을 미치는 것**을 의미함
    * 역은 성립하지 않음. A는 B에 의존하지만, B는 A에 의존하지 않음.
- 구분
    * 설계상의 관계
        + 모델/코드에서 드러나는 관계
        + 인터페이스에 대해서만 의존관계를 만들어 구현 클래스와의 관계를 느슨하게 할 수 있다. 
            * = 낮은 결합도
            * = 변경에서 좀더 자유로워짐
    * 실체화된 관계
        + a.k.a. 런타임 의존관계, 오브젝트 의존관계
        + **런타임 시에** 오브젝트 사이에서 만들어지는 의존관계
        + 개발자가 미리 정할 수는 있지만, 설계상으로는, 느슨한 의존관계는 런타임 시에 누구와 관계 맺어지는지 알 수 없다.
- 의존관계 주입은 아래 조건을 충족하는 작업이다.
    1. 설계(클래스 모델/코드)에는 런타임 시점의 의존관계가 드러나지 않도록 **인터페이스에만 의존**한다.
    2. 런타임 시점의 의존관계는 **제 3의 존재**(관계설정책임을 가진 오브젝트. 컨테이너/팩토리 등)가 결정한다.
    3. 의존관계는 사용할 오브젝트에 대한 레퍼런스를 **외부에서 제공(주입)**하여 만든다.
        + 이때도 구체적인 클래스로 파라미터 타입이 선언된 게 아니라, 인터페이스 타입으로 선언되어 있어야 함 
- 의존관계 검색
    * 런타임에 의존관계를 맺을 오브젝트를 결정하고 생성하는 것은 외부 컨테이너에게 맡김 (IoC)
    * 관계 맺는 오브젝트는 메소드/생성자 주입 대신 **스스로 컨테이너에게 요청**함
    * 주입의 장점을 모두 갖고 있지만, 코드상으로 검색이 더 복잡하다. (코드 안에 팩토리 클래스나 스프링 API가 드러남)
    * 그러나 꼭 써줘야 하는 순간이 있다!
        + 테스트 코드
        + 애플리케이션 기동 시점, main()은 DI 받을 방법이 없기 때문에
        + 서버환경에서 요청을 받을 때마다 서블릿이 오브젝트를 가져오기 위해
    * 검색하는 오브젝트는 꼭 빈이 아니어도 된다. 주입은 검색하는 쪽과 검색되는 쪽 모두 빈이어야 한다.
- DI의 장점과 응용
    * 다른 책임을 가진 쪽에서 변경이 일어나도 영향을 받지 않음
    * 변경을 통한 다양한 확장에 열려 있음
    * 로컬 환경과 리얼 환경을 최소한의 수정으로 간편하게 분리할 수 있음
    * 부가 기능을 추가하고 싶을 경우 역시 최소한의 수정으로 끼워넣을 수 있음
- DI 방법
    * 생성자 주입
        + 필요한 모든 인스턴스 변수를 세팅할 수 있음
    * 수정자 주입
        + setter 메소드의 파라미터로 전달된 값을 내부의 인스턴스 변수에 저장
        + 한 번에 한 개의 파라미터만 가질 수 있음
        + 스프링이 많이 이용해온 방식
        + IDE에 자동생성 기능 있음 ex. intelliJ `⌘` `N` `enter`
    * 일반 메소드 주입
        + 여러 개의 파라미터를 가짐 (필요한 것만 받을 수 있음)


## 1.8 XML을 이용한 설정
- 범용 DI 컨테이너를 사용할 때 오브젝트 사이의 의존 정보를 모두 자바로 만들기엔 번거롭고 구조의 중복이 있다.
- 간단하게 XML로 DI 의존관계 설정정보를 만들 수 있다.
    * 다루기 쉬운 텍스트 파일
    * 쉽게 이해할 수 있음
    * 컴파일 등 별도의 빌드 작업이 없음
- `@Configuration`:`@Bean` = `<beans>`:`<bean>`
- 애플리케이션 컨텍스트가 사용하는 XML 설정파일의 이름은 관례를 따라 `applicationContext.xml` 으로 만든다.
- 많이 사용되는 기능은 인터페이스와 구현 클래스가 이미 존재하니까 갖다 쓰면 충분하다.
- `<property>` 태그를 사용해 의존 오브젝트와의 관계를 정의한다.
    * `name`: DI에 사용할 수정자 메소드의 프로퍼티 이름
    * `ref`: 수정자 메소드를 통해 주입해줄 오브젝트 레퍼런스의 빈 이름
    * `value`: 오브젝트 레퍼런스가 아니라 단순 값을 주입할 때 사용
- 텍스트/단순 오브젝트를 수정자 메소드에 넣어주는 것을 스프링에서는 값을 주입한다고 한다.
    * 사용할 오브젝트 자체를 바꾸는 것은 아니지만, 특성을 외부에서 변경하기 때문에 일종의 DI
    * 스프링은 프로퍼티의 값을 수정자 메소드의 파라미터 타입을 참고해서 적절하게 변환한다.
- 기타: properties, yaml 파일을 이용한 설정