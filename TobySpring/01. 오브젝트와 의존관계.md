# 오브젝트와 의존관계
- 스프링의 관심: 객체지향 프로그래밍
- 오브젝트: 생성, 관계, 사용, 소멸 `cycle` + `설계`, `구현` 방법 + `단위` + `등장` etc.
- 스프링이 제공하는 것: (오브젝트를 다루는 기준, 실용적인 전략, 검증된 베스트 프랙티스) as 프레임워크

## 1.1 초난감 DAO
> - Data Access Object: DB를 사용해 데이터 조회/조작하기 위한 오브젝트
> - cf. Data Transfer Object: 계층 간 데이터 교환을 하기 위한 순수한 데이터 오브젝트 (getter, setter만 가짐)

### User
> 만든 목적: 사용자 정보를 저장하는 오브젝트
- **자바빈 규약**을 따르는 오브젝트를 이용하면 편리
    1. defulat 패키지가 아닌 패키지 하위에 있는 클래스
    2. 기본 생성자가 존재 (no-arg constructor)
        + 툴/프레임워크에서 **리플렉션**을 이용해 오브젝트를 생성하기 때문에 필요
            * 구체적인 클래스 타입을 알지 못해도, 그 클래스의 메소드/타입/변수들에 접근할 수 있도록 해주는 자바 API
            * 대개 프레임워크 단에서 런타임 때 동적으로 정보를 가져오기 위해 사용함 ex. `DI`, `어노테이션`
    3. property는 모두 private으로 선언
    4. getter/setter를 통해서 properties를 조작
    5. Serializable을 implement 하여 직렬화 가능

### UserDao
> 만든 목적: 사용자 정보를 DB에 쿼리할 수 있는 오브젝트
- DB와 커넥션을 맺고 질의하고 오브젝트에 세팅하고 리소스를 반환하는 등의 작업을 함
- 자신을 엔트리 포인트로 설정해 직접 실행이 가능하게 해주는 스태틱 메소드 main을 사용해서 검증하면 동작에는 문제 없음
- 그럼에도 이 코드는 개선해야 하는 **초난감 DAO**다. 스프링은 개선 과정을 돕는 매개체다.


## 1.2 DAO의 분리

### 관심사의 분리
> 관심이 같은 것은 모으고, 관심이 다른 것은 떨어뜨리자
- 오브젝트에 대한 설계와 이를 구현한 코드는 끊임없이 변한다.
    * 고로 개발자는 반드시 **미래의 변화를 고려해야** 한다.
    * 미래의 변화를 잘 준비하면 수정 요청에 대해 **수정 부분은 작고**, **변경이 나머지 기능에 문제를 일으키지 않는다**는 것을 빠르게 검증할 수 있다.
    * **변화는 한 번에 한 가지 관심사항에 집중해서 일어난다**.
- 객체지향 기술은 추상세계를 효과적으로 구성하고, 자유롭고 편리하게 **변경, 발전, 확장**할 수 있다는 장점이 있다.

### UserDao에 적용한다면?
- UserDao는 크게 `커넥션 획득`, `질의 실행`, `리소스 반환`으로 관심사를 나눌 수 있다.
- 리팩토링의 필요
    * 리팩토링? 나쁜 냄새가 나는 기존의 코드를 외부의 동작 방식에 변화 없이 내부 구조를 변경해서 재구성하는 작업
        + 정말 동작 방식에 변화가 없었는지 테스트 코드로 검증해야 한다.
    * 중복 코드가 많은 경우 => `메소드 추출`
    * 구현 방법이 사용처마다 달라질 수 있는 경우 => `템플릿 메소드 패턴` (상위 클래스로 분리해서 그 안에 기본적 로직의 흐름을 두고 일부 구현을 하위 클래스에 위임), `팩토리 메소드 패턴` (하위 클래스가 구체적인 오브젝트 생성 방법을 결정)
- 디자인 패턴의 필요
    * 디자인 패턴? 자주 맞닥뜨리는 문제 해결을 위한 재사용 가능한 솔루션
    * 경제적 커뮤니케이션: 간결하게 설계의 의도와 해결책을 함께 설명 가능
    * 대개의 확장성 추구 방법이 `클래스 상속` or `오브젝트 합성`
    * 패턴을 적용할 상황, 해결해야 하는 문제, 솔루션의 구조, 요소들의 역할, 핵심 의도 등 파악하면 좋음
- **상속**을 사용한 관심사 분리의 한계점
    * 이미 상속을 하고 있는 경우 & 나중에 상속 적용하기 어려움
    * 상속은 여전히 긴밀한 결합인 편임 (상위 클래스 수정 -> 모든 하위 클래스 수정 ㅠㅠ)
    * 상위 클래스가 많은 하위 클래스에 적용 가능한 부분과 특정 하위 클래스에만 적용 가능한 부분을 모두 포함함


## 1.3 DAO의 확장
- 변화의 성격이 다른 관심: 변화의 이유, 시기, 주기 등이 다르다
    * ex. A는 쿼리문이 바뀔 때, B는 사용하는 DB가 바뀔 때 변경된다면 변화의 성격이 다르다.
- 또 다른 관심사의 분리 방법: **클래스 분리**
    * 특정 관심사와 관련한 부분을 완전히 독립적인 별도의 클래스로 만들기
    * 그렇게 만든 클래스를 필요한 곳에서 이용하게 하기
    * ex. `UserDao` 와 `DbConnectionMaker` 의 분리
- 클래스를 분리하면 분리된 클래스에 종속되기 때문에 상속이 제공했던 유연한 변경과 확장이 어려워진다.
    * 왜? *종속된 클래스에 대해 너~무 많이 알고 있어서*!
    * ex. 메소드 이름이 분리된 클래스의 관심사를 가진 다른 클래스와 다르다면?
    * ex. 아예 클래스의 관심사를 가진 다른 클래스에 종속되게 하고 싶다면?
- 해결책 1: 분리된 클래스끼리 긴밀하게 연결되지 않도록 추상적인 느슨한 연결고리 `인터페이스`를 만든다.
    * 추상화? 어떤 것들의 공통적인 성격을 뽑아내서 이를 따로 분리하는 작업
    * 인터페이스로 기본적인 명세만 정의해두고, 구현 내용을 필요에 따라 변경해서 사용
- 해결책 2: `관계 설정의 책임`을 분리한다.
    * 종속될 클래스를 결정하는 것 역시 관계를 설정해주는 것에 관한 관심이므로, 분리한다.
    * 관계 설정이란 인터페이스 없이 다른 클래스를 직접 사용한다는 것 => 오브젝트와 오브젝트의 관계를 설정
    * 관계 설정 책임을 클라이언트에게 넘기고, 다형성을 활용하여 관계 설정한다.
      ```java
      // UserDao 바깥, 즉 UserDao를 사용하는 측에서 관계를 설정한다.
      // UserDao의 생성자의 파라미터가 ConnectionMaker 인터페이스 타입이고
      // fooConnectionMaker는 ConnectionMaker를 구현한 FooConnectionMaker의 인스턴스
      UserDao user = new UserDao(fooConnectionMaker);
      ```

### 원칙과 패턴
- 개방 폐쇄 원칙
    * 객체지향 설계 원칙 중 하나 (cf. `SOLID`)
    * 클래스나 모듈은 확장에는 열려 있고 (자신의 관심사와 무관한) 변경에는 닫혀 있어야 한다.
- 높은 응집도와 낮은 결합도
    * 응집도가 높다 = 변화가 있을 때 모듈에서 많은 부분이 변한다.
    * 결합도가 낮다 = 변화가 있을 때 외부에 변화를 요구하는 정도가 낮다.
- 전략 패턴
    * 변경이 필요한 부분을 분리하여 필요에 따라 바꿔서 사용할 수 있도록 하는 디자인 패턴


## 1.4 제어의 역전 (IoC)
- UserDao의 클라이언트를 UserDaoTest에 두었는데, 이는 `테스트` + `관계 설정` 이라는 2개 책임을 가진 것.
- 객체의 생성 방법을 결정하고 만들어진 오브젝트를 돌려주는 역할을 하는 `팩토리` 를 만들어 책임을 분리할 수 있다.
- 팩토리는 실제 로직을 가진 오브젝트들의 관계를 설정하는 **설계도**의 역할을 한다.
- 일반적으로 프로그램의 흐름은 자신이 사용할 오브젝트를 스스로 선택/생성하는 것이다. (사용자가 제어하는 구조)
- 제어의 역전이란 오브젝트 자신은 어디서 사용되는지 모른 채 제어 권한을 다른 대상에 위임하는 것이다. (특별한 오브젝트가 제어하는 구조)
    * ex. 컨테이너 안에서 동작하는 구조들 (서블릿, JSP, EJB)
    * ex. 상위 템플릿 메소드가 필요할 때 기능을 호출하는 템플릿 메소드 패턴
    * ex. 프레임워크 (애플리케이션 코드는 라이브러리를 사용하고, 프레임워크는 애플리케이션 코드를 사용한다.)
- 제어의 역전에서는 프레임워크/컨테이너와 같이 **컴포넌트의 생성, 관계설정, 사용, 생명주기 관리 등을 담당하는 오브젝트**가 필요하다. 하나하나 만들기에는 규모가 커질수록 어렵기 때문에, 애플리케이션 전반에 걸쳐 IoC를 본격적으로 사용하려면 프레임워크의 도움을 받는 것이 유리하다.