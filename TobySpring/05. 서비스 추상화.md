# 서비스 추상화
> 자바 생태계에는 기능과 목적이 유사한 기술이 존재한다. 스프링은 어떻게 비슷한 기술을 추상화하여 일관된 방법으로 사용할 수 있게 하는가?


## 사용자 레벨 관리 기능 추가
- 비즈니스 로직을 DAO에 적용하기
- 컴파일러가 제대로 체크하게 하려면 값의 범위가 한정되어 있는 필드는 enum 타입을 추천
- 단순한 오탈자나 문법 실수를 방지하기 위해 로직에는 꼭 테스트 코드를 만들 것
    * JDBC가 사용하는 SQL은 컴파일 과정에서는 자동으로 검증이 되지 않는 문자열에 불과함
- 테스트는 가능한 모든 조건을 하나씩은 확인해봐야 함


#### 코드 개선하기
- 이해하기 쉬운 코드
    * 성격이 다른 로직은 분리
- 변경에 대응하기 쉬운 코드
    * 자주 변경될 가능성이 있는 로직을 분리
        + 메소드 추출
        + 로직 분리 & DI해서 임시 교체 (ex. 이벤트 기간 동안 승급 처리)
    * 자신의 책임에 충실함
    * 중복 제거: 한 가지 변경으로 여러 군데를 대응해야 한다면 중복이 있는 것
- 오브젝트에게 데이터를 요구하지 말고 작업을 요청할 것
- 꼼꼼한 테스트
    * 기능이 추가되어도 테스트를 확장해 사용 가능
    * 좋은 코드는 깔끔하게 테스트를 작성할 수 있는 경우가 많음


## 트랜잭션 서비스 추상화
- 모 아니면 도: 전부 되거나 아무것도 되지 않아야 하는 로직에는 트랜잭션이 필요하다.
    * 위와 같은 케이스의 로직을 A 메소드라고 할 때, A는 하나의 트랜잭션 안에서 동작해야 한다.
    * 트랜잭션이란 더 이상 나눌 수 없는 단위 작업이다.
    * 일반적으로 하나의 SQL은 하나의 트랜잭션이다. 하지만 여러개의 SQL을 하나의 트랜잭션으로 취급해야 하는 경우도 있다.
- 트랜잭션의 경계
    * 시작하는 지점
    * 끝나는 지점
        + 롤백(rollback): 문제가 된 경우, 모든 작업을 무효화
        + 커밋(commit): 모든 작업이 성공적으로 마무리된 경우, 작업을 확정
    * 복잡한 로직 흐름 사이에서 정확하게 트랜잭션 경계를 설정하는 일은 중요하다.
    * 시작을 선언해주고 종료하는 작업을 트랜잭션의 경계설정이라고 한다.
    * 트랜잭션의 경계는 하나의 Connection이 만들어지고 닫히는 범위 안에 존재한다.
- JDBC의 트랜잭션
    * 하나의 `Connection`을 가져와 사용하다가 닫는 사이에 일어남
    * 트랜잭션의 시작과 종료가 `Connection` 오브젝트를 통해 이뤄지기 때문
    * 시작: 자동커밋 옵션을 false로 만든다. (`setAutoCommit(false)`)
    * 종료: `rollback()` 또는 `commit()`을 호출한다.
- 하나의 DB 커넥션 안에서 만들어지는 트랜잭션을 로컬 트랜잭션이라고 한다.


#### 비즈니스 로직 내의 트랜잭션 경계설정
1. DAO를 호출할 때마다 트랜잭션을 만든다
    * -> 매번 커넥션을 만들기 때문에 여러 작업을 하나의 트랜잭션으로 묶기 불가능해짐
2. DAO 메소드 안으로 서비스 로직을 옮긴다
    * -> 성격과 책임을 분리하고 느슨하게 연결해서 확장성을 좋게 하려던 노력이 물거품이 됨
3. Connection을 서비스 로직에서 만들고 파라미터로 전달한다
    * -> jdbcTemplate을 더이상 사용할 수 없어서 리소스를 깔끔하게 처리하기 어려움
    * -> 서비스 로직의 코드에 Connection 파라미터가 추가되고, 계속 전달됨
    * -> 데이터 액세스 기술에 독립적일 수 없는 DAO
    * -> 테스트 코드에 영향을 미침
4. [스프링의 제안] **독립적인 트랜잭션 동기화**
    * Connection을 트랜잭션 동기화 저장소에 보관
        + 작업 스레드마다 독립적으로 Connection 오브젝트를 저장하고 관리해서 멀티스레드 환경에서도 안전함
    * 트랜잭션 시작 선언 이후 DAO를 사용하기 시작
    * 이후 호출되는 DAO의 메소드에서는 저장된 Connection을 가져다가 사용
    * 트랜잭션이 종료되면 동기화 종료
    * 구현 방법
        + `TransactionSynchronizationManager` 클래스로 관리
        + `DataSourceUtils`의 `getConnection()`으로 커넥션 생성 및 저장소에 바인딩
5. 글로벌 트랜잭션?
    * 언제? 하나 이상의 DB로의 작업을 하나의 트랜잭션으로 만들고 싶을 경우
    * 로컬은 왜 안 될까? 로컬 트랜잭션은 하나의 DB Connection에 종속되기 때문에 불가능
    * 어떻게? 별도의 트랜잭션 관리자를 통해 트랜잭션을 관리 (`JTA`)
    * 장점? 여러 DB가 참여하는 트랜잭션 생성 가능 & 트랜잭션 서비스(ex. JMS)도 트랜잭션 참여 가능


#### 트랜잭션 API의 의존관계
- 특정 데이터 액세스 기술에 종속되지 않도록 추상화할 수 있다.
    * 트랜잭션의 경계설정을 담당하는 코드는 일정한 패턴을 갖는 유사한 구조
    * 공통점이 있는 사용 방법은 그 공통점을 뽑아 분리(추상화)할 수 있음
- 스프링이 제공하는 트랜잭션 추상화 계층구조
    * (추상화 계층) `PlatformTransactionManager` > `DataSourceTxManager` / `HibernateTxManager` 
    * (트랜잭션 계층) > JDBC `Connection` / JTA `UserTransaction` / Hibernate `Transaction`
    * 구현하는 쪽에서 구체적으로 자기가 사용하는 기술에 맞게 트랜잭션을 관리해줌
    * ex. 로컬 -> 글로벌? PlatformTransactionManager의 구현을 DataSourceTransactionManager에서 JTATransactionManager로 변경
        + JTATransactionManager는 주요 자바 서버가 제공하는 JTA 정보를 JNDI를 통해 자동으로 인식해줘서 별다른 설정 없이 사용하는 것만으로 다른 트랜잭션 매니저/서비스와 연동해서 동작함
        + JNDI는 Java Naming and Directory Interface API의 약자로, 네이밍 서비스로 부터 제공하는 자원(데이터 및 객체)를 찾아 참고(lookup)하기 위한 자바 API


## 서비스 추상화와 단일 책임 원칙
> 기술과 서비스에 대한 추상화 기법을 적용하면 특정 기술환경에 종속되지 않는 포터블한 코드를 만들 수 있다.
- 단일 책임 원칙: 하나의 모듈은 한 가지 책임만 지게 할 것. 다른 곳의 일과 무관하게 일을 수행할 수 있게 할 것.
    * 변경이 필요할 때 수정 대상이 명확함
    * 작업량이 줄어듦
    * 실수가 일어날 확률이 낮아짐
- 엔터프라이즈 애플리케이션은 갈수록 복잡해지기 때문에 추상화 기법의 도입과 적절한 분리는 반드시 필요하다.
    * 서비스 로직간의 분리 = 수평적 분리
    * 서비스 로직과 구체적 기술간의 분리 = 수직적 분리
- 결합도가 낮고 서로 영향을 주지 않고 자유롭게 확장될 수 있는 구조를 만드는 데에는 DI가 중요한 역할을 한다.
    * DataSource 인터페이스와 DI로 추상화된 방식으로 로우레벨의 DB 연결기술을 사용
    * 트랜잭션 기술에 PlatformTransactionManager를 두고 구체적 기술과 서비스 코드 분리
    * 스프링은 적극적으로 DI의 원칙과 응용모델을 문제 해결에 응용함


## 메일 서비스 추상화
- 메일 전송을 테스트하는 데에는 많은 자원이 소모된다.
- 테스트용 서버에 메일을 보내는 식으로 테스트하기에는 JavaMail이 확장/지원이 안 되는 API이다.
- **건전하지 않게 설계된 API를 사용할 때에는 서비스 추상화를 적용해보자**
    * 인터페이스를 만들어서 발생 가능한 예외들을 런타임 예외로 포장해서 던지도록 명세
    * 구체적 클래스를 구현해 작성한 코드를 인터페이스로 옮기면서 DI하게 설정 파일도 수정
    * 타 서버의 API로 이전해야 하거나 추가 기능을 넣을 때에도 유용
- 테스트 대역: 테스트용으로 사용된 특별한 오브젝트. 테스트 대상이 사용하는 의존 오브젝트를 대체할 수 있게 함.
    * 테스트 스텁
        + 상태 검증 목적 (메소드가 수행된 후, 객체의 **상태를 확인**하여 올바르게 동작했는지를 확인하는 검증법)
        + 인스턴스화하여 구현한 가짜 객체(=Dummy. 기능 구현 X)를 이용해 실제로 동작하는 것처럼 "보이게" 만드는 객체
    * 목 오브젝트
        + 행위 검증 목적 (메소드의 리턴 값으로 판단할 수 없는 경우 **특정 동작을 수행하는지** 확인하는 검증법)
        + 호출에 대한 기대를 명세하고, 내용에 따라 동작하도록 프로그래밍 된 객체
    * 테스트 대역으로는 Dummy, Stub, Spy, Mock, Fake 등이 있다.
    * cf. [기타](https://github.com/team-tancheon/book-lounge/issues/16) [참고](https://github.com/team-tancheon/book-lounge/issues/14)