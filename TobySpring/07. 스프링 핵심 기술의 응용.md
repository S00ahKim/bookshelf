# 스프링 핵심 기술의 응용
> SQL과 DAO를 분리해보자!


## XML 설정 이용하기
- SQL을 스트링의 XML 설정파일로 빼내기
    * 문자열 값을 외부에서 DI하는 식으로 손쉽게 분리 가능
    * 새로운 SQL이 필요해질 때마다 프로퍼티 추가, 변수 추가, 수정자 추가 등 복잡함
- SQL을 맵 프로퍼티로 받아오기
    * 새로운 SQL이 필요하면 설정에 <entry>만 추가해주면 되어 간단함
    * 실제로 메소드가 실행되기 전까지는 에러 검출이 어려움


## SQL 제공 서비스 만들기
- 설정 정보와 SQL이 섞여 있으면 관리의 어려움이 있음
- 인터페이스를 만들면 DAO는 SQL의 출처에 신경쓰지 않아도 됨
- SQL을 저장하는 별도의 독립적인 파일을 만드는 것이 바람직함
    * 스프링 설정 파일의 <map>, <entry> 태그보다 <sqlmap>, <sql> 태그에 담는 것이 더 읽기 편함
- JAXB
    * 장점: XML 문서정보를 거의 동일한 구조의 오브젝트로 직접 매핑해주고, 자동으로 만들어주는 컴파일러 제공
    * 언마샬링: XML -> 자바 오브젝트
    * 마샬링: 바인딩 오브젝트 -> XML
    * cf. 직렬화(오브젝트 -> 바이트 스트림)와 유사함
- 특별한 이유가 없다면 XML 파일은 한 번만 읽게 할 것
    * 파일에서 SQL을 읽어와 내부에 저장해두는 초기 작업 필요
    * 생성자에서 하는 것 비추: 예외 발생 가능, 다루기 어렵고 보안 문제도 있음
    * 초기 상태의 오브젝트에 별도로 초기화 추천: 빈 후처리기 `@PostConstruct` 활용
        + 프로퍼티까지 준비된 뒤에 실행됨
    * 읽을 파일의 위치와 이름을 코드에 고정하지 말고 외부에서 DI 받게 할 것
- 인터페이스 분리
    * SQL 가져오기 & SQL 보관하고 사용하기 -> 분리할 만한 관심사
    * 만약 읽으려는 파일의 형식이 XML이 아니라면? -> 확장 가능한 구조로 변경 필요
    * 여러 종류의 책임에 대한 인터페이스를 받아 서비스 인터페이스를 만들고 이를 구현하기
    * 자기참조 빈: 책임들 간에 서로 호출하는 부분이 있더라도 그 다른 부분을 알고 있다는 전제로 코딩하면 안 됨. **자기 자신을 전달받더라도**, 다른 오브젝트라고 생각하고 인터페이스에 정의된 메소드를 통해서만 사용할 것.
    * 디폴트 의존관계: 디폴트라고 해도 좋을 만큼 기본적인 설정이 있다면, 외부에서 DI 받지 않는 이상 자동 적용되는 의존관계를 만들 수 있음. 생성자에서 디폴트 의존 오브젝트를 직접 만들어서 스스로 DI하면 됨. 유사하게 읽어올 파일 이름도 관례적으로 사용되는 이름을 디폴트로 넣어줄 수 있음.
        + 대신 사용하고 싶은 오브젝트가 있을 경우 설정에 프로퍼티 추가
        + 별다른 조정이 없다면 디폴트 프로퍼티와 추가 주입 프로퍼티가 모두 만들어짐. 빈 후처리기를 이용해 조정 가능.


## 서비스 추상화 적용
- 개선점
    * XML과 자바 오브젝트를 매핑할 때 JAXB 외의 기술(OXM)을 적용하고 싶다.
    * XML 파일의 위치를 원하는 곳에 놓고 싶다.

#### XML과 자바 오브젝트를 매핑할 때 JAXB 외의 기술(OXM)을 적용하고 싶다.
- 스프링의 OXM 추상화 서비스 인터페이스에는 `Marshaller`와 `Unmarshaller`가 있다.
- 세부 구현 기술에 맞게 위 두 인터페이스를 구현하고 빈으로 등록한다.
- 이 구현 과정에서 구조적으로 `Service`와 `SqlReader`는 강결합되므로, `private final`로 외부에서 접근 불가능하고 변경 불가능하게 선언한다.
- 이때 하나의 빈 설정으로 필요한 오브젝트를 모두 설정하려면 외부에서 DI받을 수 있도록 수정자 메소드를 열어두는 방법을 쓸 수 있다.
- 코드의 중복을 막기 위해 위임 구조를 활용하여 기본이 되는 구현체를 프로퍼티로 가져와 호출할 수 있다.

#### XML 파일의 위치를 원하는 곳에 놓고 싶다.
- 자바에는 다양한 위치에 존재하는 리소스에 대해 단일화된 접근 인터페이스를 제공해주는 클래스는 없다.
- 스프링은 이를 추상화해서 `Resource`라는 추상화 인터페이스를 제공한다.
    * 빈이 아니라 값으로 취급
    * 외부에서 지정해주는 식으로 추상화하려면 `<property>`의 `value` 애트리뷰트에 넣는 방법뿐이다.
    * 그런데 value에 들어갈 수 있는 것은 문자열뿐이다. -> `ResourceLoader` 필요
    * 실제 소스가 어떤 것이든 무관하게 스트림으로 가져올 수 있음
    * 리소스에 접근 가능한 추상화된 핸들러일 뿐이라 실제 리소스가 존재하지 않을 수 있어서 디폴트 설정이 필요
- 문자열 안에 리소스의 종류와 위치를 함께 적어두면 그에 맞는 방법으로 ResourceLoader가 읽어온다.
    * ex. 스프링 애플리케이션 컨텍스트: 스프링 설정정보 읽음, 빈 프로퍼티 값 변환에 사용, 리소스 읽어옴 등

#### 서버 재시작 없이 SQL을 변경하고 싶다.
- 이를 위해서는 인터페이스를 적극 활용한 DI 최적화 설계가 필요
    * 다형성: 구현을 바꿔가며 사용 가능
    * 클라이언트와 의존 오브젝트 간 관계 명확히 함
        + 이 클라이언트가 무슨 관심을 갖고 있나 파악 가능 cf. 인터페이스 분리 원칙
        + **동일한 오브젝트에 의존하는 두 클라이언트가 있다면 각자의 관심과 필요에 따라 다른 인터페이스를 통해 접근 가능**
        + 클라이언트가 정말 필요한 기능을 가진 인터페이스로 오브젝트에 접근하게 했는가가 중요
    * 당장 변경될 것 같지 않아도 확장에 대비하는 것이 현명함
        + 로직/구현의 변경 또는 다른 종류의 클라이언트가 등장할 수 있음
- 실시간으로 정보를 변경하는 데 있어서 가장 중요한 문제는 **동시성**
    * 멀티스레드 환경에서 안전하게 해시맵을 조작하려면...
        + `Collections.synchronizedMap()` ===> 모든 작업을 동기화하면 성능 이슈
        + `ConcurrentHashMap` ===> 조작시 일부에만 락을 걸고 조회에는 락 없어서 어느정도 안전하고 성능도 보장
        + 데이터베이스 ===> ConcurrentHashMap이 다루기에 저장되는 데이터 양이 많고 변경과 조회가 잦은 경우
- SQL 관리용으로 DB를 새로 만들기엔 배보다 배꼽이 크기 때문에, 내장형 DB를 활용
    * 내장형 DB? 애플리케이션에 내장돼서 애플리케이션과 함께 시작되고 종료되는 DB로, 데이터는 메모리에 저장함
    * 특성상 외부에서 DB생성하고 필요한 테이블 만들고 초기화할 수 없어서 애플리케이션 내에서 그걸 해야 함 (+종료)
    * 위 작업을 위해 다양한 빌더들을 제공함
    * `EmbeddedDatabaseBuilder`가 스프링이 제공하는 `EmbeddedDatabase` 인터페이스 타입의 오브젝트를 만들어 이를 JdbcTemplate등이 필요로 하는 DataSource로 넘겨줄 수 있음
    * 적절한 메소드를 호출해줄 초기화 코드를 위한 팩토리 빈은 전용 태그(ex. `<jdbc:embedded-database>`)로 만들 수 있음
- 한번은 변경된 SQL, 한번은 변경되지 않은 SQL이 적용되는 불상사를 막으려면 트랜잭션 필요
    * 트랜잭션 적용 코드에 템플릿 콜백 패턴을 적용한 TransactionTemplate 활용