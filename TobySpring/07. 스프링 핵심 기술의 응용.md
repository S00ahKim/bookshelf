# 스프링 핵심 기술의 응용
> SQL과 DAO를 분리해보자!


## XML 설정 이용하기
- SQL을 스트링의 XML 설정파일로 빼내기
    * 문자열 값을 외부에서 DI하는 식으로 손쉽게 분리 가능
    * 새로운 SQL이 필요해질 때마다 프로퍼티 추가, 변수 추가, 수정자 추가 등 복잡함
- SQL을 맵 프로퍼티로 받아오기
    * 새로운 SQL이 필요하면 설정에 <entry>만 추가해주면 되어 간단함
    * 실제로 메소드가 실행되기 전까지는 에러 검출이 어려움


## SQL 제공 서비스 만들기
- 설정 정보와 SQL이 섞여 있으면 관리의 어려움이 있음
- 인터페이스를 만들면 DAO는 SQL의 출처에 신경쓰지 않아도 됨
- SQL을 저장하는 별도의 독립적인 파일을 만드는 것이 바람직함
    * 스프링 설정 파일의 <map>, <entry> 태그보다 <sqlmap>, <sql> 태그에 담는 것이 더 읽기 편함
- JAXB
    * 장점: XML 문서정보를 거의 동일한 구조의 오브젝트로 직접 매핑해주고, 자동으로 만들어주는 컴파일러 제공
    * 언마샬링: XML -> 자바 오브젝트
    * 마샬링: 바인딩 오브젝트 -> XML
    * cf. 직렬화(오브젝트 -> 바이트 스트림)와 유사함
- 특별한 이유가 없다면 XML 파일은 한 번만 읽게 할 것
    * 파일에서 SQL을 읽어와 내부에 저장해두는 초기 작업 필요
    * 생성자에서 하는 것 비추: 예외 발생 가능, 다루기 어렵고 보안 문제도 있음
    * 초기 상태의 오브젝트에 별도로 초기화 추천: 빈 후처리기 `@PostConstruct` 활용
        + 프로퍼티까지 준비된 뒤에 실행됨
    * 읽을 파일의 위치와 이름을 코드에 고정하지 말고 외부에서 DI 받게 할 것
- 인터페이스 분리
    * SQL 가져오기 & SQL 보관하고 사용하기 -> 분리할 만한 관심사
    * 만약 읽으려는 파일의 형식이 XML이 아니라면? -> 확장 가능한 구조로 변경 필요
    * 여러 종류의 책임에 대한 인터페이스를 받아 서비스 인터페이스를 만들고 이를 구현하기
    * 자기참조 빈: 책임들 간에 서로 호출하는 부분이 있더라도 그 다른 부분을 알고 있다는 전제로 코딩하면 안 됨. **자기 자신을 전달받더라도**, 다른 오브젝트라고 생각하고 인터페이스에 정의된 메소드를 통해서만 사용할 것.
    * 디폴트 의존관계: 디폴트라고 해도 좋을 만큼 기본적인 설정이 있다면, 외부에서 DI 받지 않는 이상 자동 적용되는 의존관계를 만들 수 있음. 생성자에서 디폴트 의존 오브젝트를 직접 만들어서 스스로 DI하면 됨. 유사하게 읽어올 파일 이름도 관례적으로 사용되는 이름을 디폴트로 넣어줄 수 있음.
        + 대신 사용하고 싶은 오브젝트가 있을 경우 설정에 프로퍼티 추가
        + 별다른 조정이 없다면 디폴트 프로퍼티와 추가 주입 프로퍼티가 모두 만들어짐. 빈 후처리기를 이용해 조정 가능.


## 서비스 추상화 적용
- 개선점
    * XML과 자바 오브젝트를 매핑할 때 JAXB 외의 기술(OXM)을 적용하고 싶다.
    * XML 파일의 위치를 원하는 곳에 놓고 싶다.

#### XML과 자바 오브젝트를 매핑할 때 JAXB 외의 기술(OXM)을 적용하고 싶다.
- 스프링의 OXM 추상화 서비스 인터페이스에는 `Marshaller`와 `Unmarshaller`가 있다.
- 세부 구현 기술에 맞게 위 두 인터페이스를 구현하고 빈으로 등록한다.
- 이 구현 과정에서 구조적으로 `Service`와 `SqlReader`는 강결합되므로, `private final`로 외부에서 접근 불가능하고 변경 불가능하게 선언한다.
- 이때 하나의 빈 설정으로 필요한 오브젝트를 모두 설정하려면 외부에서 DI받을 수 있도록 수정자 메소드를 열어두는 방법을 쓸 수 있다.
- 코드의 중복을 막기 위해 위임 구조를 활용하여 기본이 되는 구현체를 프로퍼티로 가져와 호출할 수 있다.

#### XML 파일의 위치를 원하는 곳에 놓고 싶다.
- 자바에는 다양한 위치에 존재하는 리소스에 대해 단일화된 접근 인터페이스를 제공해주는 클래스는 없다.
- 스프링은 이를 추상화해서 `Resource`라는 추상화 인터페이스를 제공한다.
    * 빈이 아니라 값으로 취급
    * 외부에서 지정해주는 식으로 추상화하려면 `<property>`의 `value` 애트리뷰트에 넣는 방법뿐이다.
    * 그런데 value에 들어갈 수 있는 것은 문자열뿐이다. -> `ResourceLoader` 필요
    * 실제 소스가 어떤 것이든 무관하게 스트림으로 가져올 수 있음
    * 리소스에 접근 가능한 추상화된 핸들러일 뿐이라 실제 리소스가 존재하지 않을 수 있어서 디폴트 설정이 필요
- 문자열 안에 리소스의 종류와 위치를 함께 적어두면 그에 맞는 방법으로 ResourceLoader가 읽어온다.
    * ex. 스프링 애플리케이션 컨텍스트: 스프링 설정정보 읽음, 빈 프로퍼티 값 변환에 사용, 리소스 읽어옴 등

#### 서버 재시작 없이 SQL을 변경하고 싶다.
- 이를 위해서는 인터페이스를 적극 활용한 DI 최적화 설계가 필요
    * 다형성: 구현을 바꿔가며 사용 가능
    * 클라이언트와 의존 오브젝트 간 관계 명확히 함
        + 이 클라이언트가 무슨 관심을 갖고 있나 파악 가능 cf. 인터페이스 분리 원칙
        + **동일한 오브젝트에 의존하는 두 클라이언트가 있다면 각자의 관심과 필요에 따라 다른 인터페이스를 통해 접근 가능**
        + 클라이언트가 정말 필요한 기능을 가진 인터페이스로 오브젝트에 접근하게 했는가가 중요
    * 당장 변경될 것 같지 않아도 확장에 대비하는 것이 현명함
        + 로직/구현의 변경 또는 다른 종류의 클라이언트가 등장할 수 있음
- 실시간으로 정보를 변경하는 데 있어서 가장 중요한 문제는 **동시성**
    * 멀티스레드 환경에서 안전하게 해시맵을 조작하려면...
        + `Collections.synchronizedMap()` ===> 모든 작업을 동기화하면 성능 이슈
        + `ConcurrentHashMap` ===> 조작시 일부에만 락을 걸고 조회에는 락 없어서 어느정도 안전하고 성능도 보장
        + 데이터베이스 ===> ConcurrentHashMap이 다루기에 저장되는 데이터 양이 많고 변경과 조회가 잦은 경우
- SQL 관리용으로 DB를 새로 만들기엔 배보다 배꼽이 크기 때문에, 내장형 DB를 활용
    * 내장형 DB? 애플리케이션에 내장돼서 애플리케이션과 함께 시작되고 종료되는 DB로, 데이터는 메모리에 저장함
    * 특성상 외부에서 DB생성하고 필요한 테이블 만들고 초기화할 수 없어서 애플리케이션 내에서 그걸 해야 함 (+종료)
    * 위 작업을 위해 다양한 빌더들을 제공함
    * `EmbeddedDatabaseBuilder`가 스프링이 제공하는 `EmbeddedDatabase` 인터페이스 타입의 오브젝트를 만들어 이를 JdbcTemplate등이 필요로 하는 DataSource로 넘겨줄 수 있음
    * 적절한 메소드를 호출해줄 초기화 코드를 위한 팩토리 빈은 전용 태그(ex. `<jdbc:embedded-database>`)로 만들 수 있음
- 한번은 변경된 SQL, 한번은 변경되지 않은 SQL이 적용되는 불상사를 막으려면 트랜잭션 필요
    * 트랜잭션 적용 코드에 템플릿 콜백 패턴을 적용한 TransactionTemplate 활용


## 스프링3.1의 DI
- 스프링은 1.0부터 3.1까지 근본 패러다임을 고수하며 거의 완벽에 가까운 구버전 호환성을 유지함
- 자바 언어의 변화에 따른 스프링의 사용 방식 변화
    1. 애노테이션의 메타정보 활용
        * 자바 코드를 리플렉션 API등을 이용해 구성을 살펴보고 그에 따라 동작하는 기능이 점점 많이 사용되는 추세
        * 그 절정은 자바 5에서 등장한 애노테이션 (리플렉션 등으로 애노테이션의 메타정보 조회 + 그 안의 설정값 참고)
        * 애플리케이션의 일반적 구성(로직 코드, IoC 프레임워크, 프레임워크가 참조하는 메타정보) 중 메타정보로 활용하기 좋음
        * XML 설정정보보다 더 간결하고 여러 군데에 더 쉽게 적용할 수 있고, 리팩토링하기 좋음
        * 스프링은 2.5부터 DI와 웹 기능 일부에 애노테이션을 적용하기 시작하고, 점점 그 범위를 넓혀가고 있음
    2. 정책과 관례를 이용한 프로그래밍
        * 명시적으로 동작 내용을 기술하는 대신 미리 약속한 규칙/관례에 따라 프로그램이 동작하게 하는 스타일
        * 장점: 작성해야 할 내용이 상당수 줄어든다
        * 단점: 미리 정의된 많은 관례를 기억해야 함 & 메타정보를 보고 동작을 이해해야 함 (학습 비용 소모, 휴먼에러 가능성)
        * ex: `@Transactional` 의 우선순위 정책

### 자바 코드를 이용한 빈 설정
- XML에 담겨 있던 빈 설정정보 => 애노테이션 + 자바 코드
    * `@ContextConfiguration` 스프링 테스트가 테스트용 DI 정보를 어디서 가져와야 하는지 지정
    * `@Configuration` DI 설정정보를 담은 클래스에 붙여줌
    * `@ImportResource` 필요할 경우 XML 파일의 설정정보를 가져올 수 있음
    * `@Bean` 메소드를 이용해서 빈 오브젝트의 생성과 의존관계 주입을 자바 코드로 작성할 수 있게 함. @Configuration이 붙은 DI 설정용 클래스에서 많이 사용됨
        + <bean>에 넣는 클래스는 내부적으로 리플렉션 API를 사용해서 private도 사용할 수 있었음
        + 그러나 @Bean 으로 직접 자바 코드에서 참조할 땐 패키지가 다르면 public으로 만들어줘야 함
- 자동 등록과 와이어링 기능 적용
    * `@Autowired`
        + 필드에 붙여서 해당 필드의 타입과 같은 타입의 빈을 필드에 자동으로 넣어줌
        + 조건에 맞는 빈을 찾아 자동으로 수정자 메소드나 필드에 넣어줌
        + 만약 컨테이너가 타입/이름으로 자동 주입이 어려울 경우, 직접 프로퍼티에 주입해주는 방식 병행 가능
        + 장점: DI 관련 코드를 대폭 줄일 수 있음
        + 단점: 빈 설정정보를 보고 다른 빈과 의존관계를 확인하기 어려움
    * `@Resource` 역시 필드에 빈을 주입받을 때 사용됨
        + `@Autowired`는 필드의 타입을 기준으로 빈을 검색 (타입이 동일할 경우 프로퍼티 이름이 같은 것으로 선택)
        + `@Resource`는 필드 이름을 기준으로 빈을 검색
    * `@Component` 클래스에 붙여 빈 스캐너가 빈을 자동 등록하는 데 사용
        + 직접 붙이거나 이를 **메타 애노테이션**으로 갖고 있는 애노테이션을 붙이면 됨. 일종의 마커.
            - 메타 애노테이션? 애노테이션의 정의에 부여된 애노테이션
            - ex. SNS 접속 기능을 제공하는 빈을 AOP 포인트컷으로 지정할 수 있도록 구분할 목적으로 만드는 애노테이션 정의를 다음과 같이 하면 자동 빈 등록 대상으로 만들 수 있음.
              ```java
              @Component
              public @interface SnsConnector {...}
              // 활용예: @SnsConnector
              ```  
            - ex. `@Repository` 데이터 액세스 서비스를 제공하는 빈
            - ex. `@Service` 비즈니스 로직을 담고 있는 서비스 계층의 빈
        + `@ComponentScan`을 DI 설정용 클래스에 붙여 어느 패키지 아래에서 빈을 등록할지 설정
        + 빈의 아이디는 따로 지정하지 않았으면 클래스 이름의 첫 글자를 소문자로 바꿔서 사용함
- 실행 환경에 따라 달라지는 빈 설정정보를 분리해서 프로파일 적용
    * `@Import` 설정 정보들을 용도에 따라 분리하고, 특정 상황에서 필요한 설정 정보들만 가져오고 싶을 때 활용
    * `@Profile` 특정 환경에 따라 활성화해야 하는 설정 정보라면, 그 설정 정보 클래스에 붙이는 식으로 활용
        + 이 애노테이션이 붙은 설정 클래스는 @Import로 가져오든 @ContextConfiguration에 직접 명시하든 현재 컨테이너의 활성 프로파일 목록에 자신의 프로파일 이름이 붙어있지 않으면 무시됨
    * `@ActiveProfiles` 특정 코드가 실행될 때 특정 환경을 지정해주고 싶은 경우 사용
- 외부 서비스 접속에 필요한 정보는 프로퍼티 파일로 만들어두고 프로퍼티 소스를 통해 빈 설정에서 사용
    * 프로퍼티 파일은 .properties 확장자를 사용하며, 내부에 키=값 형태로 프로퍼티를 저장함
    * `@PropertySource` 프로퍼티 파일의 내용을 컨텍스트가 사용하도록 지정할 때 활용
    * `@Value` 이 애노테이션을 붙인 필드에 값을 주입하기 위해 활용. 타입 변환도 스프링이 알아서 해줌.
- 독립적으로 재사용 가능한 코드와 설정정보 분리 + 쉽게 갖다 쓸 수 있게 전용 애노테이션도 도입
    * 특별한 목적을 위해 만들어진, 내부적으로 복잡한 로우레벨의 빈을 등록해주는 전용 태그(ex. `<tx:annotation-driven>`)와 유사하게 스프링3.1은 전용 애노테이션(`@EnableTransactionManagement`)을 제공함
    * 특정 컨텍스트를 사용하는 서비스임을 명시하려면 @Import를 메타 애노테이션으로 가지는 @EnableXXXService와 같은 애노테이션을 만들어서 붙여두는 식으로 활용할 수 있음. 의미가 명확해서 읽기 쉬움.