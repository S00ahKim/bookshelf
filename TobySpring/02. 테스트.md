# 테스트
> 테스트는 내가 예상하고 의도한 대로 코드가 동작하는지 확인하여 만들어진 코드에 확신을 갖게 한다.


## 2.1 테스트의 필요
- 어떤 기능을 추가할 때, 작은 컴포넌트에 대한 테스트를 위해 **모든 기능 개발이 완료되어야 한다면**...
    1. 개발 기간 동안에는 안심할 수 없다.
    2. 잘 되는지 한번 확인하는 데 시간이 너무 오래 걸린다.
    3. 테스트를 한다 해도 문제의 원인을 찾기가 어렵다.
- 테스트의 관심이 다르면 테스트할 대상을 분리하자! `단위 테스트`
    * 단위를 나누는 기준? 충분히 하나의 관심에 집중해서 효율적으로 테스트할 만한 범위의 단위
    * 일반적으로는 단위가 작을수록, 레이어를 넘나들지 않을수록, 통제할 수 없는 외부 요소에 의존하지 않을수록 좋다.
    * 개발자가 스스로 자신의 코드를 빨리 확인해보기 위한 목적
    * 뭔가 추가/변경/개선 등을 할 때 side-effect가 없는지 빠르게 확인 가능 (지속적 개선 & 점진적 개발)
- 테스트는 자동으로 실행되어야 한다.
    * 수동으로 UI를 하나하나 클릭해서 테스트해야 한다면 귀찮고 휴먼에러가 나기 쉽다.
    * 자동으로 실행되면 테스트를 자주 반복할 수 있다.
- 테스트의 결과
    * 성공
    * 실패
        1. 테스트 에러 (진행되는 동안 에러 발생)
        2. 테스트 실패 (진행에는 이슈가 없으나 결과가 예상과 다름)

## 2.2 JUnit의 필요
- main 메소드와 콘솔 로그의 확인으로 만든 테스트는 약간의 수동 진행(콘솔 값 확인, main 실행 등)이 필요해서 완전 자동화된 코드가 아니며, 번거로움이 있다.
- 테스트를 효율적으로 수행하는 도구, JUnit
    * 일정한 패턴을 가진 테스트 작성 지원
    * 많은 테스트를 간단하게 실행 지원
    * 테스트 결과를 종합해서 확인 지원
    * 테스트가 실패한 곳을 빠르게 찾을 수 있게 지원
- JUnit은 **프레임워크**: IoC가 적용되었으므로 main()과 오브젝트 생성 로직이 불필요하다.
- 테스트 로직 작성
    * 테스트 메소드는 public으로 선언되어야 한다.
    * 테스트 메소드에는 `@Test` 어노테이션이 붙어있어야 한다.
- 검증 로직 작성
    * 스태틱 메소드 `assertThat`으로 값을 matcher와 비교한다.
    * 기대한 결과가 아닐 경우 `AssertionError`를 던진다.
    * 자매품: `assertTrue`, `assertFalse` 등
- 실행
    * 어딘가에 코드(JUnitCore.main)로 실행해주는 main 메소드 만들기
    * [Runner 클래스가 실행하게 하기](https://stackoverflow.com/questions/14011981/java-junit-has-no-main-function)
    * IDE 등에서 실행: Assert 문은 디버깅 용도라 실행에서 제외되어서 이를 동작하게 하려면 `-ea` 옵션 필요


## 2.3 테스팅 프레임워크 JUnit
> 스프링 역시 JUnit으로 테스트를 만들어가며 개발되었다.
- 실행
    * 빌드 툴에서 제공하는 플러그인/태스크 등으로 테스트를 실행할 수 있다. ex. `maven`
    * 모든 테스트를 통합해서 실행해야 할 경우 별도의 서버에서 모든 코드를 가져와 통합하고 빌드한 후에 테스트를 수행하면 좋다. ex. `Jenkins 활용`
- 테스트는 항상 일관적이어야 한다 = 적절한 상태 관리 필요
    * 테스트가 변경한 데이터를 원복하는 메소드 만들기
    * `@Transactional` 어노테이션으로 테스트 완료 후 롤백하게 할 수 있음
    * 클래스 단위로 `@Transactional` 어노테이션을 붙여서 모든 메소드가 롤백되지만, 특정 메소드의 결과는 롤백되지 않길 원한다면 `@Rollback(false)` 어노테이션을 붙여줌
- JUnit은 특정한 테스트 메소드의 실행 순서를 보장하지 않는다. 실행 순서에 영향을 받는다면 잘못된 테스트를 만든 것이다.
- 예외조건 테스트
    * ~JUnit4 `@Test(expected=FooException.class)`
    * JUnit5 `AssertThrows`
- 성공하는 테스트만 만드는 실수를 범하지 말자. 네거티브 테스트를 먼저 만들자. (예외 상황 대처 방법 고려)
- TDD
    * 기능 설계를 위한 테스트: 테스트는 `조건`, `행위`, `결과`를 코드로 명시한 일종의 설계문서가 될 수 있다.
    * 테스트를 우선 작성하고 애플리케이션 코드가 테스트에 성공하도록 다듬어 나간다.
    * 실패한 테스트를 성공시키기 위한 목적이 아닌 코드는 만들지 않는다.
    * 테스트를 나중에 작성하려고 하면, 귀찮고 막막할 수 있다.
    * TDD는 테스트를 꼼꼼하게 작성할 수 있게 하고, 테스트-애플리케이션 개발이 긴밀하게 진행되어 코드에 대한 자신감을 키운다.
    * TDD를 하지 않아도 개발 과정은 TDD와 닮아 있다. 그러나 머릿속 테스트는 제약이 심하고 오류가 많고 반복이 어렵다.
- 진작 테스트했다면 하지 않아도 될 삽질이 많다.
- 스프링은 테스트하기 편리한 구조의 애플리케이션을 만들게 돕고, 테스트를 쉽게 작성할 수 있는 기능을 다수 제공한다.
- 테스트도 깔끔하게 리팩토링할 수 있다.
- JUnit 테스트 실행 과정 요약
    1. 테스트 클래스에서 `@Test`가 붙은 public이고 void형이며 파라미터가 없는 테스트 메소드를 모두 찾는다.
    2. 테스트 클래스의 오브젝트를 하나 만든다.
        * 각 테스트 메소드를 실행할 때마다 테스트 클래스의 오브젝트는 새로 만들어짐
        * 각 테스트가 서로 영향을 주지 않고 독립적으로 실행됨을 확실히 보장하기 때문 
    3. `@Before`가 붙은 메소드가 있으면 실행한다.
        * cf. 메소드 간 주고받아야 하는 정보는 인스턴스 변수 이용 
    4. `@Test`가 붙은 메소드를 하나 호출하고 테스트 결과를 저장해둔다.
    5. `@After`가 붙은 메소드가 있으면 실행한다.
    6. 나머지 테스트 메소드에 대해 2~5번을 반복한다.
    7. 모든 테스트의 결과를 종합해서 돌려준다.
- 픽스처: 테스트를 수행하는 데 필요한 정보나 오브젝트
    * cf. FixtureMonkey라는 테스트 데이터를 편리하게 만들 수 있도록 돕는 도구가 있다. [공식문서](https://naver.github.io/fixture-monkey/), [활용예 블로그](https://jiwondev.tistory.com/272) 참고.


## 2.4 스프링 테스트 적용
- 애플리케이션 컨텍스트가 만들어질 땐 모든 싱글톤 오브젝트를 초기화해서 시간이 걸리므로 한 번만 만들고 여러 테스트가 공유하면 좋다.
- 스태틱 필드에 저장할 수도 있지만, 스프링이 직접 제공하는 애플리케이션 컨텍스트 테스트 지원 기능을 사용하면 편하다.