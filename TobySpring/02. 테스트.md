# 테스트
> 테스트는 내가 예상하고 의도한 대로 코드가 동작하는지 확인하여 만들어진 코드에 확신을 갖게 한다.


## 2.1 테스트의 필요
- 어떤 기능을 추가할 때, 작은 컴포넌트에 대한 테스트를 위해 **모든 기능 개발이 완료되어야 한다면**...
    1. 개발 기간 동안에는 안심할 수 없다.
    2. 잘 되는지 한번 확인하는 데 시간이 너무 오래 걸린다.
    3. 테스트를 한다 해도 문제의 원인을 찾기가 어렵다.
- 테스트의 관심이 다르면 테스트할 대상을 분리하자! `단위 테스트`
    * 단위를 나누는 기준? 충분히 하나의 관심에 집중해서 효율적으로 테스트할 만한 범위의 단위
    * 일반적으로는 단위가 작을수록, 레이어를 넘나들지 않을수록, 통제할 수 없는 외부 요소에 의존하지 않을수록 좋다.
    * 개발자가 스스로 자신의 코드를 빨리 확인해보기 위한 목적
    * 뭔가 추가/변경/개선 등을 할 때 side-effect가 없는지 빠르게 확인 가능 (지속적 개선 & 점진적 개발)
- 테스트는 자동으로 실행되어야 한다.
    * 수동으로 UI를 하나하나 클릭해서 테스트해야 한다면 귀찮고 휴먼에러가 나기 쉽다.
    * 자동으로 실행되면 테스트를 자주 반복할 수 있다.
- 테스트의 결과
    * 성공
    * 실패
        1. 테스트 에러 (진행되는 동안 에러 발생)
        2. 테스트 실패 (진행에는 이슈가 없으나 결과가 예상과 다름)

## 2.2 JUnit의 필요
- main 메소드와 콘솔 로그의 확인으로 만든 테스트는 약간의 수동 진행(콘솔 값 확인, main 실행 등)이 필요해서 완전 자동화된 코드가 아니며, 번거로움이 있다.
- 테스트를 효율적으로 수행하는 도구, JUnit
    * 일정한 패턴을 가진 테스트 작성 지원
    * 많은 테스트를 간단하게 실행 지원
    * 테스트 결과를 종합해서 확인 지원
    * 테스트가 실패한 곳을 빠르게 찾을 수 있게 지원
- JUnit은 **프레임워크**: IoC가 적용되었으므로 main()과 오브젝트 생성 로직이 불필요하다.
- 테스트 로직 작성
    * 테스트 메소드는 public으로 선언되어야 한다.
    * 테스트 메소드에는 `@Test` 어노테이션이 붙어있어야 한다.
- 검증 로직 작성
    * 스태틱 메소드 `assertThat`으로 값을 matcher와 비교한다.
    * 기대한 결과가 아닐 경우 `AssertionError`를 던진다.
    * 자매품: `assertTrue`, `assertFalse` 등
- 실행
    * 어딘가에 코드(JUnitCore.main)로 실행해주는 main 메소드 만들기
    * [Runner 클래스가 실행하게 하기](https://stackoverflow.com/questions/14011981/java-junit-has-no-main-function)
    * IDE 등에서 실행: Assert 문은 디버깅 용도라 실행에서 제외되어서 이를 동작하게 하려면 `-ea` 옵션 필요