# 템플릿
> 변경이 거의 일어나지 않고 일정한 패턴으로 유지되는 특성을 가진 부분을 자유롭게 변경되는 성질을 가진 부분으로부터 독립시켜서 효과적으로 활용할 수 있도록 하는 방법


## 3.1 다시 보는 초난감 DAO
- JDBC 코드는 적절한 예외처리가 필수다.
    * 예외가 발생해도 사용한 리소스를 반드시 반환해야 하기 때문
    * 예외가 발생했다고 미처 반환 못한 커넥션이 계속 쌓이면 어느 순간 커넥션 풀에 여유가 없어져 리소스가 모자란다는 심각한 오류를 내며 서버가 중단될 수 있음
    * 커넥션 풀?
        + 미리 정해진 풀 안에 제한된 수의 리소스를 만들어두고 필요할 때 할당하고 반환하면 다시 풀에 넣는 방식으로 운영
        + 필요할 때마다 매번 생성하는 방법보다 미리 만든 리소스를 돌려 사용하는 것이 훨씬 유리하기 때문
- 예외처리를 모든 메소드마다 구현하는 것은 상당히 복잡하다.
    * 로직의 흐름 중 어디에서 예외가 발생했냐에 따라 close해줘야 할 요소가 달라짐
    * 로직 자체로도 다중 try-catch-finally 문이 포함되고 모든 메소드마다 반복됨
    * 복붙이 잘못된다면...?! 폭탄이 될 가능성!


## 3.2 변하는 것과 변하지 않는 것
- 핵심: `변하지 않는, 그러나 많은 곳에서 중복되는 코드`와 `로직에 따라 자꾸 확장되고 자주 변하는 코드`를 잘 분리하는 작업
- 다양한 디자인 패턴을 적용해볼 수 있다...
    * 메소드 추출 (=> 재사용 필요한 부분이 남고 확장될 부분이 분리됨 ㅠㅠ)
    * 템플릿 메소드 패턴 (=> 메소드마다 클래스를 만들어야 하고, 관계의 유연성이 떨어짐 ㅠㅠ)
    * 전략 패턴 (=> 컨텍스트가 인터페이스 뿐 아니라 특정 구현 클래스를 알고 있음 ㅠㅠ)
    * **DI 적용을 위한 클라이언트-컨텍스트 분리**
        + 클라이언트는 자신이 사용하는 컨텍스트가 어떤 전략을 사용할지 결정한다.
        + 이와 유사하게, 메소드(클라이언트)가 자신이 사용하는 컨텍스트(공통로직)가 어떤 전략(구체적로직)을 사용할지 결정하게 한다.
        + 일종의 관심사 분리
- 마이크로 DI
    * DI
        + 제 3자의 도움으로 두 오브젝트 사이의 유연한 관계를 설정
        + 일반적으로 의존관계에 있는 두개의 오브젝트, 이 관계를 다이나믹하게 설정해주는 오브젝트 팩토리(DI 컨테이너), 이를 사용하는 클라이언트라는 4개의 오브젝트 사이에서 일어남
    * 마이크로 DI
        + IoC 컨테이너의 도움 없이 코드 내에서 DI의 장점을 단순화해서 적용
        + DI가 매우 작은 단위의 코드/메소드 사이에서 일어나는 경우들이 있을 수 있다.
            1. 원시적인 전략 패턴의 구조를 따라 클라이언트가 오브젝트 팩토리의 책임을 함께 지는 경우
            2. 클라이언트와 전략(의존 오브젝트)의 결합
            3. 클라이언트와 DI관계의 두 오브젝트가 하나의 클래스에 있음