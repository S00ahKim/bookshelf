# 구글의 테스트
> 구글 엔지니어는 이렇게 일한다 chap 11~14

## 왜 테스트?
- (시간이 많이 걸리는 작업인) 디버깅 감소
- 버그 검사 및 양산 방지
- 복잡한 대규모 시스템을 안심하고 빠르게 변경 가능
- 설계 개선 (테스트하기 좋은 코드가 실제로 좋은 코드: 단일 책임 원칙 준수, 강결합 줄임 등)
- 빠른 리뷰 (사이드 이펙트를 일일이 검증할 필요 없음)
- 더 나은 문서 (SW 문서자료는 신뢰할 수 없음)
- 수동으로 검증 가능한 한계를 극복 (자동화 필요)

## 주의
- 테스트 때문에 생산성이 떨어짐
    * 처음 만들 때 변하지 않는 테스트로 만들기 위해 노력해야 함
- 테스트가 돌릴 때마다 결과가 달라진다면 (비결정성) 신뢰 불가
- 미묘한 것들은 여전히 인간 테스터가 필요함 (복잡한 보안, 검색 결과에 대한 느낌 등)

## 구글의 정책
- 모든 코드 변경에는 지속해서 실행 가능한 테스트 필요
    * 버그 수정과 함께 누락되었던 테스트를 반드시 추가해야 함
- 자동 테스트를 수시로, 정기적으로 실행함
- 실패하는 테스트는 바로 대응
- 테스트도 제품 코드처럼 다루기 (필요하다면 리팩토링할 것)
- 테스트 인프라에 투자: 린터 개발, 문서 보강, 문화 가꾸기 등
    * 프레임워크는 조기에 표준을 정할 것
    * 문화 확산: 온보딩 필수 교육, 테스트 레벨제도, 화장실 문구
- 노하우
    * 시스템 규모의 테스트보다 작은 테스트들이 빠르고 신뢰할 수 있으며 디버깅하기 쉬움 (구글의 경우, 단위 테스트가 80%)
    * 테스트 범위의 크기가 커질수록 비결정성이 높아짐 / 제한적으로 사용
    * 테스트가 시스템을 **사용자와 같은 방식**으로 사용하게 할 것
        + **가능한 한 실제 의존성을 끊지 않고 테스트**
        + **가능한 한 실제 구현을 사용해서 테스트**
        + 테스트 대상의 내부 구현 방식에 의존하지 말 것 (**상호작용 테스트(how) < 상태 테스트(what)**)
        + private 메소드를 테스트하지 말 것
        + 좀 더 확신을 줄 수 있음
    * 모의 객체 중심주의는 확장하기 어렵다
        + 모의 객체 프레임워크에 지나치게 의존하면 테스트와 실제의 결과가 달라짐
        + 모의 객체 프레임워크에 지나치게 의존하면 상호작용 테스트를 만들게 됨
        + 모의 객체는 변경된 인터페이스에 대응하기 어려움 (ex. null 안 되게 해놨는데 null 리턴하는 테스트 객체)
    * 코드 커버리지는 테스트되지 않은 코드를 확인하는 용도로만 사용할 것 (제대로 테스트되었는지는 판단 불가)
- 효과
    * 모노레포로 운영되는 시스템의 효율적 관리
    * 상대적으로 적은 버그만 발생시키며 매일 릴리스

## 좋은 테스트
- 명확한 것
    * 존재 이유와 실패 원인을 엔지니어가 바로 알아차릴 수 있음
    * 무엇을 검사하려는지 & 이 검사가 왜 실패하는지
    * 직관적이어야 남들이 확인하기 편함
- 행위를 테스트하는 것
    * 자주 하는 실수: 테스트 구조를 코드 베이스의 구조에 맞추려고 함
    * 행위: 특정 상태에서 특정 입력을 받았을 때 시스템이 보장하는 반응 (given/when/then)
    * 메서드와 행위는 다대다 관계
    * 테스트 이름 = 행위 요약. 수행하는 동작과 예상 결과를 담기. (ex. `잔고가_부족하면_에러를_발생()`)
        + 이름에 And 가 들어가면 여러 행위를 검사하는 것임. 쪼갤 것.
- 간결한 것
    * 확인하려는 행위를 수행하는 데 필요한 정보<만> 포함해야 함
    * 그러나 **서술적이고 의미 있게 작성**하기 위해 차라리 중복이 나은 경우가 있음
        + 테스트 안에 불필요한 논리 추가 (ex. `baseUrl + "/albums"` (X))
        + 본문에 모든 정보가 있도록 해야 함 (ex. `createUser()` 같은 메소드로 테스트 객체 만들기 (X))
            - 검증 행위와 크게 관련 없는 초기화 로직의 반복은 따로 빼주는 게 나음
            - 하지만 setUp() 안에 중요한 세부 정보가 들어가서는 안 됨
- 완전한 것
    * 결과에 도달하기까지의 논리를 읽는 이가 이해하는 데 필요한 모든 정보를 본문에 갖고 있음
    * 완전성을 위해 중복이 있어도 상관 없음
- 빨리 수행되는 것
    * 소모하는 자원을 최소화: 하루에 몇백 개의 테스트가 종일 실행되는 환경
    * 병렬 실행, 빠른 하드웨어를 사용하는 등의 대안 O
    * 초기에는 빨랐던 테스트들도 시스템이 커지면 느려질 수 있음
    * 느린 테스트는 개발 속도도 늦추고, 엔지니어들은 테스트를 무시하게 될 수 있음
    * 변경되지 않은 코드는 이전 빌드 결과를 캐싱해서 사용하는 빌드 도구 사용 (ex. Bazel)
- 돌릴 때마다 항상 같은 결과를 보장하는 것
    * 비결정성의 원인? 스레드 스케줄링, 네트워크 지연, 하드웨어 인터럽트 등
    * 해당 테스트와 무관한 코드가 변경되었을 때 실패할 가능성이 있다면 나쁜 테스트
- 다양한 상황을 검증할 수 있는 것
    * 의도적으로 실패 시나리오를 테스트화

## 테스트 대역
- 실제 구현 대신 사용할 수 있는 객체/함수
- 테스트 대역이 가져오는 영향
    * 코드 베이스의 설계가 테스트하기 쉽게 되어 있지 않으면 상당한 리팩토링 필요
    * 대역은 실제 구현의 행위와 유사하게 동작해야 함
    * 잘못 사용할 경우 나쁜 테스트를 양산할 수 있으므로 되도록 실제 구현을 사용할 것
        + 모의 객체를 사용하면 테스트 작성은 쉽지만 버그를 찾기는 어려움
- 언제 사용하면 좋은가?
    * 실제 호출이 될 경우 문제가 생기는 경우
        + ex. 신용카드 결제 테스트
        + 프로덕션의 의존 대상을 테스트 대상으로 교체 (의존성 주입 활용)
    * 대역이 꼭 필요한데 자질구레한 보일러 플레이트 코드를 만들기 싫은 경우
        + ex. `@Mock CreditCardService creditCardService;`
    * 상호작용 테스트를 하려는 경우
        + 실제로 호출하지 않고 어떻게 호출되는지 검증
        + 잘 동작하는지가 아니라 호출이 되었는지만 봐줌
        + 실제 구현은 너무 느린데 가짜 객체가 존재하지 않을 때 임시방편으로 사용
        + 함수 호출 횟수나 순서가 달라지면 결과값이 다른 경우
        + 상태 **변경** 함수일 때에 한해 사용해야 함
        + 너무 세세하게 검증하려고 하지 말 것
    * 실제 구현을 못 쓰게 만드는 딱 그 부분에만 사용할 것
        + sleep, I/O 등에서 지나치게 느려진 경우 
        + 의존하는 곳에서 에러가 잦을 경우
        + 특정 에러를 일으켜야 하는 테스트인 경우
        + 원하는 특정 리턴값이 있는 경우
- 종류
    * 실제와 비슷하게 동작하되 더 간단하게 구현한 객체 `fake object` (ex. 인메모리 데이터베이스)
    * 원래는 없는 행위를 부여하는 객체 `stub` (ex. `when(foo.bar(zoo).thenReturn(null)`)
        + 왜 스터빙했는지 목적이 명확하게 드러나야 함 (assertion과 직접적인 연관이 있어야 함)
        + 특정 함수를 스텁으로 뭉갰는데 원본 소스를 자꾸 읽게 된다면 잘못 스터빙한 것
        + 스텁이 많다면 그냥 그 자체로 과용했다는 신호일 수 있음
    * 스텁보다는 가짜 객체가 최선일 때가 많다.

## 큰 테스트
- 최소 15분 ~ 며칠씩 걸리는 대규모 테스트
- 단위 테스트가 손대기 어려운 부분을 테스트 가능
    * 부정확한 테스트 대역
    * (네트워크 등) 설정 문제
    * 과부하
    * 브라우저 등 기기 테스트
    * A/B 테스트
    * 예기치 못한 동작, 입력, 부작용 등
- 유지보수가 어려움
- end-to-end 테스트는 설계에 따라 기하급수적으로 늘어날 수 있음
- 프로덕션 환경에서의 테스트는 실사용자에게 노출될 여지가 있음 (ex. webdriver torso)