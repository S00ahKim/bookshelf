# AOP
> IoC/DI, 서비스 추상화와 더불어 스프링의 3대 기반기술 중 하나


## 트랜잭션 코드의 분리
- 스프링에 자주 적용되는 AOP의 대상은 선언적 트랜잭션 기능
- 분리 방법
    * 비즈니스 로직과 트랜잭션 경계를 설정하는 로직을 분리 (by 메소드 추출ㄴ)
    * 서비스단에서 트랜잭션 코드를 분리 (by 공통 인터페이스 추출, 비즈니스구현클래스&트랜잭션구현클래스)
    * 트랜잭션 오브젝트를 먼저 사용하고 비즈니스 오브젝트를 사용하는 식으로 의존관계를 구성 (by 클라이언트 -> 트.오 -> 비.오)
    * 관련 테스트 코드 수정
- 장점
    1. 비즈니스 로직 작성시에는 트랜잭션과 같은 기술적 요소를 고려하지 않아도 됨
    2. 비즈니스 로직에 대한 테스트를 쉽게 만들 수 있음


## 고립된 단위 테스트
- 좋은 테스트는 가능한 한 작은 단위로 쪼개서 테스트하는 것 (실패시 원인 파악이 쉬움)
- 테스트 대상이 다른 오브젝트와 환경에 의존하고 있다면 작은 테스트를 만들기 어렵다.
- 테스트 대상이 다른 부분에 종속되지 않게 고립시키는 방법은 **테스트 대역**을 사용하는 것이다.
- 고립된 테스트의 장점은 (1) `의존성에 대비해 복잡하게 준비할 필요 없음` (2) `성능이 크게 향상됨` 이다.
- 개발자 테스트의 종류
    * 단위 테스트: 단위는 정하기 나름이지만, 편의상 외부 의존이 없이 고립시켜 테스트하는 것.
    * 통합 테스트: 외부 의존을 하도록 만드는 테스트. 두 개 이상의 단위가 결합한 테스트.
- 테스트 가이드
    * 항상 단위 테스트를 먼저 고려하기
    * 어떤 경우에는 통합 테스트만 가능함
    * 단위 테스트가 있더라도 통합 테스트가 필요함
- 테스트를 작성하기 편한 코드가 좋은 코드일 가능성이 높다.
- 테스트에서 사용하지 않는 인터페이스도 모두 구현해야 하는 번거로움을 피하기 위해 프레임워크를 사용할 수 있다.
- 대표적인 목 프레임워크, `Mockito`
    * 스태틱 메소드 `mock()`으로 목 오브젝트를 만들 수 있음
    * `when(@@@).thenReturn(~~)`과 같이 스텁 기능 사용 가능
    * 목 오브젝트 사용법
        1. 인터페이스로 목 오브젝트 만들기
        2. 목 오브젝트가 리턴할 값이 있으면 지정하기 (opt.)
        3. 테스트 대상 오브젝트에 DI해서 목 오브젝트로 테스트하게 하기
        4. 테스트 대상 오브젝트를 사용한 뒤 목 오브젝트의 특정 메소드가 호출되었는지 검증하기 (opt.)


## 다이나믹 프록시와 팩토리 빈
> 클라이언트 -> 프록시 -> 타깃
- 프록시
    * 클라이언트가 사용하려는 대상인 것처럼 위장해서 요청을 받아주는 객체
    * 기존 코드에는 영향을 주지 않음
    * 타깃과 같은 인터페이스를 구현함 (타깃과 같은 메소드를 구현하고 있다가 메소드 호출시 타깃으로 위임)
    * 프록시가 타깃을 제어할 수 있는 위치에 있음
    * 지정된 요청에 대해 부가기능 수행
- 타깃(실체)
    * 프록시를 통해 최종적으로 요청을 받아 처리해주는 오브젝트
- 목적
    * 클라이언트가 타깃에 **접근하는 방법을 제어**하기 위함 => `프록시 패턴`
    * 타깃에 **부가적인 기능을 부여**해주기 위함 => `데코레이터 패턴`
- 프록시 패턴
    * 타깃에 대한 접근 방법을 제어하기 위해 프록시를 사용하는 패턴
    * 클라이언트에게 타깃에 대한 레퍼런스 대신 일단 프록시를 넘겨주고, 실제로 사용하려고 할 때 프록시가 타깃 오브젝트를 생성하고 요청을 위임해주는 방식
    * 레퍼런스를 갖고는 있지만 끝까지 사용하지 않거나 많은 작업이 진행된 후 사용하는 경우라면 생성을 늦추는 이 패턴이 유용함
- 데코레이터 패턴
    * 타깃에 부가적인 기능을 런타임시 다이나믹하게 부여해주기 위해 프록시를 사용하는 패턴
    * 다이나믹? 컴파일 시점, 즉 코드상에서는 프록시와 타깃이 어떻게 연결되는지 정해져 있지 않음 (인터페이스를 통해 위임하는 방식이기 때문)
    * 프록시를 여러개 쓸 수 있어서 단계적으로 위임하는 구조 만들기 가능
    * 데코레이터의 다음 위임 대상은 인터페이스로 선언하고 생성자/수정자로 런타임 시에 외부에서 주입받으면 됨
    * 인터페이스를 통한 데코레이터 정의와 런타임 시의 다이나믹한 구성방법은 스프링DI를 사용하면 편리함
    * 타깃의 코드를 손대지 않고 클라이언트가 호출하는 방법도 변경하지 않고 새로운 기능을 추가할 때 유용함
- `java.lang.reflect`
    * 일일이 모든 인터페이스를 구현해서 클래스를 새로 정의하는 식으로 프록시를 만들기 번거롭기 때문에, 편리하게 만들 수 있도록 지원
        + 인터페이스의 모든 메소드를 구현하기 번거롭다
        + 부가기능을 모든 메소드에 중복해서 작성해야 한다
    * 리플렉션은 자바의 코드 자체를 추상화해서 접근할 수 있게 함. ex. `Method 객체`
    * 다이나믹 프록시 생성 ex. `Proxy.newInstance(@@@)`
        + 한번에 하나 이상의 인터페이스 구현 가능 (인자로 인터페이스의 배열 사용)
        + 마지막 파라미터로 부가기능&위임을 위한 InvocationHandler 구현 오브젝트 제공
    * `InvocationHandler`: 부가기능 제공을 위해 프록시 오브젝트와 독립적으로 구현해야 함.
        + 다이나믹 프록시가 클라이언트로부터 받는 모든 요청이 전달되는 invoke()만을 갖고 있는 인터페이스
        + 생성자로 받아둔 타깃 오브젝트의 메소드를 호출
        + 단일 메소드로 모든 요청을 처리하기 때문에 필요할 경우 메소드 안에서 기능 적용을 위한 분기 처리
    * 그래도 번거롭다?
        + 인터페이스의 메소드가 아주 많아진다면? 리턴 타입이 다양해진다면?
        + 타깃의 종류에 상관없이 같은 부가기능을 만들어주고 싶다면?
- 다이나믹 프록시를 DI로 사용하게 하는 방법
    * 일반적인 스프링 빈으로 등록하기 어렵다
        + 오브젝트 클래스가 다이나믹하게 결정되므로 미리 알 수 없다.
        + 다이나믹 프록시는 Proxy 클래스의 newProxyInstance() 스태틱 메소드로만 생성 가능
    * 클래스 정보를 갖고 디폴트 생성자로 만드는 것 외의 방법: **팩토리 빈**으로 생성
        + 팩토리 빈? 스프링을 대신해서 오브젝트의 생성로직을 담당하도록 만들어진 특별한 빈, 팩토리 메소드를 가진 오브젝트
        + 스프링은 FactoryBean 인터페이스를 구현한 클래스가 빈의 클래스로 지정되면 팩토리 빈 클래스의 오브젝트의 getObject()로 오브젝트를 가져와 빈 오브젝트로 사용한다. (팩토리 빈은 빈의 생성에만 사용)
        + 즉 aaa라는 빈의 설정에 class 애트리뷰트가 AAAFactoryBean으로 설정되어 있어도 getBean()하면 AAA 타입이 나온다.
        + 팩토리 빈 자체가 필요할 경우 빈 이름 앞에 &을 붙여(ex. `&aaa`) 사용한다.
    * 프록시 팩토리 빈 방식의 장점
        + 타깃의 타입과 무관하게 재사용 가능
        + 설정만 변경하면 빠르게 프록시 적용 가능
        + 타깃 인터페이스를 일일이 만드는 번거로움이 없음
        + 부가기능을 한번만 구현해도 여러 곳에서 사용할 수 있음
    * 프록시 팩토리 빈의 한계
        + 부가기능 제공은 메소드 단위로 일어남 (여러 클래스에 공통적인 부가기능 제공 불가)
        + 너무 많이 적용해야 할 경우 설정 파일이 너무 길어짐
        + TransactionHandler 오브젝트가 프록시 팩토리 빈 개수만큼 만들어짐


## 스프링의 프록시 팩토리 빈
- 스프링은 일관된 방법으로 프록시를 만들 수 있게 도와주는 추상 레이어 제공
    * 생성된 프록시는 스프링 빈으로 등록돼야 함
    * 스프링은 프록시 오브젝트를 생성해준느 기술을 추상화한 팩토리 빈 제공
- 스프링의 `ProxyFactoryBean`
    * 부가기능은 별도의 빈에 두고 생성하는 작업만 담당
    * 다이나믹 프록시의 타입을 결정하기 위한 인터페이스를 제공받지 않아도 됨 (by 인터페이스 자동검출 가능)
        + 타깃이 구현하는 인터페이스 정보를 알아냄
        + 알아낸 인터페이스를 모두 구현하는 프록시를 만들어줌
- 스프링의 `MethodInterceptor`
    * ProxyFactoryBean이 생성하는 프록시에서 사용할 부가기능을 구현하는 방법
    * InvocationHandler와는 달리 타깃 오브젝트에 대한 정보(MethodInvocation)도 함께 제공받음
    * 그래서 타깃에 독립적으로 만들어질 수 있음 => 여러 프록시에서 사용(공유)가능, 싱글톤 빈 등록가능
    * a.k.a. `Advice` (타깃에 종속되지 않는, 순수하게 부가기능을 담은 오브젝트)
- `Pointcut` (메소드 선정 알고리즘을 담은 오브젝트)
    * 타깃에 독립적으로 어드바이스를 만들기 때문에 메소드 이름 패턴을 넣어주기 곤란하므로, 분리시킨 것
        + 전략 패턴: 프록시로부터 어드바이스와 포인트컷을 독립시키고 DI를 사용하게 함
    * 프록시가 포인트컷으로부터 부가기능 적용 대상 메소드인지 확인받고, 맞으면 어드바이스를 호출하는 식
        + 템플릿 콜백 패턴: 어드바이스가 템플릿, 타깃을 호출하는 기능을 가진 MethodInvocation 오브젝트가 콜백
    * cf. 실무에서 많이 사용되는 경우는 별로 없다.
- 포인트컷과 어드바이스를 `Advisor`로 묶어서 한번에 추가
    * 프록시 팩토리 빈에는 여러개의 어드바이스와 포인트컷을 추가할 수 있음
    * 따로 등록할 경우 어떤 어드바이스에 어떤 포인트컷을 적용할지 애매해져서 묶어서 등록
    * 설정 파일에는 어드바이저를 <interceptorNames>라는 프로퍼티로 넣음. 어드바이스와 어드바이저를 혼합하기 위한 이름.