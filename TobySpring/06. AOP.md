# AOP
> IoC/DI, 서비스 추상화와 더불어 스프링의 3대 기반기술 중 하나


## 트랜잭션 코드의 분리
- 스프링에 자주 적용되는 AOP의 대상은 선언적 트랜잭션 기능
- 분리 방법
    * 비즈니스 로직과 트랜잭션 경계를 설정하는 로직을 분리 (by 메소드 추출ㄴ)
    * 서비스단에서 트랜잭션 코드를 분리 (by 공통 인터페이스 추출, 비즈니스구현클래스&트랜잭션구현클래스)
    * 트랜잭션 오브젝트를 먼저 사용하고 비즈니스 오브젝트를 사용하는 식으로 의존관계를 구성 (by 클라이언트 -> 트.오 -> 비.오)
    * 관련 테스트 코드 수정
- 장점
    1. 비즈니스 로직 작성시에는 트랜잭션과 같은 기술적 요소를 고려하지 않아도 됨
    2. 비즈니스 로직에 대한 테스트를 쉽게 만들 수 있음


## 고립된 단위 테스트
- 좋은 테스트는 가능한 한 작은 단위로 쪼개서 테스트하는 것 (실패시 원인 파악이 쉬움)
- 테스트 대상이 다른 오브젝트와 환경에 의존하고 있다면 작은 테스트를 만들기 어렵다.
- 테스트 대상이 다른 부분에 종속되지 않게 고립시키는 방법은 **테스트 대역**을 사용하는 것이다.
- 고립된 테스트의 장점은 (1) `의존성에 대비해 복잡하게 준비할 필요 없음` (2) `성능이 크게 향상됨` 이다.
- 개발자 테스트의 종류
    * 단위 테스트: 단위는 정하기 나름이지만, 편의상 외부 의존이 없이 고립시켜 테스트하는 것.
    * 통합 테스트: 외부 의존을 하도록 만드는 테스트. 두 개 이상의 단위가 결합한 테스트.
- 테스트 가이드
    * 항상 단위 테스트를 먼저 고려하기
    * 어떤 경우에는 통합 테스트만 가능함
    * 단위 테스트가 있더라도 통합 테스트가 필요함
- 테스트를 작성하기 편한 코드가 좋은 코드일 가능성이 높다.
- 테스트에서 사용하지 않는 인터페이스도 모두 구현해야 하는 번거로움을 피하기 위해 프레임워크를 사용할 수 있다.
- 대표적인 목 프레임워크, `Mockito`
    * 스태틱 메소드 `mock()`으로 목 오브젝트를 만들 수 있음
    * `when(@@@).thenReturn(~~)`과 같이 스텁 기능 사용 가능
    * 목 오브젝트 사용법
        1. 인터페이스로 목 오브젝트 만들기
        2. 목 오브젝트가 리턴할 값이 있으면 지정하기 (opt.)
        3. 테스트 대상 오브젝트에 DI해서 목 오브젝트로 테스트하게 하기
        4. 테스트 대상 오브젝트를 사용한 뒤 목 오브젝트의 특정 메소드가 호출되었는지 검증하기 (opt.)


## 다이나믹 프록시와 팩토리 빈
> 클라이언트 -> 프록시 -> 타깃
- 프록시
    * 클라이언트가 사용하려는 대상인 것처럼 위장해서 요청을 받아주는 객체
    * 기존 코드에는 영향을 주지 않음
    * 타깃과 같은 인터페이스를 구현함 (타깃과 같은 메소드를 구현하고 있다가 메소드 호출시 타깃으로 위임)
    * 프록시가 타깃을 제어할 수 있는 위치에 있음
    * 지정된 요청에 대해 부가기능 수행
- 타깃(실체)
    * 프록시를 통해 최종적으로 요청을 받아 처리해주는 오브젝트
- 목적
    * 클라이언트가 타깃에 **접근하는 방법을 제어**하기 위함 => `프록시 패턴`
    * 타깃에 **부가적인 기능을 부여**해주기 위함 => `데코레이터 패턴`
- 프록시 패턴
    * 타깃에 대한 접근 방법을 제어하기 위해 프록시를 사용하는 패턴
    * 클라이언트에게 타깃에 대한 레퍼런스 대신 일단 프록시를 넘겨주고, 실제로 사용하려고 할 때 프록시가 타깃 오브젝트를 생성하고 요청을 위임해주는 방식
    * 레퍼런스를 갖고는 있지만 끝까지 사용하지 않거나 많은 작업이 진행된 후 사용하는 경우라면 생성을 늦추는 이 패턴이 유용함
- 데코레이터 패턴
    * 타깃에 부가적인 기능을 런타임시 다이나믹하게 부여해주기 위해 프록시를 사용하는 패턴
    * 다이나믹? 컴파일 시점, 즉 코드상에서는 프록시와 타깃이 어떻게 연결되는지 정해져 있지 않음 (인터페이스를 통해 위임하는 방식이기 때문)
    * 프록시를 여러개 쓸 수 있어서 단계적으로 위임하는 구조 만들기 가능
    * 데코레이터의 다음 위임 대상은 인터페이스로 선언하고 생성자/수정자로 런타임 시에 외부에서 주입받으면 됨
    * 인터페이스를 통한 데코레이터 정의와 런타임 시의 다이나믹한 구성방법은 스프링DI를 사용하면 편리함
    * 타깃의 코드를 손대지 않고 클라이언트가 호출하는 방법도 변경하지 않고 새로운 기능을 추가할 때 유용함
- `java.lang.reflect`
    * 일일이 모든 인터페이스를 구현해서 클래스를 새로 정의하는 식으로 프록시를 만들기 번거롭기 때문에, 편리하게 만들 수 있도록 지원
        + 인터페이스의 모든 메소드를 구현하기 번거롭다
        + 부가기능을 모든 메소드에 중복해서 작성해야 한다
    * 리플렉션은 자바의 코드 자체를 추상화해서 접근할 수 있게 함. ex. `Method 객체`
    * 다이나믹 프록시 생성 ex. `Proxy.newInstance(@@@)`
        + 한번에 하나 이상의 인터페이스 구현 가능 (인자로 인터페이스의 배열 사용)
        + 마지막 파라미터로 부가기능&위임을 위한 InvocationHandler 구현 오브젝트 제공
    * `InvocationHandler`: 부가기능 제공을 위해 프록시 오브젝트와 독립적으로 구현해야 함.
        + 다이나믹 프록시가 클라이언트로부터 받는 모든 요청이 전달되는 invoke()만을 갖고 있는 인터페이스
        + 생성자로 받아둔 타깃 오브젝트의 메소드를 호출
        + 단일 메소드로 모든 요청을 처리하기 때문에 필요할 경우 메소드 안에서 기능 적용을 위한 분기 처리
    * 그래도 번거롭다?
        + 인터페이스의 메소드가 아주 많아진다면? 리턴 타입이 다양해진다면?
        + 타깃의 종류에 상관없이 같은 부가기능을 만들어주고 싶다면?