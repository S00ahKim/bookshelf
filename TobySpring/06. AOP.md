# AOP
> IoC/DI, 서비스 추상화와 더불어 스프링의 3대 기반기술 중 하나


## 트랜잭션 코드의 분리
- 스프링에 자주 적용되는 AOP의 대상은 선언적 트랜잭션 기능
- 분리 방법
    * 비즈니스 로직과 트랜잭션 경계를 설정하는 로직을 분리 (by 메소드 추출ㄴ)
    * 서비스단에서 트랜잭션 코드를 분리 (by 공통 인터페이스 추출, 비즈니스구현클래스&트랜잭션구현클래스)
    * 트랜잭션 오브젝트를 먼저 사용하고 비즈니스 오브젝트를 사용하는 식으로 의존관계를 구성 (by 클라이언트 -> 트.오 -> 비.오)
    * 관련 테스트 코드 수정
- 장점
    1. 비즈니스 로직 작성시에는 트랜잭션과 같은 기술적 요소를 고려하지 않아도 됨
    2. 비즈니스 로직에 대한 테스트를 쉽게 만들 수 있음


## 고립된 단위 테스트
- 좋은 테스트는 가능한 한 작은 단위로 쪼개서 테스트하는 것 (실패시 원인 파악이 쉬움)
- 테스트 대상이 다른 오브젝트와 환경에 의존하고 있다면 작은 테스트를 만들기 어렵다.
- 테스트 대상이 다른 부분에 종속되지 않게 고립시키는 방법은 **테스트 대역**을 사용하는 것이다.
- 고립된 테스트의 장점은 (1) `의존성에 대비해 복잡하게 준비할 필요 없음` (2) `성능이 크게 향상됨` 이다.
- 개발자 테스트의 종류
    * 단위 테스트: 단위는 정하기 나름이지만, 편의상 외부 의존이 없이 고립시켜 테스트하는 것.
    * 통합 테스트: 외부 의존을 하도록 만드는 테스트. 두 개 이상의 단위가 결합한 테스트.
- 테스트 가이드
    * 항상 단위 테스트를 먼저 고려하기
    * 어떤 경우에는 통합 테스트만 가능함
    * 단위 테스트가 있더라도 통합 테스트가 필요함
- 테스트를 작성하기 편한 코드가 좋은 코드일 가능성이 높다.
- 테스트에서 사용하지 않는 인터페이스도 모두 구현해야 하는 번거로움을 피하기 위해 프레임워크를 사용할 수 있다.
- 대표적인 목 프레임워크, `Mockito`
    * 스태틱 메소드 `mock()`으로 목 오브젝트를 만들 수 있음
    * `when(@@@).thenReturn(~~)`과 같이 스텁 기능 사용 가능
    * 목 오브젝트 사용법
        1. 인터페이스로 목 오브젝트 만들기
        2. 목 오브젝트가 리턴할 값이 있으면 지정하기 (opt.)
        3. 테스트 대상 오브젝트에 DI해서 목 오브젝트로 테스트하게 하기
        4. 테스트 대상 오브젝트를 사용한 뒤 목 오브젝트의 특정 메소드가 호출되었는지 검증하기 (opt.)
