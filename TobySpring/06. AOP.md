# AOP
> IoC/DI, 서비스 추상화와 더불어 스프링의 3대 기반기술 중 하나


## 트랜잭션 코드의 분리
- 스프링에 자주 적용되는 AOP의 대상은 선언적 트랜잭션 기능
- 분리 방법
    * 비즈니스 로직과 트랜잭션 경계를 설정하는 로직을 분리 (by 메소드 추출ㄴ)
    * 서비스단에서 트랜잭션 코드를 분리 (by 공통 인터페이스 추출, 비즈니스구현클래스&트랜잭션구현클래스)
    * 트랜잭션 오브젝트를 먼저 사용하고 비즈니스 오브젝트를 사용하는 식으로 의존관계를 구성 (by 클라이언트 -> 트.오 -> 비.오)
    * 관련 테스트 코드 수정
- 장점
    1. 비즈니스 로직 작성시에는 트랜잭션과 같은 기술적 요소를 고려하지 않아도 됨
    2. 비즈니스 로직에 대한 테스트를 쉽게 만들 수 있음


## 고립된 단위 테스트
- 좋은 테스트는 가능한 한 작은 단위로 쪼개서 테스트하는 것 (실패시 원인 파악이 쉬움)
- 테스트 대상이 다른 오브젝트와 환경에 의존하고 있다면 작은 테스트를 만들기 어렵다.
- 테스트 대상이 다른 부분에 종속되지 않게 고립시키는 방법은 **테스트 대역**을 사용하는 것이다.
- 고립된 테스트의 장점은 (1) `의존성에 대비해 복잡하게 준비할 필요 없음` (2) `성능이 크게 향상됨` 이다.
- 개발자 테스트의 종류
    * 단위 테스트: 단위는 정하기 나름이지만, 편의상 외부 의존이 없이 고립시켜 테스트하는 것.
    * 통합 테스트: 외부 의존을 하도록 만드는 테스트. 두 개 이상의 단위가 결합한 테스트.
- 테스트 가이드
    * 항상 단위 테스트를 먼저 고려하기
    * 어떤 경우에는 통합 테스트만 가능함
    * 단위 테스트가 있더라도 통합 테스트가 필요함
- 테스트를 작성하기 편한 코드가 좋은 코드일 가능성이 높다.
- 테스트에서 사용하지 않는 인터페이스도 모두 구현해야 하는 번거로움을 피하기 위해 프레임워크를 사용할 수 있다.
- 대표적인 목 프레임워크, `Mockito`
    * 스태틱 메소드 `mock()`으로 목 오브젝트를 만들 수 있음
    * `when(@@@).thenReturn(~~)`과 같이 스텁 기능 사용 가능
    * 목 오브젝트 사용법
        1. 인터페이스로 목 오브젝트 만들기
        2. 목 오브젝트가 리턴할 값이 있으면 지정하기 (opt.)
        3. 테스트 대상 오브젝트에 DI해서 목 오브젝트로 테스트하게 하기
        4. 테스트 대상 오브젝트를 사용한 뒤 목 오브젝트의 특정 메소드가 호출되었는지 검증하기 (opt.)


## 다이나믹 프록시와 팩토리 빈
> 클라이언트 -> 프록시 -> 타깃
- 프록시
    * 클라이언트가 사용하려는 대상인 것처럼 위장해서 요청을 받아주는 객체
    * 기존 코드에는 영향을 주지 않음
    * 타깃과 같은 인터페이스를 구현함 (타깃과 같은 메소드를 구현하고 있다가 메소드 호출시 타깃으로 위임)
    * 프록시가 타깃을 제어할 수 있는 위치에 있음
    * 지정된 요청에 대해 부가기능 수행
- 타깃(실체)
    * 프록시를 통해 최종적으로 요청을 받아 처리해주는 오브젝트
- 목적
    * 클라이언트가 타깃에 **접근하는 방법을 제어**하기 위함 => `프록시 패턴`
    * 타깃에 **부가적인 기능을 부여**해주기 위함 => `데코레이터 패턴`
- 프록시 패턴
    * 타깃에 대한 접근 방법을 제어하기 위해 프록시를 사용하는 패턴
    * 클라이언트에게 타깃에 대한 레퍼런스 대신 일단 프록시를 넘겨주고, 실제로 사용하려고 할 때 프록시가 타깃 오브젝트를 생성하고 요청을 위임해주는 방식
    * 레퍼런스를 갖고는 있지만 끝까지 사용하지 않거나 많은 작업이 진행된 후 사용하는 경우라면 생성을 늦추는 이 패턴이 유용함
- 데코레이터 패턴
    * 타깃에 부가적인 기능을 런타임시 다이나믹하게 부여해주기 위해 프록시를 사용하는 패턴
    * 다이나믹? 컴파일 시점, 즉 코드상에서는 프록시와 타깃이 어떻게 연결되는지 정해져 있지 않음 (인터페이스를 통해 위임하는 방식이기 때문)
    * 프록시를 여러개 쓸 수 있어서 단계적으로 위임하는 구조 만들기 가능
    * 데코레이터의 다음 위임 대상은 인터페이스로 선언하고 생성자/수정자로 런타임 시에 외부에서 주입받으면 됨
    * 인터페이스를 통한 데코레이터 정의와 런타임 시의 다이나믹한 구성방법은 스프링DI를 사용하면 편리함
    * 타깃의 코드를 손대지 않고 클라이언트가 호출하는 방법도 변경하지 않고 새로운 기능을 추가할 때 유용함
- `java.lang.reflect`
    * 일일이 모든 인터페이스를 구현해서 클래스를 새로 정의하는 식으로 프록시를 만들기 번거롭기 때문에, 편리하게 만들 수 있도록 지원
        + 인터페이스의 모든 메소드를 구현하기 번거롭다
        + 부가기능을 모든 메소드에 중복해서 작성해야 한다
    * 리플렉션은 자바의 코드 자체를 추상화해서 접근할 수 있게 함. ex. `Method 객체`
    * 다이나믹 프록시 생성 ex. `Proxy.newInstance(@@@)`
        + 한번에 하나 이상의 인터페이스 구현 가능 (인자로 인터페이스의 배열 사용)
        + 마지막 파라미터로 부가기능&위임을 위한 InvocationHandler 구현 오브젝트 제공
    * `InvocationHandler`: 부가기능 제공을 위해 프록시 오브젝트와 독립적으로 구현해야 함.
        + 다이나믹 프록시가 클라이언트로부터 받는 모든 요청이 전달되는 invoke()만을 갖고 있는 인터페이스
        + 생성자로 받아둔 타깃 오브젝트의 메소드를 호출
        + 단일 메소드로 모든 요청을 처리하기 때문에 필요할 경우 메소드 안에서 기능 적용을 위한 분기 처리
    * 그래도 번거롭다?
        + 인터페이스의 메소드가 아주 많아진다면? 리턴 타입이 다양해진다면?
        + 타깃의 종류에 상관없이 같은 부가기능을 만들어주고 싶다면?
- 다이나믹 프록시를 DI로 사용하게 하는 방법
    * 일반적인 스프링 빈으로 등록하기 어렵다
        + 오브젝트 클래스가 다이나믹하게 결정되므로 미리 알 수 없다.
        + 다이나믹 프록시는 Proxy 클래스의 newProxyInstance() 스태틱 메소드로만 생성 가능
    * 클래스 정보를 갖고 디폴트 생성자로 만드는 것 외의 방법: **팩토리 빈**으로 생성
        + 팩토리 빈? 스프링을 대신해서 오브젝트의 생성로직을 담당하도록 만들어진 특별한 빈, 팩토리 메소드를 가진 오브젝트
        + 스프링은 FactoryBean 인터페이스를 구현한 클래스가 빈의 클래스로 지정되면 팩토리 빈 클래스의 오브젝트의 getObject()로 오브젝트를 가져와 빈 오브젝트로 사용한다. (팩토리 빈은 빈의 생성에만 사용)
        + 즉 aaa라는 빈의 설정에 class 애트리뷰트가 AAAFactoryBean으로 설정되어 있어도 getBean()하면 AAA 타입이 나온다.
        + 팩토리 빈 자체가 필요할 경우 빈 이름 앞에 &을 붙여(ex. `&aaa`) 사용한다.
    * 프록시 팩토리 빈 방식의 장점
        + 타깃의 타입과 무관하게 재사용 가능
        + 설정만 변경하면 빠르게 프록시 적용 가능
        + 타깃 인터페이스를 일일이 만드는 번거로움이 없음
        + 부가기능을 한번만 구현해도 여러 곳에서 사용할 수 있음
    * 프록시 팩토리 빈의 한계
        + 부가기능 제공은 메소드 단위로 일어남 (여러 클래스에 공통적인 부가기능 제공 불가)
        + 너무 많이 적용해야 할 경우 설정 파일이 너무 길어짐
        + TransactionHandler 오브젝트가 프록시 팩토리 빈 개수만큼 만들어짐


## 스프링의 프록시 팩토리 빈
- 스프링은 일관된 방법으로 프록시를 만들 수 있게 도와주는 추상 레이어 제공
    * 생성된 프록시는 스프링 빈으로 등록돼야 함
    * 스프링은 프록시 오브젝트를 생성해준느 기술을 추상화한 팩토리 빈 제공
- 스프링의 `ProxyFactoryBean`
    * 부가기능은 별도의 빈에 두고 생성하는 작업만 담당
    * 다이나믹 프록시의 타입을 결정하기 위한 인터페이스를 제공받지 않아도 됨 (by 인터페이스 자동검출 가능)
        + 타깃이 구현하는 인터페이스 정보를 알아냄
        + 알아낸 인터페이스를 모두 구현하는 프록시를 만들어줌
- 스프링의 `MethodInterceptor`
    * ProxyFactoryBean이 생성하는 프록시에서 사용할 부가기능을 구현하는 방법
    * InvocationHandler와는 달리 타깃 오브젝트에 대한 정보(MethodInvocation)도 함께 제공받음
    * 그래서 타깃에 독립적으로 만들어질 수 있음 => 여러 프록시에서 사용(공유)가능, 싱글톤 빈 등록가능
    * a.k.a. `Advice` (타깃에 종속되지 않는, 순수하게 부가기능을 담은 오브젝트)
- `Pointcut` (메소드 선정 알고리즘을 담은 오브젝트)
    * 타깃에 독립적으로 어드바이스를 만들기 때문에 메소드 이름 패턴을 넣어주기 곤란하므로, 분리시킨 것
        + 전략 패턴: 프록시로부터 어드바이스와 포인트컷을 독립시키고 DI를 사용하게 함
    * 프록시가 포인트컷으로부터 부가기능 적용 대상 메소드인지 확인받고, 맞으면 어드바이스를 호출하는 식
        + 템플릿 콜백 패턴: 어드바이스가 템플릿, 타깃을 호출하는 기능을 가진 MethodInvocation 오브젝트가 콜백
    * cf. 실무에서 많이 사용되는 경우는 별로 없다.
- 포인트컷과 어드바이스를 `Advisor`로 묶어서 한번에 추가
    * 프록시 팩토리 빈에는 여러개의 어드바이스와 포인트컷을 추가할 수 있음
    * 따로 등록할 경우 어떤 어드바이스에 어떤 포인트컷을 적용할지 애매해져서 묶어서 등록
    * 설정 파일에는 어드바이저를 <interceptorNames>라는 프로퍼티로 넣음. 어드바이스와 어드바이저를 혼합하기 위한 이름.


## 스프링 AOP
- 부가기능을 적용해도 기존 설계/코드에는 영향을 주지 않도록...
- 빈 후처리기
    * 스프링 빈 오브젝트로 만들어진 후, 재가공 가능하게 함 (프로퍼티 강제 수정/초기화/바꿔치기 등)
    * `DefaultAdvisorAutoProxyCreator` 빈 후처리기가 등록되어 있으면...
        1. 스프링이 빈 오브젝트를 만들 때마다 후처리기에 빈을 보냄
        2. 후처리기가 빈으로 등록된 모든 어드바이저 내의 포인트컷으로 전달받은 빈이 프록시 적용 대상인지 확인
              + 등록된 모든 어드바이저? 등록된 빈 중에서 Advisor 인터페이스를 구현한 모든 것
              + 생성되는 모든 빈에 대해 어드바이저의 포인트컷을 적용해보면서 프록시 대상을 선정
        3. 후처리기가 받은 빈이 프록시 적용 대상이면 내장된 프록시 생성기에게 현재 빈에 대한 프록시를 만들게 함
        4. 후처리기가 만들어진 프록시에 어드바이저를 연결해줌
        5. 후처리기가 프록시 생성 후 컨테이너가 전달해준 빈 대신 프록시를 컨테이너에게 돌려줌
        6. 컨테이너는 후처리기가 돌려준 오브젝트를 빈으로 등록하고 사용함
        7. 결과적으로 타깃 빈에 의존하게 정의된 다른 빈들은 프록시 오브젝트를 DI받게 됨
- 포인트컷의 여러 기능
    * 프록시 적용 클래스인지 판단 기능
    * 어드바이스 적용 메소드인지 판단 기능
- 자동으로 뭔가 적용됐다 하면 확인해보자!
    * 트랜잭션이 필요한 빈에 해당 부가기능이 잘 적용됐나?
    * 아무 빈에나 트랜잭션 부가기능이 적용된 것은 아닌가?
- **포인트컷 표현식**을 이용하면 편리하게 포인트컷의 클래스와 메소드를 선정하는 알고리즘을 작성할 수 있다
    * `AspectJExpressionPointcut`
    * 포인트컷 지시자 사용 ex. `execution()`(메소드 시그니처를 비교하는 식)
    * 적용 범위(패키지명/메소드명 등 지정, 애노테이션으로 메소드 선정 등)를 세세하게 조정하면서 표현할 수 있음
    * 포인트컷 표현식의 클래스 이름에 적용되는 패턴은 클래스 이름 패턴이 아니라 타입 패턴
- 비즈니스 로직에 트랜잭션을 적용해온 과정 정리
    1. 트랜잭션의 구현 방식을 자유롭게 변경(by DI)할 수 있도록 **서비스 추상화 기법** 적용
    2. 비즈니스 로직과 트랜잭션 적용 로직 분리를 위해 **데코레이터 패턴** 적용
          + 타깃 코드는 깔끔하게
          + 부가기능은 한 번 코딩해서 재사용할 수 있게 
    3. 번거로운 프록시 클래스 생성 작업을 생략하기 위해 **JDK 다이나믹 프록시 기술** 적용
    4. 동일한 기능의 프록시를 여러군데 적용할 때 중복 생성을 막기 위해 **스프링의 프록시 팩토리 빈**을 이용 (-> 공유가능)
    5. 트랜잭션 적용 대상마다 프록시 팩토리 빈을 설정해주는 대신 컨테이너 초기화 시점에 자동으로 프록시를 만들 수 있도록 **스프링 컨테이너의 빈 생성 후처리 기법**을 활용
    6. 중복 코드를 줄이고 유사한 것은 모아두는 **모듈화**
          + 부가기능이라 스스로 독립되기 어렵다
          + 1~5까지의 기술을 적용하면서 효과적으로 모듈화 가능
          + 원시형태: 어드바이스+포인트컷(**어드바이저**)
- AOP
    * 애스펙트는 애플리케이션의 핵심기능은 아니지만, 부가기능으로서 중요한 요소
    * 객체지향 패러다임과는 구분되는 특성을 가짐
    * 객체지향을 보조하는 개념 (핵심기능을 설계/구현할 때 객체지향적 가치를 지킬 수 있게 도와줌)
- AOP 적용기술
    * [간접] 스프링 AOP는 프록시 방식의 AOP
    * [직접] `AspectJ`는 프록시 방식이 아니라 타깃 오브젝트를 뜯어고쳐서 직접 넣어주는, 바이트코드를 조작하는 방법
        + 컨테이너의 도움을 받지 않아도 됨
        + 프록시보다 강력하고 유연함
        + 추가로 번거로운 작업이 필요함 (JVM 실행 옵션 변경, 별도의 컴파일러 사용 등)
- 주요 용어
    * **타깃**: 부가기능을 부여할 대상
    * **어드바이스**: 부가기능을 담은 모듈
    * **조인포인트**: 어드바이스가 적용될 위치 (스프링 AOP에서는 메소드 실행 단계에서만 적용 가능)
    * **포인트컷**: 조인포인트 선별 작업을 정의한 모듈
    * **프록시**: 클라이언트-타깃 사이에서 부가기능을 제공해주는 오브젝트
    * **어드바이저**: 포인트컷과 어드바이스를 갖고 있는 오브젝트 (스프링 AOP의 기본)
    * **애스펙트**: OOP의 클래스처럼 AOP의 기본 모듈. 포인트컷과 어드바이스의 조합.
- 네임스페이스
    * 등록해야 하는 최소한의 빈
        + 자동 프록시 생성기 (빈 후처리기)
        + 어드바이스 (부가기능을 구현한 클래스)
        + 포인트컷 (`AspectJExpressionPointcut`을 등록, expression프로퍼티에 표현식 넣기)
        + 어드바이저 (`DefaultPointcutAdvisor`를 등록, 자동 검색되어 사용됨)
    * <bean> 대신 <aop>라는 별도 스키마 사용 가능
        + 애플리케이션을 구성하는 컴포넌트와 컨테이너의 기반기능을 위한 빈은 구분되는 것이 좋음