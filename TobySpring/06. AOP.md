# AOP
> IoC/DI, 서비스 추상화와 더불어 스프링의 3대 기반기술 중 하나


## 트랜잭션 코드의 분리
- 스프링에 자주 적용되는 AOP의 대상은 선언적 트랜잭션 기능
- 분리 방법
    * 비즈니스 로직과 트랜잭션 경계를 설정하는 로직을 분리 (by 메소드 추출ㄴ)
    * 서비스단에서 트랜잭션 코드를 분리 (by 공통 인터페이스 추출, 비즈니스구현클래스&트랜잭션구현클래스)
    * 트랜잭션 오브젝트를 먼저 사용하고 비즈니스 오브젝트를 사용하는 식으로 의존관계를 구성 (by 클라이언트 -> 트.오 -> 비.오)
    * 관련 테스트 코드 수정
- 장점
    1. 비즈니스 로직 작성시에는 트랜잭션과 같은 기술적 요소를 고려하지 않아도 됨
    2. 비즈니스 로직에 대한 테스트를 쉽게 만들 수 있음


## 고립된 단위 테스트
- 좋은 테스트는 가능한 한 작은 단위로 쪼개서 테스트하는 것 (실패시 원인 파악이 쉬움)
- 테스트 대상이 다른 오브젝트와 환경에 의존하고 있다면 작은 테스트를 만들기 어렵다.
- 테스트 대상이 다른 부분에 종속되지 않게 고립시키는 방법은 **테스트 대역**을 사용하는 것이다.
- 고립된 테스트의 장점은 (1) `의존성에 대비해 복잡하게 준비할 필요 없음` (2) `성능이 크게 향상됨` 이다.
- 개발자 테스트의 종류
    * 단위 테스트: 단위는 정하기 나름이지만, 편의상 외부 의존이 없이 고립시켜 테스트하는 것.
    * 통합 테스트: 외부 의존을 하도록 만드는 테스트. 두 개 이상의 단위가 결합한 테스트.
- 테스트 가이드
    * 항상 단위 테스트를 먼저 고려하기
    * 어떤 경우에는 통합 테스트만 가능함
    * 단위 테스트가 있더라도 통합 테스트가 필요함
- 테스트를 작성하기 편한 코드가 좋은 코드일 가능성이 높다.
- 테스트에서 사용하지 않는 인터페이스도 모두 구현해야 하는 번거로움을 피하기 위해 프레임워크를 사용할 수 있다.
- 대표적인 목 프레임워크, `Mockito`
    * 스태틱 메소드 `mock()`으로 목 오브젝트를 만들 수 있음
    * `when(@@@).thenReturn(~~)`과 같이 스텁 기능 사용 가능
    * 목 오브젝트 사용법
        1. 인터페이스로 목 오브젝트 만들기
        2. 목 오브젝트가 리턴할 값이 있으면 지정하기 (opt.)
        3. 테스트 대상 오브젝트에 DI해서 목 오브젝트로 테스트하게 하기
        4. 테스트 대상 오브젝트를 사용한 뒤 목 오브젝트의 특정 메소드가 호출되었는지 검증하기 (opt.)


## 다이나믹 프록시와 팩토리 빈
> 클라이언트 -> 프록시 -> 타깃
- 프록시
    * 클라이언트가 사용하려는 대상인 것처럼 위장해서 요청을 받아주는 객체
    * 기존 코드에는 영향을 주지 않음
    * 타깃과 같은 인터페이스를 구현함 (타깃과 같은 메소드를 구현하고 있다가 메소드 호출시 타깃으로 위임)
    * 프록시가 타깃을 제어할 수 있는 위치에 있음
    * 지정된 요청에 대해 부가기능 수행
- 타깃(실체)
    * 프록시를 통해 최종적으로 요청을 받아 처리해주는 오브젝트
- 목적
    * 클라이언트가 타깃에 **접근하는 방법을 제어**하기 위함 => `프록시 패턴`
    * 타깃에 **부가적인 기능을 부여**해주기 위함 => `데코레이터 패턴`
- 프록시 패턴
    * 타깃에 대한 접근 방법을 제어하기 위해 프록시를 사용하는 패턴
    * 클라이언트에게 타깃에 대한 레퍼런스 대신 일단 프록시를 넘겨주고, 실제로 사용하려고 할 때 프록시가 타깃 오브젝트를 생성하고 요청을 위임해주는 방식
    * 레퍼런스를 갖고는 있지만 끝까지 사용하지 않거나 많은 작업이 진행된 후 사용하는 경우라면 생성을 늦추는 이 패턴이 유용함
- 데코레이터 패턴
    * 타깃에 부가적인 기능을 런타임시 다이나믹하게 부여해주기 위해 프록시를 사용하는 패턴
    * 다이나믹? 컴파일 시점, 즉 코드상에서는 프록시와 타깃이 어떻게 연결되는지 정해져 있지 않음 (인터페이스를 통해 위임하는 방식이기 때문)
    * 프록시를 여러개 쓸 수 있어서 단계적으로 위임하는 구조 만들기 가능
    * 데코레이터의 다음 위임 대상은 인터페이스로 선언하고 생성자/수정자로 런타임 시에 외부에서 주입받으면 됨
    * 인터페이스를 통한 데코레이터 정의와 런타임 시의 다이나믹한 구성방법은 스프링DI를 사용하면 편리함
    * 타깃의 코드를 손대지 않고 클라이언트가 호출하는 방법도 변경하지 않고 새로운 기능을 추가할 때 유용함
- `java.lang.reflect`
    * 일일이 모든 인터페이스를 구현해서 클래스를 새로 정의하는 식으로 프록시를 만들기 번거롭기 때문에, 편리하게 만들 수 있도록 지원
        + 인터페이스의 모든 메소드를 구현하기 번거롭다
        + 부가기능을 모든 메소드에 중복해서 작성해야 한다
    * 리플렉션은 자바의 코드 자체를 추상화해서 접근할 수 있게 함. ex. `Method 객체`
    * 다이나믹 프록시 생성 ex. `Proxy.newInstance(@@@)`
        + 한번에 하나 이상의 인터페이스 구현 가능 (인자로 인터페이스의 배열 사용)
        + 마지막 파라미터로 부가기능&위임을 위한 InvocationHandler 구현 오브젝트 제공
    * `InvocationHandler`: 부가기능 제공을 위해 프록시 오브젝트와 독립적으로 구현해야 함.
        + 다이나믹 프록시가 클라이언트로부터 받는 모든 요청이 전달되는 invoke()만을 갖고 있는 인터페이스
        + 생성자로 받아둔 타깃 오브젝트의 메소드를 호출
        + 단일 메소드로 모든 요청을 처리하기 때문에 필요할 경우 메소드 안에서 기능 적용을 위한 분기 처리
    * 그래도 번거롭다?
        + 인터페이스의 메소드가 아주 많아진다면? 리턴 타입이 다양해진다면?
        + 타깃의 종류에 상관없이 같은 부가기능을 만들어주고 싶다면?
- 다이나믹 프록시를 DI로 사용하게 하는 방법
    * 일반적인 스프링 빈으로 등록하기 어렵다
        + 오브젝트 클래스가 다이나믹하게 결정되므로 미리 알 수 없다.
        + 다이나믹 프록시는 Proxy 클래스의 newProxyInstance() 스태틱 메소드로만 생성 가능
    * 클래스 정보를 갖고 디폴트 생성자로 만드는 것 외의 방법: **팩토리 빈**으로 생성
        + 팩토리 빈? 스프링을 대신해서 오브젝트의 생성로직을 담당하도록 만들어진 특별한 빈, 팩토리 메소드를 가진 오브젝트
        + 스프링은 FactoryBean 인터페이스를 구현한 클래스가 빈의 클래스로 지정되면 팩토리 빈 클래스의 오브젝트의 getObject()로 오브젝트를 가져와 빈 오브젝트로 사용한다. (팩토리 빈은 빈의 생성에만 사용)
        + 즉 aaa라는 빈의 설정에 class 애트리뷰트가 AAAFactoryBean으로 설정되어 있어도 getBean()하면 AAA 타입이 나온다.
        + 팩토리 빈 자체가 필요할 경우 빈 이름 앞에 &을 붙여(ex. `&aaa`) 사용한다.
    * 프록시 팩토리 빈 방식의 장점
        + 타깃의 타입과 무관하게 재사용 가능
        + 설정만 변경하면 빠르게 프록시 적용 가능
        + 타깃 인터페이스를 일일이 만드는 번거로움이 없음
        + 부가기능을 한번만 구현해도 여러 곳에서 사용할 수 있음
    * 프록시 팩토리 빈의 한계
        + 부가기능 제공은 메소드 단위로 일어남 (여러 클래스에 공통적인 부가기능 제공 불가)
        + 너무 많이 적용해야 할 경우 설정 파일이 너무 길어짐
        + TransactionHandler 오브젝트가 프록시 팩토리 빈 개수만큼 만들어짐


## 스프링의 프록시 팩토리 빈
- 스프링은 일관된 방법으로 프록시를 만들 수 있게 도와주는 추상 레이어 제공
    * 생성된 프록시는 스프링 빈으로 등록돼야 함
    * 스프링은 프록시 오브젝트를 생성해준느 기술을 추상화한 팩토리 빈 제공
- 스프링의 `ProxyFactoryBean`
    * 부가기능은 별도의 빈에 두고 생성하는 작업만 담당
    * 다이나믹 프록시의 타입을 결정하기 위한 인터페이스를 제공받지 않아도 됨 (by 인터페이스 자동검출 가능)
        + 타깃이 구현하는 인터페이스 정보를 알아냄
        + 알아낸 인터페이스를 모두 구현하는 프록시를 만들어줌
- 스프링의 `MethodInterceptor`
    * ProxyFactoryBean이 생성하는 프록시에서 사용할 부가기능을 구현하는 방법
    * InvocationHandler와는 달리 타깃 오브젝트에 대한 정보(MethodInvocation)도 함께 제공받음
    * 그래서 타깃에 독립적으로 만들어질 수 있음 => 여러 프록시에서 사용(공유)가능, 싱글톤 빈 등록가능
    * a.k.a. `Advice` (타깃에 종속되지 않는, 순수하게 부가기능을 담은 오브젝트)
- `Pointcut` (메소드 선정 알고리즘을 담은 오브젝트)
    * 타깃에 독립적으로 어드바이스를 만들기 때문에 메소드 이름 패턴을 넣어주기 곤란하므로, 분리시킨 것
        + 전략 패턴: 프록시로부터 어드바이스와 포인트컷을 독립시키고 DI를 사용하게 함
    * 프록시가 포인트컷으로부터 부가기능 적용 대상 메소드인지 확인받고, 맞으면 어드바이스를 호출하는 식
        + 템플릿 콜백 패턴: 어드바이스가 템플릿, 타깃을 호출하는 기능을 가진 MethodInvocation 오브젝트가 콜백
    * cf. 실무에서 많이 사용되는 경우는 별로 없다.
- 포인트컷과 어드바이스를 `Advisor`로 묶어서 한번에 추가
    * 프록시 팩토리 빈에는 여러개의 어드바이스와 포인트컷을 추가할 수 있음
    * 따로 등록할 경우 어떤 어드바이스에 어떤 포인트컷을 적용할지 애매해져서 묶어서 등록
    * 설정 파일에는 어드바이저를 <interceptorNames>라는 프로퍼티로 넣음. 어드바이스와 어드바이저를 혼합하기 위한 이름.


## 스프링 AOP
- 부가기능을 적용해도 기존 설계/코드에는 영향을 주지 않도록...
- 빈 후처리기
    * 스프링 빈 오브젝트로 만들어진 후, 재가공 가능하게 함 (프로퍼티 강제 수정/초기화/바꿔치기 등)
    * `DefaultAdvisorAutoProxyCreator` 빈 후처리기가 등록되어 있으면...
        1. 스프링이 빈 오브젝트를 만들 때마다 후처리기에 빈을 보냄
        2. 후처리기가 빈으로 등록된 모든 어드바이저 내의 포인트컷으로 전달받은 빈이 프록시 적용 대상인지 확인
              + 등록된 모든 어드바이저? 등록된 빈 중에서 Advisor 인터페이스를 구현한 모든 것
              + 생성되는 모든 빈에 대해 어드바이저의 포인트컷을 적용해보면서 프록시 대상을 선정
        3. 후처리기가 받은 빈이 프록시 적용 대상이면 내장된 프록시 생성기에게 현재 빈에 대한 프록시를 만들게 함
        4. 후처리기가 만들어진 프록시에 어드바이저를 연결해줌
        5. 후처리기가 프록시 생성 후 컨테이너가 전달해준 빈 대신 프록시를 컨테이너에게 돌려줌
        6. 컨테이너는 후처리기가 돌려준 오브젝트를 빈으로 등록하고 사용함
        7. 결과적으로 타깃 빈에 의존하게 정의된 다른 빈들은 프록시 오브젝트를 DI받게 됨
- 포인트컷의 여러 기능
    * 프록시 적용 클래스인지 판단 기능
    * 어드바이스 적용 메소드인지 판단 기능
- 자동으로 뭔가 적용됐다 하면 확인해보자!
    * 트랜잭션이 필요한 빈에 해당 부가기능이 잘 적용됐나?
    * 아무 빈에나 트랜잭션 부가기능이 적용된 것은 아닌가?
- **포인트컷 표현식**을 이용하면 편리하게 포인트컷의 클래스와 메소드를 선정하는 알고리즘을 작성할 수 있다
    * `AspectJExpressionPointcut`
    * 포인트컷 지시자 사용 ex. `execution()`(메소드 시그니처를 비교하는 식)
    * 적용 범위(패키지명/메소드명 등 지정, 애노테이션으로 메소드 선정 등)를 세세하게 조정하면서 표현할 수 있음
    * 포인트컷 표현식의 클래스 이름에 적용되는 패턴은 클래스 이름 패턴이 아니라 타입 패턴
- 비즈니스 로직에 트랜잭션을 적용해온 과정 정리
    1. 트랜잭션의 구현 방식을 자유롭게 변경(by DI)할 수 있도록 **서비스 추상화 기법** 적용
    2. 비즈니스 로직과 트랜잭션 적용 로직 분리를 위해 **데코레이터 패턴** 적용
          + 타깃 코드는 깔끔하게
          + 부가기능은 한 번 코딩해서 재사용할 수 있게 
    3. 번거로운 프록시 클래스 생성 작업을 생략하기 위해 **JDK 다이나믹 프록시 기술** 적용
    4. 동일한 기능의 프록시를 여러군데 적용할 때 중복 생성을 막기 위해 **스프링의 프록시 팩토리 빈**을 이용 (-> 공유가능)
    5. 트랜잭션 적용 대상마다 프록시 팩토리 빈을 설정해주는 대신 컨테이너 초기화 시점에 자동으로 프록시를 만들 수 있도록 **스프링 컨테이너의 빈 생성 후처리 기법**을 활용
    6. 중복 코드를 줄이고 유사한 것은 모아두는 **모듈화**
          + 부가기능이라 스스로 독립되기 어렵다
          + 1~5까지의 기술을 적용하면서 효과적으로 모듈화 가능
          + 원시형태: 어드바이스+포인트컷(**어드바이저**)
- AOP
    * 애스펙트는 애플리케이션의 핵심기능은 아니지만, 부가기능으로서 중요한 요소
    * 객체지향 패러다임과는 구분되는 특성을 가짐
    * 객체지향을 보조하는 개념 (핵심기능을 설계/구현할 때 객체지향적 가치를 지킬 수 있게 도와줌)
- AOP 적용기술
    * [간접] `스프링 AOP`는 프록시 방식의 AOP
    * [직접] `AspectJ`는 프록시 방식이 아니라 타깃 오브젝트를 뜯어고쳐서 직접 넣어주는, 바이트코드를 조작하는 방법
        + 컨테이너의 도움을 받지 않아도 됨
        + 프록시보다 강력하고 유연함
        + 추가로 번거로운 작업이 필요함 (JVM 실행 옵션 변경, 별도의 컴파일러 사용 등)
        + a.k.a. weaving
- 주요 용어
    * **타깃**: 부가기능을 부여할 대상
    * **어드바이스**: 부가기능을 담은 모듈
    * **조인포인트**: 어드바이스가 적용될 위치 (스프링 AOP에서는 메소드 실행 단계에서만 적용 가능)
    * **포인트컷**: 조인포인트 선별 작업을 정의한 모듈
    * **프록시**: 클라이언트-타깃 사이에서 부가기능을 제공해주는 오브젝트
    * **어드바이저**: 포인트컷과 어드바이스를 갖고 있는 오브젝트 (스프링 AOP의 기본)
    * **애스펙트**: OOP의 클래스처럼 AOP의 기본 모듈. 포인트컷과 어드바이스의 조합.
- 네임스페이스
    * 등록해야 하는 최소한의 빈
        + 자동 프록시 생성기 (빈 후처리기)
        + 어드바이스 (부가기능을 구현한 클래스)
        + 포인트컷 (`AspectJExpressionPointcut`을 등록, expression프로퍼티에 표현식 넣기)
        + 어드바이저 (`DefaultPointcutAdvisor`를 등록, 자동 검색되어 사용됨)
    * <bean> 대신 <aop>라는 별도 스키마 사용 가능
        + 애플리케이션을 구성하는 컴포넌트와 컨테이너의 기반기능을 위한 빈은 구분되는 것이 좋음


## 트랜잭션 속성
- 트랜잭션 전파? 트랜잭션의 경계에서 이미 진행 중인 트랜잭션이 어떻게 동작할 것인지를 결정하는 방식
    * `PROPAGATION_REQUIRED` 이미 시작된 트랜잭션이 있으면 참여한다
    * `PROPAGATION_REQUIRES_NEW` 항상 새로운 트랜잭션을 시작한다
    * `PROPAGATION_NOT_SUPPPORTED` 트랜잭션 없이 동작하며 이미 진행중인 트랜잭션도 무시한다
- 격리수준? 가능한 한 많은 트랜잭션을 동시에 진행시키면서도 문제가 발생하지 않게 제어하는 방식
    * 기본적으로 DB에 정해져 있으며, 이를 따르는 것이 기본값
    * 특별한 작업을 수행할 경우 독자적인 격리수준을 지정할 필요가 있음
- 제한시간? 트랜잭션을 수행하는 제한시간을 설정하는 것
    * 없는 것이 기본값
    * 전파 설정이 NOT_SUPPORTED면 무의미
- 읽기 전용? 트랜잭션 내에서 데이터를 조작하는 시도를 막음
- 설정 방법
    * 기본값을 바꾸고자 한다면 `TransactionDefinition` 오브젝트를 DI 받아서 사용하도록 하면 됨
    * 메소드별로 다른 트랜잭션 정의를 적용하려면 어드바이스의 기능을 확장해야 함: 스프링의 `TransactionInterceptor`
        + 트랜잭션 매니저, 프로퍼티 속성을 가짐
        + `rollbackOn()` ? 특정 예외에 따라 롤백을 할 것인가를 결정
            - 스프링은 기본적으로 유의미한 예외상황에서만 체크 예외를 사용하고 그 외에는 런타임 예외를 전달한다고 가정함
            - 하지만 기본 원칙을 따르지 않는 경우를 위해 위 메소드를 제공해서 다른 예외처리 지원
            - 특정 체크 예외는 트랜잭션 롤백, 특정 런타임 예외는 커밋하는 식
    * 트랜잭션 전파 항목만 필수 설정이고 나머지는 생략 가능함
    * 속성은 하나의 문자열로 정의
    * tx 네임스페이스르 이용해서 읽기 쉽게 속성 지정 가능 (권장)
    * 트랜잭션 포인트컷 표현식은 타입 패턴(인터페이스 권장)이나 빈 이름(표현이 좀더 간결)을 이용
    * 공통된 메소드 이름 규칙을 통해 최소한의 트랜잭션 어드바이스와 속성을 정할 수 있음
    * 프록시 AOP는 같은 타깃 오브젝트 내의 메소드를 호출할 때엔 적용되지 않음: AspectJ처럼 직접 조작하게
    * 트랜잭션 속성에서 읽기전용, 제한시간 등은 처음 트랜잭션이 시작할 때만 적용되고 **이후 참여하는 속성은 무시됨**
- 조언
    * 트랜잭션 전파 방식을 생각하면 필요 없어 보이는 메소드도 다른 트랜잭션에 참여할 가능성이 높으니, 트랜잭션을 정의해주는 것이 바람직함
    * 조회의 경우 읽기 전용으로 설정하면 성능 향상을 가져올 수 있음
    * 비즈니스 로직과 데이터 접근 로직을 별도로 테스트하기 위해 레이어를 분리할 것


## 어노테이션 @Transactional
- 세밀하게 튜닝된 속성을 적용해야 하는 등의 경우, 일일이 포인트컷과 어드바이스를 부여하는 대신 타깃에 어노테이션을 지정하여 유연한 설정이 가능하게 할 것
- 메소드에 부여된 설정값이 가장 우선
- 메소드 > 클래스 > 인터페이스 순으로 확인
- `<tx: annotation-driven />`
- 읽고 이해하기 쉬워서 가장 추천하는 방법


## 트랜잭션 지원 테스트
- 스프링이 트랜잭션을 정의하는 방식
    * AOP를 이용해 코드 외부에서 트랜잭션 기능을 부여해주고 속성을 지정해주는 방법: 선언적 트랜잭션 (권장)
    * 개별 데이터 기술의 트랜잭션 API로 직접 코드 안에서 사용하는 방법: 프로그램에 의한 트랜잭션
- 스프링이 트랜잭션의 자유로운 전파와 유연한 개발을 지원하는 방식
    * **AOP** (프록시로 부가기능을 애플리케이션 전반에 적용)
    * **트랜잭션 추상화**
        + **트랜잭션 매니저** (구체적 기술에 상관없이 일관된 제어 지원)
        + **트랜잭션 동기화** (시작된 트랜잭션 정보를 저장소에 보관했다가 DAO에서 공유 & 전파 지원)
- 테스트 코드로 트랜잭션을 제어해서 적용할 수 있는 테스트 기법: 롤백 테스트
    * 테스트 내의 모든 DB 작업을 하나의 트랜잭션 안에서 동작하게 하고 테스트 끝나면 무조건 롤백해버림
    * 테스트 의존성을 없애는 데 유용함: DB 작업이 있는 테스트를 해도 DB에 영향을 안 줌
    * 복잡한 데이터를 바탕으로 데이터 상태가 중요한 테스트를 실행할 때 유용함
    * 동시에 여러 테스트가 진행되어도 무관함
    * mySQL의 경우 동일한 작업을 수행하고 롤백하는 게 커밋하는 것보다 빠름 (DB by DB)
    * 테스트에 `@Transactional`이 붙어있으면 무조건 롤백됨. 반영하고 싶으면 `@Rollback(false)`을 붙이면 됨.
    * `@Rollback`은 메소드 레벨만 지원함. 클래스 단위로 지정하려면 `@TransactionConfiguration(defaultRollback=false)` 지정