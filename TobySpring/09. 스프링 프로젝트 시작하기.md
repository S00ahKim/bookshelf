# 스프링 프로젝트 시작하기
> 스프링은 유연하게 설계되어 아키텍처 종류/프로젝트 구성법에 자유도가 높다

## 자바 엔터프라이즈 플랫폼과 스프링 애플리케이션
- 스프링의 주 용도: 엔터프라이즈 애플리케이션 개발
- 가장 많이 사용되는 구조 = 클라이언트(웹 브라우저) - 백엔드(DB), a.k.a. DB를 사용하는 웹 애플리케이션
- 자바 서버가 받아들일 수 있는 요청으로 보내기만 한다면 클라이언트의 종류는 무관함
- 애플리케이션을 서버에 배포하려면 **JavaEE**(or J2EE)가 필요하다.
    1. WAS(웹 애플리케이션 서버)
        * JavaEE의 대부분의 표준 기술을 지원
        * 다양한 형태의 모듈로 배포 가능
        * 가격대가 높은 대신 안정적인 리소스 관리를 지원 (관리/모니터링 기능 뛰어남)
    2. 경량급WAS / 서블릿 컨테이너
        * 톰캣 또는 제티 등
            - 스프링 개발진 중에 톰캣 개발자들이 많아서 스프링에 최적화된 tcServer를 개발함
        * EJB, 리소스 커넥터 등이 굳이 필요하지 않은 경우
        * 선언적 트랜잭션/보안, DB 연결 풀링 등 다양한 부가기능을 라이브러리로 제공
        * 가볍고 빠르며 저렴한 비용으로 사용할 수 있음
- 배포 단위
    * 독립 웹 모듈
        + war로 패키징된 독립 웹 모듈
        + 톰캣 등 서블릿 컨테이너를 사용한다면 유일한 방법
        + 단순하고 편리한 배포 단위
    * 엔터프라이즈 애플리케이션
        + ear로 패키징된 엔터프라이즈 애플리케이션
        + 앱 내에서 EJB를 긴밀하게 사용하는 등의 경우
    * 백그라운드 서비스 모듈
        + rar로 패키징된 모듈
        + 리소스 커넥터 배포할 때 사용하는 방법
        + UI 필요 없고 서버 내에서 백그라운드 서비스처럼 사용하는 경우

## 개발도구와 환경
- JavaSE, JavaEE
    * 스프링은 버전에 따라 특정 JDK를 필요로 함
    * JavaSE/JDK (스프링 3.0의 경우, JDK 5.0 이상)
    * JavaEE/J2EE (스프링 3.0의 경우, J2EE 1.4 또는 JavaEE 5.0 이상)
- IDE: 이클립스, 인텔리제이 등
- STS(스프링 소스 툴 서비스): 최신 이클립스 기반 주요 플러그인과 도구를 모아 개발에 최적화한 IDE
    * 각종 플러그인으로 편리한 개발을 도움 ex. 빈 클래스 이름 자동완성, 오류검증 기능, 각종 위저드 등
- 라이브러리 관리와 빌드 툴
    * 직/간접적으로 참조하는 라이브러리는 수십개를 훌쩍 넘음
    * 라이브러리마다 버전이 따로 존재해서 오류 가능성 있음
    * 라이브러리 의존 관계 관리의 어려움을 해결하는 **재패키징**
    * 무슨 라이브러리를 사용할지 선정 필요
        + 애플리케이션에 무슨 기능이 들어가는지 정리
        + 그 기능을 지원하는 많은 라이브러리 중 무엇을 사용할지 선정
        + 대개 시행착오를 거침
        + 불필요한 라이브러리는 모듈 파일의 크기도 커지고 관리가 어려우므로 꼭 필요한 것만 넣을 것
- 빌드 툴과 라이브러리 관리
    * 대부분의 IDE에는 자동 빌드 기능이 있으나, 환경에 독립적인 빌드 툴을 함께 사용해야 함
    * Maven
        + 개발 과정에서 필요한 빌드, 테스트, 배치, 문서화, 리포팅 등을 지원하는 종합 프로젝트 관리 툴
        + POM이라는 프로젝트 모델 정보 이용. 라이브러리를 선언만 하면 자동으로 다운로드 받음. 전이적이라 선언 안했지만 필요한 것도 다운로드함.
        + ANT는 스크립트와 구조가 비슷한데, Maven은 선언적
    * 참고로 라이브러리는 배포되는 기술에 따라 이름을 다르게 가질 수 있음 (OSGi가 표준)

## 애플리케이션 아키텍처
### 계층형 아키텍처
- 응집도를 높이고 결합도를 낮추는 시도는 오브젝트 레벨 뿐 아니라, 아키텍처 레벨에서도 적용 가능
    * DAO끼리, 비즈니스 서비스 오브젝트끼리, 웹을 처리하는 코드끼리
    * 성격이 다른 오브젝트 그룹은 아키텍처 레벨에서 분리하는 것이 좋음 (독자적 개발 및 테스트 가능)
- 일반적으로 3계층을 가짐
    1. 데이터 액세스 계층: 백엔드의 DB나 레거시 시스템과 연동하는 인터페이스 역할 `ex. DAO, EIS(Enterprise Information System)`
       * a.k.a. DAO 계층
       * 주된 책임: 장기적 데이터 저장을 위한 DB 이용
       * 추상화 수준에 따라 수직적 계층으로 분할됨: DAO코드 - JdbcTemplate - JDBC/트랜잭션동기화 - DataSource
    2. 서비스 계층: 비즈니스 로직을 담음 `ex. 매니저, 비즈니스 로직`
       * 이상적인 POJO로 작성
       * DAO 계층을 호출하고 이를 활용해서 만들어짐
       * 데이터 액세스 기능 외에 서버/시스템 레벨에서 제공하는 기반 서비스(원격 콜, 메일링 등)를 활용할 때도 있음
       * 도메인의 핵심 비즈니스 로직이 들어있으므로, 타 계층에 종속되지 않아야 함
    3. 프레젠테이션 계층: 웹 기반 UI를 만들고 흐름을 관리함 `ex. 웹, UI, MVC`
       * 가장 복잡함. 웹 기술은 항상 새로운 모델이 등장하며 진보함.
       * 클라이언트 단에 로직이 들어가기도 함 ex. RIA(Rich Internet Application) 등
       * 스프링은 다양한 서드파티 웹 기술을 지원하며, 필요시 스프링을 없애고 다른 기술 사용 가능
- 설계 원칙
    * 각 계층은 자신의 계층의 책임에만 충실해야 한다.
       + 다른 기술의 API 사용 금지
           - DAO 인터페이스는 SQLException이 아니라 래핑한 예외 던질 것
           - 프레젠테이션 계층의 오브젝트인 HttpServletRequest가 아니라 래핑한 객체를 서비스 계층으로 던질 것
       + 계층 사이의 호출은 인터페이스를 통할 것
           - 다른 계층에서 꼭 필요한 메소드만 노출
           - DI는 계층을 구분하지 않으므로, 다른 계층의 오브젝트를 DI하지 않도록 유의

### 애플리케이션 정보 아키텍처
- 독립 애플리케이션은 사용자의 작업 상태를 오래 유지하나, 엔터프라이즈 애플리케이션은 요청을 처리하는 동안만 유지한다.
- 정보를 어떻게 다룰 것인가의 관점에서 아키텍처를 결정할 수 있다.
    1. 데이터로 다루는 경우, **데이터 중심 아키텍처**
        * 정보를 단순히 값 or 값을 담기 위한 오브젝트로 취급
        * DB의 정보를 값으로 두고 그 값을 취급하는 코드를 만들고 사용자에게 전달하는 오래된 방식
        * 계층 사이 결합도는 높고 응집도는 떨어지는 특징을 가짐
        * 핵심 비즈니스 로직의 위치에 따라 `DB에 무게를 두는 구조`와 `서비스 코드에 무게를 두는 구조`로 구분
        * DB/SQL 중심
            + 하나의 트랜잭션에 모든 계층의 코드가 종속되는 경향이 있고, 로직 재활용이 어려움
            + 따라서 개발하기 쉽지만, 변화에 취약함
        * 거대한 서비스 계층 방식
            + 복잡한 SQL은 피하고 SQL이 맡던 주요 로직은 서비스 계층에서 처리함
            + 초기 개발 속도가 빠르고 독립적 개발이 가능하며, 자바 언어의 장점을 활용할 수 있고, 테스트하기 쉬움
            + 하지만 계층 간 결합도는 여전히 높고, 객체지향 설계 적용이 어려우며, 코딩 스타일을 통일하기 어렵고, DB/SQL 중심보다 오히려 복잡한 코드를 만들 수 있음
    2. 오브젝트로 다루는 경우, **오브젝트 중심 아키텍처**
        * 객치제향 분석/모델링으로 도출한 `도메인 모델`을 반영하는 오브젝트 구조를 만들고 이를 계층 간 정보 전송에 사용함
        * DB의 데이터를 오브젝트 구조에 맞게 변환이 필요하지만, 이후 처리에 대해서는 사용처에 위임함
        * 코드 이해, 로직 작성, 코드와 메소드 재사용이 쉽고 매 SQL마다 DAO를 정의할 필요가 없음
        * 최적화된 SQL은 아니기 때문에 성능 면에서 약간의 손실이 있을 수 있음
            + ex. 안 보는 필드도 다 읽어옴
                - 자주 사용되는 필드만 모아두는 DAO를 정의함
                - `지연된 로딩`: 일부 필드만 가져오는 DAO 사용 시 NPE가 발생할 수 있어 필요시 DB에서 다시 읽어오는 기술
                - 이상적인 방법은 `ORM`(오브젝트 중심 데이터 액세스 기술)을 활용하는 것
        * 오브젝트의 활용 방법을 기준으로 `빈약한 도메인 오브젝트 방식`과 `풍성한 도메인 오브젝트 방식`으로 구분
        * 빈약한 도메인 오브젝트 방식
            + 도메인 오브젝트에 정보만 담겨 있고, 정보를 활용하는 아무런 기능도 갖고 있지 않음
            + 데이터 중심 아키텍처의 거대 서비스 구조와 유사함
            + 풍성한 방식보다 혼란이 적고 개발자 간 합의가 덜 필요함
        * 풍성한 도메인 오브젝트 방식
            + 서비스 코드가 간결해지며, 코드를 이해하기 쉽고, 객체지향적 특징을 보다 잘 살릴 수 있음
            + 도메인이 가진 정보와 깊은 관련이 있는 로직은 서비스 계층이 아니라 도메인 오브젝트에 넣는 것
            + 물론 여러 종류의 도메인 오브젝트의 기능을 조합해서 만드는 비즈니스 로직은 여전히 서비스 단에 있어야 함
            + 단, 도메인 오브젝트는 빈이 아니기 때문에 DAO를 DI 받을 수는 없음
            + 이상적인 도메인 모델링을 해두지 않았다면, 개발자 간 커뮤니케이션 미스로 중복 코드 작성 우려 있음
        * **도메인 계층 방식**
            + *도메인 오브젝트가 스스로 필요한 정보를 DAO에서 가져오고, 변경 반영을 요청하기 위해 도메인 계층의 역할과 비중을 극대화*하여 3계층과 같은 레벨로 격상시킨 방식
            + 도메인에 종속적인 비즈니스 로직의 처리는 서비스 계층이 아니라 도메인 계층의 오브젝트 안에서 진행됨
            + 도메인 오브젝트가 기존 데이터 액세스 계층이나 기반 계층의 기능을 직접 활용할 수 있음
            + 위와 마찬가지로 여러 종류의 도메인 오브젝트의 기능을 조합해서 만드는 비즈니스 로직은 여전히 서비스 단에 존재함
            + 도메인 오브젝트가 도메인 계층을 벗어나서도 사용되게 할지 말지 정해야 함
                - 여전히 모든 계층에서 도메인 오브젝트를 사용하게 할 경우
                    * 편리하지만 혼란을 야기할 수 있음
                    * 철저한 개발 가이드 제공 필요 (자체 규정 또는 AstpectJ의 정책/표준 강제화 기능 활용)
                - 도메인 오브젝트는 도메인 계층을 벗어나지 못하게 할 경우
                    * 도메인 계층 밖으로 전달할 때에는 별도의 정보 전달 오브젝트(`DTO`)를 사용해서 넘김
                    * DTO는 상태 변화를 허용하지 않아 정의된 기능이 없어 안전함
                    * 매번 변환해주어야 하는 번거로움은 AOP 등으로 자동화하는 것을 추천
            + 도메인 계층 내의 오브젝트는 싱글톤으로 계속 존재하는 게 아니라 짧은 시간 생성과 소멸을 반복함
                - 요청에 독립적인 상태를 유지해야 해서 생명 주기가 요청에 좌우됨
                - 당연하게도 빈으로 등록할 수 없고, 특별한 방식으로 DI해주어야 함
            + 불편한 방식이지만, 도메인이 복잡하고 변경이 잦을 경우 유용함 (그렇지 않은 도메인이면 오버엔지니어링)
        * 도메인 계층 방식에서가 아니더라도 DTO 사용이 필요할 때가 있다.
            + 리포트 쿼리의 결과값을 저장하는 용도
            + 코드로 데이터를 분석하고 가공한 뒤 결과값을 저장하는 용도
            + 전송 규약에 맞춰 도메인 오브젝트를 가공하려는 용도

### 스프링 애플리케이션을 위한 아키텍처 설계
- 아키텍처를 결정하는 데에는 다양한 요소를 고려하게 된다.
    * 계층구조를 어떻게 나눌 것인가?
    * 애플리케이션 정보를 어떻게 다룰 것인가?
    * 그 위에 각 계층에 사용될 구체적 기술의 종류는 무엇인가?
    * 추상화 계층을 어떻게 도입할 것인가?
    * etc.
- 계층형 아키텍처
    * 3계층이 가장 많이 사용됨
        - 프레젠테이션 계층은 보통 MVC라는 이름으로 잘 알려진 패턴을 주로 사용
        - 서비스 계층은 POJO로 구현 + 트랜잭션 AOP 적용
        - 데이터 액세스 계층은 JDBC, JPA, 하이버네이트 등 사용
    * 계층 구분은 개념적으로, 딱 끊어지는 것은 아님
        - ex. 단순한 비즈니스 로직은 서비스 계층이 따로 없을 수 있음 (서비스+DAO)
        - ex. 조건에 따르는 간단한 로직 적용은 프레젠테이션 계층에 넘길 수 있음 (프레젠테이션+서비스) [비권장]
    * SOFEA 아키텍처라는 클라이언트까지 경계를 확장하는 경우도 있음
- 정보 전송 아키텍처
    * 일단은 빈약한 도메인 오브젝트 방식으로 시작하고, 차차 단순한 기능이라도 추가해보기
    * 도메인 오브젝트를 사용하여 정보를 일관된 형태로 유지하는 게 스프링에 제일 잘 맞음
- 상태 관리와 빈 스코프
    * 특정 사용자가 독점적으로 사용하는 애플리케이션이 아니라 수많은 사용자의 요청을 효율적으로 처리하기 위해 `무상태`여야 함
    * 꼭 필요한 상태 정보는 URL, 파라미터, 쿠키 등을 사용하여 관리함
    * 스프링으로 상태유지 시스템을 만들 수도 있음
- 서드파티 프레임워크, 라이브러리 적용
    * 스프링은 거의 대부분의 자바 표준 기술 & 여러 오픈소스와 함께 사용될 수 있음
    * 오픈소스를 사용할 때에는 스프링이 공식적으로 지원하는지 확인 필요
    * 지원하는 기술이란? 스프링이 지지하는 개발철학과 프로그래밍 모델을 따르면서 사용할 수 있는 기술
        + **해당 기술을 스프링의 DI 패턴을 따라 사용할 수 있다**
            - 프레임워크/라이브러리의 핵심 클래스를 빈으로 등록할 수 있게 지원하는 것 (`팩토리 빈 클래스` 제공)
            - 만약 빈으로 바로 사용할 수 없다면 빈으로 등록 및 사용하기 적합하도록 팩토리 빈을 도입해야 함
            - ex. 하이버네이트의 SessionFactory를 빈 등록만으로 생성할 수 있도록 LocalSessionFactoryBean 클래스를 제공함
        + **스프링의 서비스 추상화가 적용됐다**
            - 비슷한 기능을 제공하는 기술에 대한 일관된 접근 방법을 정의해주는 것
            - 미리 제정된 자바 표준 스펙에 따라 다양한 구현이 있을 수 있는데, 이와 유사한 원리를 비표준 영역에도 적용한 것
                * (표준->구현) 표준 기술 스펙 준수
                * (구현->추상화) 서비스 추상화. 이미 존재하는 기술의 공통점을 분석해서 추상화함
            - 추상 서비스 인터페이스를 구현해서 각 기술과 연동하게 해주는 `어댑터 클래스`가 필요함
        + **스프링이 지지하는 프로그래밍 모델을 적용했다**
            - ex. 데이터 액세스 기술에 대한 일관된 예외 적용
        + **템플릿/콜백이 지원된다**
            - 반복되는 코드 때문에 복잡해지는 것을 방지
            - 대부분의 템플릿 클래스는 빈으로 등록해서 필요한 빈에서 DI받을 수 있음
            - 스프링이 제공하는 대표적인 템플릿 클래스들 (ft. ChatGPT)
                * `JdbcTemplate` : 스프링에서 가장 기본적으로 제공되는 JDBC 템플릿 클래스입니다. 데이터베이스와의 연동을 위한 CRUD (Create, Read, Update, Delete) 작업을 수행하는 데 사용됩니다.
                * `JPATemplate` : 스프링에서 제공하는 JPA (Java Persistence API) 템플릿 클래스로, ORM (Object-Relational Mapping) 기술을 사용하여 객체와 관계형 데이터베이스 간의 매핑을 처리하는 데 사용됩니다.
                * `RestTemplate` : HTTP 클라이언트의 역할을 하는 템플릿 클래스입니다. RESTful 웹 서비스를 호출하여 데이터를 주고받는 데 사용됩니다.
                * `JmsTemplate` : JMS (Java Message Service) 메시징 시스템과 상호작용하는 데 사용되는 템플릿 클래스입니다. 큐(queue)나 토픽(topic)을 이용하여 메시지를 전송하거나 수신하는 데 사용됩니다.
                * `MongoTemplate` : 몽고DB와 상호작용하는 데 사용되는 템플릿 클래스입니다. MongoDB의 도큐먼트(document)를 생성, 수정, 조회, 삭제하는 데 사용됩니다. 
    * 스프링이 현존하는 모든 기술을 지원하지는 못하기에, 유명한 미지원 기술들에 대해 스프링 스타일의 지원 기능을 만들어둔 프로젝트들이 있음 `ex. 스프링 익스텐션`
    * 스프링에 새로운 기술을 연동하는 일반적인 방법
        1. 스프링의 **빈**으로 해당 기술의 핵심 오브젝트를 **등록**
        2. 필요에 따라 **팩토리 빈**으로 오브젝트 생성, 초기화, 프로퍼티 노출 등을 해줌
              - 애플리케이션 내의 빈들이 새로운 기술에 대해 빈을 DI할 수 있도록
              - 반대로 기존 빈 오브젝트를 새로 추가하는 기술에서 사용할 수 있도록
        3. 필요에 따라 **서비스 추상화**
              - 스프링에 제공하는 추상 인터페이스 사용 또는 아예 새 인터페이스 구현
        4. 네트워크 접근이나 파일 IO 등 **실패할 가능성이 있는** 시도를 하는 기술이면 템플릿/콜백 방식 적용 고려
        5. 때로 AOP나 예외 전환을 적용 (내부 구현을 직접 수정하기에 한계까 있는 경우)
              - ex. 특정 예외 발생하는 경우에 대해 포인트컷을 만들어두고, 어드바이스에서 추상화된 런타임 에러로 바꿔서 던짐