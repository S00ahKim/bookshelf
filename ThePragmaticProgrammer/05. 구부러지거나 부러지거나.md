# 구부러지거나 부러지거나
> 되돌릴 수 있는 의사결정


## 서로 다른 개념을 분리해 결합도 줄이기
- 코드를 모듈로 구성하고 상호작용을 제한한다.
- 불필요한 의존이 많은 시스템은 유지보수하기 어렵고, 이로 인해 비용이 많이 들며, 시스템 자체가 매우 불안정한 경향이 있다.
- 디미터 법칙: 한 객체가 제공하는 메서드에 접근하기 위해 또 다른 객체들을 통하는 것을 허용하지 않는다.
- 넓은 코드 영역에 걸친 순환적 의존성의 해악은 되돌리기가 극히 어렵다.
- 반정규화: 정규화 법칙을 어기는 대신 속도라는 이점을 얻는 것 (비슷한 트레이드오프가 개발 과정 곳곳에서 발견됨)


## 메타프로그래밍
> 세부 사항은 코드 밖으로 옮기기
- 변화에 쉽게 적응할 수 있도록 코드를 **설정 가능**(ex. `배경색`, `텍스트`, `알고리즘`, `DB 제품` 등)하게 만든다.
    * 설정 가능하게 만든다는 것은 **일반화**한다는 것!
- **메타데이터**를 이용해서 애플리케이션에 대해 기술한다.
    * 어떻게 실행되어야 하는지, 어떤 리소스를 이용해야 하는지 등
    * 컴파일 타임이 아닌 런타임에 접근되고 사용됨
    * 가능한 한 많은 메타데이터를 써서 애플리케이션을 설정하고 실행시키기
    * 일반 텍스트로 표현하는 것을 권장
    * 시작될 때 설정 정보를 읽으면, 이를 변경할 경우 프로그램을 재시작해야 한다. 실행 중에도 리로딩할 수 있게 만들면 좋다.
- 코드에는 추상화를, 메타데이터에는 세부 내용을 기술한다.
    * 어떻게가 아니라 **무엇을 해야** 하는지 명시함 -> **선언적**으로 생각 -> 동적이고 적응가능한 프로그램을 만듦
- cf. 프로퍼티 파일, `application.yml`, 로직 스위치 등


## 시간상 결합도를 최소화
- 주요한 시간 축
    * 동시성: 같은 시각에 일어나는 일들
    * 순서: 시간 속에서 일들의 상대적 위치
- 코딩할 때 대개 순서를 무의식적으로 고려하는데, 이것도 일종의 결합이다.
- 동시성을 허용해서 시간과 순서에 따른 결합을 끊고, 유연성을 얻고 흐름 분석/아키텍처/설계/배포 등 개발 단계에서의 의존성도 줄일 수 있다.
    * 작업 흐름: 무엇이 동시에 일어나도 되고, 무엇은 아닌지 찾기
    * 아키텍처: 일관된 인터페이스 뒤의 독립적이고 동시적인 서비스 만들기 (작업 큐 & 서비스 구성)
    * 설계: 멀티 쓰레딩을 고려할 경우 동시성 때문에 제약이 생김. 이 제약은 좋은 것! **동시성을 고려해 설계하기**
        + 모든 전역 변수 및 정적 변수를 동시 접근으로부터 보호 필요
        + 호출 순서와 관련 없이 일관성 있는 상태 정보 노출 필요
    * 배포: 어떤 배포 방식을 선택하든 쉽게 적용 가능


## 단 하나의 책임만 갖도록 하기
- 이벤트: 어떤 일이 일어났음을 알림. 어떤 객체의 상태 변화를 이에 관심을 가질 만한 객체들에게 알릴 수 있음.
    * 객체들 간 결합 최소화
    * 전송자는 수신자에 대해 직접적인 지식을 가질 필요가 없음
    * 조심스러운 접근 필요. ex. 루틴 하나가 모든 이벤트를 처리하는 구조는 유지보수하기 어려움
- publish/subscribe
    * 출판자가 구독자에게 이벤트가 발생했음을 알림
    * cf. `P2P`, `softweare bus`, `CORBRA`
- Model, View, Controller
    * 데이터 자체인 `모델`
    * 모델을 표시하는 `뷰` (모델의 일부를 해석하는 방식이므로, 꼭 GUI와 관련될 필요 없음)
    * 뷰를 관리하는 `컨트롤러`


## 칠판
> 모듈들(생산자&소비자)이 데이터를 동기적, 비동기적으로 교환할 수 있는 만남의 장소를 제공하여 모듈간 결합도를 줄이는 기술
- ex. `JavaSpaces`
    * 해결해야 할 문제의 규모가 크고 복잡한 AI 앱에서 사용할 목적으로 발명됨
    * 객체의 데이터뿐 아니라 **객체 그 자체**를 저장 가능
    * 중심 기능: space에 데이터를 가져오는 `읽기`, space에 데이터를 두는 `쓰기`, 읽어오고 없애는 `가져오기`, 쓰일 때 템플릿과 일치하면 통지하는 `알리기`
- 데이터의 도착 순서와 무관하게, 칠판에 올라오면 적절한 규칙이 시동되도록 작업 흐름을 조율할 수 있다.