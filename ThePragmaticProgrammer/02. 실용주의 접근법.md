# 실용주의 접근법

## 시스템 안에서 같은 지식의 중복을 피한다
- 지식은 언제 어떤 이유에서든 변할 수 있다.
- 프로그래머는 늘 유지보수 모드에 있다.
- 여러 군데에서 중복될 만한 요소는 지속적으로 사용할 수 있는 공통 처리기를 통해 해결한다.
- 낮은 차원의 지식은 코드에 두고, 높은 차원의 지식을 주석으로 설명한다. (지속적 관리 필요)
- 문서와 코드는 모두 동일 지식에 대한 표현이다.
- 데이터를 정규화한다. (ex. 여러 객체가 가지는 특정 필드를 분리하기, 계산되는 필드는 함수화하기)
- 최대한 코드 안에서 해결되도록 한다. (ex. 복잡한 메서드를 가지더라도 바깥에서는 모르게)
- 쉬운 길보다 돌아가는 길이 지름길이다.
- 개발자들 간에 적극적이고 빈번한 소통을 가진다. (아이디어 교환, 질문 등)
- 재사용하기 쉽게 만든다. (어려우면 중복 위험)

## 하나의 지식을 여러 군데에 쪼개 두지 않는다
- 하나가 바뀌어도 나머지에 어떤 영향도 주지 않으면 서로 직교한다고 할 수 있다.
- 한 군데의 변화가 다른 군데에 문제를 만들지 않는다.
- 장점
    * 생산성 향상
        1. 개발 시간과 테스트 시간이 줄어든다.
        2. 재사용을 촉진한다. 예상치 못한 방법으로도 사용될 수 있다.
    * 리스크 감소
        1. 문제가 발생한 모듈이 격리된다.
        2. 수정할 때 문제가 발생하더라도 수정된 부분에 한정된다.
        3. 테스트하기 쉽기 때문에 더 많이 테스트하게 된다.
        4. 특정 벤더/플랫폼에 덜 종속적이다.
- 팀 빌딩
    * 애플리케이션과 인프라를 분리한다.
    * 변화에 대한 회의를 열 때, 최대한 적은 인원이 참여하게 되는 구성
- 설계
    * 다양한 방법론을 사용해 결합도를 낮춘다. (ex. 레이어링, MVC 패턴 등)
    * 현실 세계의 변화와 설계 사이의 결합도를 낮춘다. (ex. 법안, 타 회사의 정책 등과 분리)
- 써드파티 라이브러리 도입 시 직교성을 보장하는지 확인한다.
- 현재 코딩하는 부분 뿐 아니라 애플리케이션의 큰 맥락을 끊임없이 살피지 않으면 의도하지 않았어도 중복을 발생시킬 수 있다.
    * 코드 결합도 줄이기: shy code (불필요한 어떤 것도 노출하지 않으며, 다른 모듈의 구현에 의존하지 않음)
    * 전역 데이터 피하기: 다른 컴포넌트와 엮이게 된다. 싱글턴 역시 주의해서 사용하기.
    * 유사한 함수 피하기: 상당히 중복된다면 스트래티지 패턴 검토하기.
- 자신이 작성한 코드를 항상 비판적으로 검토해보는 습관을 가진다.
- 시스템과 모듈의 결합도가 낮으면 테스트 케이스에서 최소한의 컴포넌트에만 의존할 수 있다.
- 중복을 최소화한다.

## 처음으로 돌아와야 하는 경우까지 고려한다
- 구현에는 한 가지 방법만 있는 것이 아니다.
- 프로젝트 초기에 항상 최선의 결정을 내리는 것은 아니다.
- 결정된 것은 항상 변경될 수 있다.
- 코드 뿐 아니라, 아키텍처, 배포, 벤더 통합 영역에서도 유연성을 고려한다.
- 의존은 잘 정의하고 추상화한 인터페이스로 감출 수 있다.
- 무엇을 추가하든 되돌릴 수 있게 한다.

## 목표를 찾기 위해 
- 전에 만든 적 없는 것, 막연한 요구사항, 익숙하지 않은 기술 등을 사용하는 것은 미지의 세계다.
    * 완벽하게 명세하고 시작하는 것이 전형적인 반응
- 빨리, 눈에 보이게, 반복적으로 요구사항을 최종 결과물까지 도달할 수 있게 해주는 무언가(예광탄)를 일단 만든다.
    * 기본 구조를 일단 만들고 잘 되는지 확인한다.
    * 기본 구조에 점차 살을 붙여 나간다.
    * 예광탄 코드의 각 부분을 키워가면서 새로운 기능을 추가한다.
- 나중에 버릴 것이 아니다. 계속 사용할 것이기 때문에 에러 검사, 구조화, 문서화, 자기 검사가 필요하다.
    * 프로토타입은 특정 측면을 탐사하는 것이 목표이며, 버릴 것이다.
    * 예광탄은 전체적으로 어떻게 연결되는지를 아는 것이 목표이며, 골격은 유지하고 구현해 나간다.
- 프로젝트는 끝나지 않는다. 변화와 추가할 기능은 계속 생기기 마련이다.
- 장점
    * 사용자는 일찍부터 작동하는 것을 보게 된다. (눈에 보이는 진전, 기여하기 시작)
    * 개발자의 생산성을 좀 더 높일 수 있는 환경이 된다.
    * 필요하면 언제든지 통합할 수 있으므로 디버깅과 테스팅 속도도 빨라지고 정확해진다.
    * 필요하면 누군가에게 보여줄 수 있는 것이 생긴다.
    * 진행 상황에 대해 정확히 알 수 있다.
- 예광탄은 지금 만들고 있는 것을 보여주지만, 그게 항상 최종 목표와 같은 것은 아니다. 다르다면 맞을 때까지 수정해야 한다.

## 위험 요소를 확인하기 위해 간단하게 프로토타입을 만든다
- 조사 대상: 위험을 수반하는 모든 것 (전에 안해본 것, 너무 중요한 것, 실험적인 것 등)
- 기능을 구현하지 않고 인터페이스를 그려보는 식으로 만들 수도 있다.
- 아키텍처 프로토타입: 전체적인 감을 잡으려는 목적
    * 컴포넌트의 책임, 컴포넌트 간 협력관계
    * 결합도가 최소화되었는지
    * 중복, 인터페이스 정의, 제약 사항
    * 모듈이 실행 중에 적절하게 데이터에 접근할 수 있는지

## 도메인의 어휘로 코드를 작성해본다
- 솔루션은 사용하는 언어에 때로 종속된다.
- 문제 도메인에 가깝게 프로그래밍한다. (ex. 범용 에러 대신 도메인에 딱 맞는 에러 만들기)
- 도메인 지식을 슈도코드화한 것을 구현하는 방식은 더 높은 추상화 수준에서 도메인 문제 자체에 집중할 수 있게 한다.
- 복잡하지만 가독성 좋은 언어를 채택하는 것이 좋다.

## 효율적으로 추정한다
- 답변이 필요한 상황은? 높은 정확도를 요구하는 경우 vs 큰 그림을 요구하는 경우
- 사용하는 단위는 결과의 해석에 차이를 가져온다. 4주 vs 1달
- 추정의 기술
    * 비슷한 상황에 처했던 사람의 경험을 참고한다.
    * 도메인의 범위에 대해 생각한다. (ex. 사고가 나지 않는다면 20분 이내)
    * 필요하다면 간결함과 정확성을 trade-off 한다. (ex. 예시 모델 만들기)
    * 모델을 컴포넌트로 나누고, 그 안에서 전체 모델에 영향을 미치는 매개 변수가 무엇인지 파악하고, 컴포넌트끼리 어떻게 상호작용하는지 파악한다.
    * 매개 변수에 값을 준다. (ex. A환경은 B환경과 유사하므로 0.5초)
    * 답을 계산한다. 이때, 중요 매개 변수들의 값을 변경시켜 가며 비교한다. (ex. A 조건에서는 0.7초, B 조건에서는 1초)
    * 계산한 추정치를 기록하고, 조금 이상하면 왜 이상한지 규명한다.
- 코드와 함께 일정도 반복하며 조정한다. 점진적 개발의 첫 싸이클을 돌고 나면 남은 작업에 대한 추정의 정확도도 올라간다.
- 곧바로 답하는 대신 찬찬히 파악해볼 시간을 가진다.