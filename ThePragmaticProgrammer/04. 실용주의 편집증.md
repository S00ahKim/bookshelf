# 실용주의 편집증
> 완벽한 소프트웨어는 만들 수 없다.
- 방어적으로 코딩하자. 동료도, 스스로도 믿지 않는다.


## 계약에 의한 설계(DBC)
- 계약: 상대와 나의 권리와 책임을 정의
- 정확한 프로그램? 명세보다 많지도, 적지도 않게 딱 그만큼 하는 프로그램
- 만약 호출자가 루틴의 모든 선행조건을 충족한다면, 해당 루틴은 종료시 모든 후행조건과 불변식이 참이 될 것을 보증해야 한다.
- lazy code: **수용할 것에 대해서는 엄격하게, 내어줄 것에 대해서는 최소한도**
- 입력 도메인 범위, 경계 조건, 루틴이 전달할 것 등을 설계할 때 나열하는 것은 개발에 큰 도움이 된다.
- assert는 상속 관계 등 복잡한 상황의 검증이 어렵다는 한계가 있다.
- 불변식은 일시적 정책, 비즈니스 법칙에 영향 받는 것이 아니라, 의미 그 자체여야 한다.


## 에러에 대응하는 법
- 문제가 생기면 이상하게 끝까지 가기보단 **일찍 멈추게** 하는 것이 좋다. 문제가 생긴 이후는 모두 의심 대상이다.


## 반드시 그래야 한다면 검증하기
- 이런 일은 절대 일어날 리 없어 같은 건 없다. (ex. count는 음수가 될 수 없어)
- 단정문을 사용해서 불가능한 상황을 예방한다. (ex. null이면 안 된다면, 그걸 검사한다)
- 가능한 모든 에러를 체크하고, 놓친 것을 단정문으로 잡아낸다.


## 예외를 만드는 법
- 모든 예외 처리기를 제거해도 코드는 실행되어야 한다.
- 예외는 예외적인 상황을 위해서만 사용한다.


## 리소스를 사용하기 시작했으면 끝낸다
- 리소스를 할당하는 쪽에서 리소스 해제의 책임도 지게 한다.
    * 불가능할 경우... (ex. 하위 구조에서 할당해서 상위 구조가 한동안 사용)
        1. 상위 구조가 자신 하위의 할당을 모두 해제 (재귀적 반복)
        2. 상위 구조가 그냥 할당이 해제 (고아가 됨)
        3. 상위 구조에게 하위 구조가 있으면 할당 해제 거부
- 리소스를 할당한 순서의 반대로 해제한다.
- 코드의 여러 군데에서 리소스 집합을 할당한다면, 순서를 같게 한다. (데드락 방지)
- 객체지향 언어의 경우, 리소스를 클래스 안에 캡슐화하는 것이 유용하다.
    * 객체가 스코프를 벗어나거나 가비지 콜렉터가 수거해가면 소멸자가 리소스를 해제하는 식
- 리소스가 적절하게 해제되었는지 실제로 점검하는 코드를 작성하는 것이 좋다.