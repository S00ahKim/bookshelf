# 기본적인 도구
> 편한 인터페이스 바깥에서도 능숙하게 작업할 수 있다


## 일반 텍스트
- 일반 텍스트도 구조화할 수 있다.
- 일반 텍스트를 사용해 지식을 저장했을 때 장점
    * 애플리케이션에 의존적이지 않아서 항상 자명한 데이터 흐름을 알 수 있으며, 호환성이 좋다.
    * 테스트하기 쉽다.
- 하지만 더 많은 공간을 차지하고, 해석하고 처리할 때 더 많은 계산을 필요로 할 수 있다.


## 명령어 셸(shell)
- 텍스트 파일을 다루는 사람에게는 명령어 셸이 작업대가 된다.
    * 도구를 결합 by 파이프
    * 시스템 상태 확인
    * 출력 필터링
    * 매크로
- GUI의 기능은 설계자의 의도에 따른 제약을 받는다.


## 에디터
- 에디터 하나를 골라서 완전히 마스터해보자.
    * 입력해야 하는 키 개수를 줄여 본다.
    * 이미 하는 작업 외에 좀 더 많은 작업에 사용하도록 확장해본다.


## 소스코드 관리 시스템
- 반드시 사용하라. 프로토타입을 만들지라도. (저자들은 코딩 외의 용도로도 사용함)


## 디버깅
- 디버깅 앞에서 비난하지 말고, 변명하지 말자. 단지 문제 해결일 뿐이다.
- 디버깅을 할 때 **당황하지 말자**.
    * 버그의 원인을 한발짝 뒤로 물러나 **생각해본다**. **근본적인 원인**을 찾아보자.
    * 실제 문제는 내 생각보다 몇단계 뒤에 떨어져 있거나, 다른 것과 연관되어 있을 수 있다.
    * 시스템의 탓으로 돌리기보다 내 실수일 것으로 먼저 생각하자
- 컴파일러가 잡아줄 수 있는 문제를 찾느라 시간낭비하지 않도록 경고 레벨을 높게 잡는다.
- 버그가 보고되면 보고자와 이야기해서 상황을 명확히 파악할 필요가 있다.
    * 버그의 결과인가? 단순한 증상인가? (cf. 가로모드)
- 정상 상황에 대한 인공적 재현으로 테스트하는 것은 부정확할 우려가 있다. 
    * boundary condition과 실제 최종 사용자 패턴 모두를 철저하게 테스트해야 한다.
    * 제대로 작동한다고 안다 = (맥락 & 경계 조건 & 데이터) 증명
- 디버깅 전략
    * 버그 재현: 버그가 드러나는 환경을 다른 것들로부터 분리
    * 데이터 가시화: 다루는 데이터를 살펴보는 것 (상호관계를 시각화)
    * 트레이싱(로그 찍어보기): 시간 자체가 중요한 요소가 되는 시스템(ex. 동시 프로세스, 실시간 등)일 경우 특히 중요
    * 설명해보기: 차근차근 설명하는 행위 자체
- 버그가 발견되면...
    * 고치는 걸 넘어 왜 더 일찍 발견되지 못했는지 생각해보고, 필요하면 테스트를 고친다.
    * 비슷하게 위험해 보이는 조건/코드를 같이 고친다.
    * 더 쉽게 고칠 수 있는 방법을 고민한다.
    * 문제에 대해 팀과 토론한다.


## 텍스트 처리
- 텍스트 처리를 빨리 하기 위한 언어를 하나 익히면 도움이 된다.


## 코드 생성기
- 코드를 작성하는 코드를 작성한다.
- 꼭 완벽할 필요는 없다. 수고로움을 조금 덜어주는 정도여도 충분하다.
- cf. 데이터 파트에서 만들었던 마이그레이션 및 DDL 코드 생성기