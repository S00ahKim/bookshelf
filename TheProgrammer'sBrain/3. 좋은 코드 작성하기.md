# 좋은 코드 작성하기

## 명명하기
- 이름은 중요하다: 코드 베이스에서 높은 지분, 리뷰에서의 언급, 일종의 문서화, 이해에 도움
- 명명에 대한 주요 관점
    * 버틀러: 좋은 이름은 문법적으로 올바르다.
    * 알라마니스: 이름은 일관적이어야 한다.
- 초기의 명명 관행은 지속적으로 영향을 미친다.
- 명명의 인지적 측면
    * 형식이 있는 이름은 이름을 처리할 때 인지 부하가 낮고, 청킹을 지원하므로 단기 기억에 도움이 된다.
    * 명확한 이름은 우리가 알고 있던 정보와 이름에서 얻은 정보를 연결지을 수 있게 하므로 장기 기억에 도움이 된다.
        + ex1. 코드의 도메인 (customer 등)
        + ex2. 프로그래밍 개념 (tree 등)
        + ex3. 이미 아는 관행 (j는 중첩 루프의 안쪽에서 사용)
- 문자와 약자보다 단어로 된 이름이 이해하기 좋다.
    * '대부분 이런 의미로 이해하겠지'라는 의도로 사용하는 약어/단일문자는 사람마다 다르게 인식됨
- 나쁜 이름을 가진 코드에 버그가 더 많을 수 있다
- 더 나은 변수
    * 이름 틀에 대한 합의: max_X, max_X_per_Y, max_num_of_X, X_max_num 등 다양한 틀이 존재
    * 페이텔슨의 3단계 모델
        1. 이름에 포함할 개념 선택: 어떤 정보를 위한 것이고, 어떻게 사용될 것인가?
        2. 각 개념을 나타낼 단어 선택
        3. 이 단어들을 사용하여 이름 구성: 최대한 자연어에 맞추기 ('점수 최대' < '최대 점수')


## 인지 부하를 발생시키는 나쁜 코드
1. 구조적 안티패턴 (code smell)
    * 정상적으로 작동하지만, 구조가 복잡해서 파악이 어려운 경우
    * 리팩토링으로 개선할 수 있다
        + 실제로 오류를 뱉을 가능성이 더 높음
        + 나중에 개선될 가능성이 더 높음
    * 주요 코드 스멜
        + 메서드 - 너무 많은 기능을 포함한 경우
        + 클래스 - 너무 많거나, 너무 적은 기능을 포함한 경우
        + 코드 베이스 - 코드에 완전히 같지 않은 중복 코드가 있는 경우
    * 왜 인지 부하?
        1. 읽으면서 기억할 수 있는 개념엔 한계가 있음
        2. 효율적으로 청킹하기 어려움
        3. 혼동이 일어나 청킹을 잘못함
2. 언어적 안티패턴
    * 변수 이름, 메서드 이름 등과 실제 동작이 다른 경우
    * 변수명이 일반적으로 알려진 것과 다르게 동작할 때 인지 부하가 더 많이 일어남


## 복잡한 문제 해결을 더 잘하려면?
> 인지와는 큰 관련이 없다. **LTM을 강화**해야 한다
- 익숙한 문제를 해결하는 것이 더 쉽기 때문이다.
- 기억
    * 절차적 (암시적) 기억: 하는 방법이 기억나는 경우 `ex. 자전거 타는 방법`
    * 명시적 (선언적) 기억: 어떤 사실이 기억나는 경우. 기억하려면 명시적 주의(ex. 플래시 카드 외우기 등)가 필요하다.
        + 일화적 기억 `ex. 오늘은 해가 떴다`
        + 의미적 기억 `ex. 곱셈공식`

#### 문제 해결?
- 문제 해결의 요소
    1. 목표 상태 (우리가 달성하고자 하는 것. 여기에 도달하면 문제가 해결된 것이다.)
    2. 시작 상태 (문제를 해결해야 하는 처음의 상태)
    3. 시작 상태에서 목표 상태에 도달하는 방법을 규정하는 규칙
- 문제 해결이란, 가능한 적은 단계로 목표 상태에 도달하기 위해 상태 공간을 최적의 방식으로 탐색해나가는 것
- 문제 해결을 위한 사고 체계
    1. 문제 이해
    2. 계획 수립
    3. 계획 실행

#### (1) 자동화하기
- 암시적 기억 생성
- 사소한 것은 특별히 생각하는 과정 없이 그냥 수행하는 것. 에너지 소모가 줄어든다.
- 암시적 기억 생성에는 기억하려는 것을 **인지** => **연상** => **자율** 단계를 거친다.
- '알고 있다'고 생각하는 것도 몸이 다르게 기억할 수 있어서, 메인 언어가 바뀌는 등의 경우, 따로 암시적 기억의 재구성이 필요하다.
- 결국 연습을 많이 해야 한다 (꼭 무식하게 할 필요는 없다)

#### (2) 타인의 코드를 활용하기
- 명시적 기억 생성
- 문제 해결 가이드(해설)가 붙은 문제를 해결했을 때의 학습 능력이 더 좋았다.
    * 인지 부하가 낮아져 남은 에너지를 일반적 규칙을 검토하고 기억하는 데에 사용했기 때문
- 타인의 코드?
    * 타인과 협업하기
    * github에서 타인의 코드 읽기
    * 책/블로그 읽기
    * 설계 방법에 대한 설명이 포함된 코드를 연구하기