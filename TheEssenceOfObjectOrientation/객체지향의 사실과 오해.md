# 객체지향의 사실과 오해

## 01장: 협력하는 객체들의 공동체
- 흔히 프로그래밍을 현실 세계를 옮기는 것이라고들 하지만, **소프트웨어의 세계와 실세계 사이에는 거리가 있다**.
- 프로그램은 `협력`으로 이루어지며, 협력의 참여자들은 맡은 `역할`에 따라 `책임`을 다한다.
    * 협력 = 요청 + 응답
    * 역할 = 책임
    * 기능 -> 다수의 책임으로 분할 -> 책임은 역할을 맡은 객체에 의해 수행
- 적절한 객체에게 적절한 책임을 부여하는 것이 핵심이다.
- 객체는 `협력적`이고 `자율적`이어야 한다.
    * 자율 = 행동과 상태를 객체가 가지는 것
    * 협력 = 메시지를 송수신


## 02장: 이상한 나라의 객체
- 오히려 프로그래밍은 **새로운 세계를 창조**하는 것에 가깝다.
    * 현실에서는 수동적인 존재가 소프트웨어에서는 능동적 객체가 된다. (의인화)
    * 현실과 소프트웨어 간의 공통점을 드러내기 위해 이름을 유사하게 짓는다. (은유)
- 세상을 객체로 분할하는 것은 세상의 복잡성을 극복하려는 시도다.
- **행동이 상태를 결정한다!**
    * 설계를 할 때 무슨 행동을 할지를 먼저 생각하고 **그 행동에 필요한** 상태를 고려하는 것이 순서다.
    * 반대로 되면 캡슐화가 저해되고, 협력과 멀어지며, 다양한 협력에 참여(재사용)하기 어려워진다.
- 객체지향 설계의 과정
    1. 협력을 생각
    2. 협력에 참여하는 데에 필요한 행동을 생각
        * `행동` = 협력에서 완수해야 할 `책임`
        * 즉 무슨 책임이 필요한지를 결정하는 과정이 전체 설계를 주도함 (책임주도설계)
    3. 행동을 수행할 객체를 선택


## 03장: 타입과 추상화
- 추상화? 의도적 생략/일반화로 불필요한 것을 쳐내고 본질을 드러내어 단순화하는 것
- 중요한 것은 **목적**에 충실한 것이다.
- 공통점을 묶어 `개념`(concept)을 추출하고, 그 개념을 객체에 부여(`분류`)하면 객체는 개념의 `인스턴스`가 된다.
- 프로그래밍에서 개념은 `타입`이라고 불린다.
- **객체가 어느 타입인지 정하는 것은 객체의 행동**이다. 행동만 같으면 다른 객체도 같은 타입이라고 볼 수 있다.
- 객체의 내부적 표현은 외부로부터 감춰진다.
- 일반화/특수화 개념은 상속으로 표현할 수 있다.
- 모델의 종류
    * 동적 모델: 객체가 **특정 시점**에 무슨 상태인지를 중시. 객체의 변화에 초점을 맞춘다. `ex. UML 객체 다이어그램`
    * 정적 모델: 시간에 독립적으로 모든 상태와 행동을 표현. `ex. 클래스`


## 04장: 역할, 책임, 협력
- 객체의 책임은 아는 것과 하는 것으로 나뉜다.
- 역할을 맡는 객체는 대체할 수 있다. 그러나 메시지 수신은 같은 방식으로 해야 한다.
- 역할 책임 협력의 측면으로 설계하기
    1. 책임 주도 설계
        * 책임을 식별하고 적합하게 할당함
        * 객체의 책임과 상호작용을 상태에 우선해서 고려
    2. 디자인 패턴
        * 반복되는 해결 방법 (미리 식별해둔 역할 책임 협력 모음)
    3. 테스트 주도 개발
        * 테스트를 작성하면서 역할/책임/협력을 식별하고, 코딩하면서 **그 식별이 적합한지 피드백**함
            + 테스트를 작성하는 거 자체가 중요한게 아님
            + 식별 = 기대하는 역할, 협력의 참여자 등
        * 테스트를 작성할 때는...
            + 객체가 이미 존재한다고 가정하고 객체에게 어떤 메시지를 전송할지에 대해 먼저 생각한다.
            + 리턴값 검증 = 책임을 고려함
            + 스텁 or 목을 사용 = 협력자에 대해 고민함


## 05장: 책임과 메시지
- 객체지향 =/= 클래스
    * 클래스는...
        + 객체의 속성과 행위를 담는 틀일 뿐!
        + 동적인 객체들의 특성과 행위를 정적인 텍스트로 표현하기 위해 사용할 수 있는 추상화 도구일 뿐!
    * 중요한 것은 클래스가 아니라 객체
    * 시스템을 정적 클래스의 집합이 아니라 **동적인 객체의 집합**으로 보는게 객체지향 패러다임의 시작
        + **협력하는** 객체들의 관점에서 시스템을 봐야 한다! (독립된 단위 X)
- 객체를 이용하는 이유는 객체가 제공하는 책임 때문이다.
    * 훌륭한 책임 = 뭘 제공하고 뭘 얻을 것인가를 고려해야
    * `what/who 사이클` 활용: **무슨 행위가 필요한가** => 그 행위를 수행할 객체를 결정
    * 즉 무슨 객체가 필요한지를 생각하는 게 아니라 무슨 책임이 필요한지 생각하는 것
- 책임은 **자율성을 보장할 수 있을 만큼 추상적**이되 **협력의 의도를 표현할 수 있을 만큼 구체적**이어야 한다.
- 객체가 책임을 수행하는 유일한 방법은 메시지다.
    * 메시지 수신시 책임 수행하는 방법이 메소드. 이름과 인자로 구성됨.
    * 메시지 송신자가 수신자에 대한 정보를 적게 알고 있더라도 협력이 가능해야 한다.
        + 그래야 협력이 유연해지고 확장/재사용이 가능하다.
        + 타 객체의 상태를 묻지 말고, 그냥 시켜라.
    * `메시지`로 `무엇`을 할지만 정해주면 `어떻게` 할지는 `객체`가 정한다.
- 수신 가능한 메시지를 모으면 객체의 **인터페이스**가 나온다.
    * 사용법만 알고 내부 원리는 몰라도 ㄱㅊ
    * 내부 원리만 변경해도 이슈 X
    * 구체적 수행자는 바뀌어도 됨
- 객체지향적으로 인터페이스를 만드는 방법
    * **너무 구체적으로 메시지를 보내기보다 자율성을 보장할 수 있도록 어느정도 추상적으로 설계**
    * 외부에서 사용할 필요 없는 인터페이스는 최소로 노출
        + 캡슐화 = 구현을 외부로부터 감춤
        + 객체는 상태와 행위를 함께 캡슐화해서 충분히 협력적이고 만족스러울 정도로 자율적인 존재가 될수있다.
    * 인터페이스와 구현 간에는 차이가 있다
        + 객체의 외부와 내부를 명확히 분리해서 설계: 외부 공개 `인터페이스` & 내부에 감춰지는 `구현`


## 06장: 객체 지도
- 기능이 아니라 **구조를 기반으로 모델을 구축**하라
- 설계의 가장 큰 도전은 기능과 구조라는 두 가지 측면을 함께 녹여 조화를 이루게 하는 것이다.
    * 도메인모델링과 유스케이스 모델링은 서로를 보완하긴 하지만 다른 쪽으로 바로 변환할 수는 없다.
    * 목표? 불안정한 `기능`을 안정적인 `구조` 안에 담아서 변경의 파급효과 최소화하는 것!
    * 어떻게? 유스케이스에 정의된 `시스템의 기능`을 도메인 모델을 기반으로 한 `객체`들의 책임으로 분배
        1. 유스케이스에서 사용자가 달성하려는 목표 & 첫번째 메시지를 얻어옴
        2. 도메인 모델로부터 기능을 수용할 수 있는 안정적 구조를 제공받음
        3. 실제로 동작하는 객체들의 협력 공동체를 창조 (객체들 간 메시지 전송 정의)
- 요구사항은 예측 불가능하게 변한다. 미래를 대비하는 방법은 예측하는 게 아니라 변경을 수용할 수 있는 선택의 여지를 설계에 마련해 놓는 것.
- `기능`(제품이 사용자를 위해 뭘 할 수 있나)은 자주 변경된다.
    * 유스케이스 모델링
        + 공통의 사용자 목표를 통해 강하게 연관된 시나리오의 집합
        + 즉, 산발적으로 흩어진 사용자들의 목표(기능적 요구사항)를 문맥(이야기 형식)으로 묶는 것
        + 수많은 요구사항을 보다 기억하기 좋게 만들어줌
    * 불안정한, 기능을 서술하는 것
        + 사용자 시스템 간의 상호작용을 쓰는 텍스트임 (다이어그램이 아님)
        + 피처들을 묶음, 세부 설계는 배제하고 외부 관점만 표현
    * 사용자의 목표를 만족시키기 위해 책임을 수행하는 시스템의 행위로 표현됨
- `구조`(제품의 형태가 어떠해야 하나)는 변경될 일이 적어 안정적이다.
    * 도메인 모델링
        + 도메인 = 소프트웨어로 해결하려는 문제 분야
        + 도메인 모델은 이해관계자가 도메인을 보는 관점이다.
        + 다양한 관점이 있을 수 있으나, 코드는 **사용자가 도메인을 보는 관점**을 코드에 은유로 담아야 한다. 그것이 본질에 가깝고, 변경이 적다.
        + 도메인 모델링 기법과 도메인 프로그래밍 기법이 동일하다는 게 객체지향의 장점이다.
    * 안정적 구조로 개념화하는 것
        + 도메인 모델을 구성하는 '개념'은 비즈니스가 파격적으로 변하지 않는 한 안정적으로 유지되는 것들이다.
    * 사용자나 이해관계자들이 도메인에 관해 생각하는 개념과 개념들 간의 관계로 표현됨 


## 07장: 함께 모으기
- 설계의 세 가지 관점
    1. 개념 관점: 도메인 안에 존재하는 개념과 개념사이의 관계를 표현
    2. 명세 관점: 객체들의 책임에 초점을 맞춰 인터페이스를 작성
    3. 구현 관점: 실제 코드 작업
- 작업 착수 전에 아무리 설계를 잘 하려고 해도 부족하다. 구현하면서 설계는 수정된다. 최대한 빨리 구현해서 설계를 피드백하라.
- 설계는 세 가지 관점을 모두 표현할 수 있어야 하고, 각 관점이 뒤섞이지 않도록 유의해야 한다.