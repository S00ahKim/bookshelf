# 클래스


## 클래스 체계
- 작성 순서: 순차적 추상화 (static public 변수, static private 변수, private 변수 (public instance 변수의 필요는 거의 없다), public 함수, public에서 호출하는 private 함수)
- 캡슐화: 변수와 유틸리티 함수는 공개하지 않는 것이 좋지만, 꼭 숨겨야 하는 것은 아님. 테스트에 필요하다면 protected, 캡슐화를 없애는 것은 지양.


## 클래스는 작아야 한다
- 무조건 작게!
- 얼마나? 함수는 절대 길이가 짧은 것. 클래스는 맡은 책임이 작은 것. 함수는 몇 개 없어도 책임이 많을 수 있다.
    * 작은 크기의 클래스는 간결한 이름으로 작명하기 쉽다
    * 모호한 이름 `ex. Manager, Processor` **X**
    * if, and, or, but **X**
- 단일 책임 원칙
    * 클래스를 변경할 이유(=책임)는 하나여야 함
    * 변경할 이유를 파악하려고 하다 보면 추상화하기 쉬워진다.
    * 일단 돌아가게 만드는 것은 좋다. 좋은 코드로 리팩토링하자.
    * 너무 작은 클래스가 많아지면 불편할 수 있다는 우려: 규모가 큰 시스템은 복잡하고, 복잡성을 다루는 데에는 체계적인 정리가 필요함
- 응집도
    * 클래스의 인스턴스 변수의 수는 작아야 함
    * 클래스의 응집도는 높을수록 좋음
        + 인스턴스 변수를 사용하는 메서드가 많을수록 클래스의 응집도는 높다
    * 응집도를 유지하면 작은 클래스 여럿이 나온다
        + 함수를 작게, 매개변수 목록을 짧게 -> 몇몇 메서드만 사용하는 인스턴스 변수가 많아짐 -> 클래스의 응집도 낮아짐 -> 클래스 쪼개기
- 리팩토링한 프로그램이 물리적으로 길어질 수 있다
    * 길고 서술적인 변수 이름
    * 주석 대신 함수와 클래스 선언
    * 가독성을 위한 공백과 형식 맞추기


## 변경하기 쉬운 클래스
- 시스템은 필연적으로 변화한다. 변화엔 리스크가 있다. 깨끗한 시스템은 리스크 가능성을 낮춘다.
- ex. `class Sql` -> `class SelectSql extends Sql` (+ SRP, OCP 만족)
- 변경으로부터의 격리
    * 상세한 구현에 의존하는 코드는 테스트가 어렵다
    * 인터페이스/추상 클래스로 추상적인 형태를 만들면, 구현체에 의존하지 않는 테스트 코드 작성을 할 수 있다.
        + 상세한 구현 클래스가 아니라 인터페이스에 의존하게 클래스 작성
        + !!! Portfolio는 StockExchange로 주식 가격을 받아오지, TokyoStockExchange에서 받아오는 게 아니다!
        + **인터페이스에서는 추상적 개념만 표현하고, 구체적으로 어떻게 하는지는 숨긴다.**
    * 시스템의 결합도를 낮추면 유연성과 재사용성이 높아진다.
        + 결합도? 시스템 요소가 서로 잘 격리되어 있음 (각 요소를 이해하기 쉬워짐)
        + 결합도를 줄이면 DIP를 따르는 클래스