# 시스템
- 도시는 적절히 추상화, 모듈화되어 전체적인 모습을 이해하지 못할지라도 각각의 구성요소는 효율적으로 돌아간다.
- 낮은 추상화 수준 -> 클린 코드, 높은 추상화 수준(= 시스템 수준) -> 클린 아키텍처
- 모든 추상화 수준에서 의도는 명확하게
- 가장 단순한 수단 사용


## 시스템 제작과 사용 분리
- 객체를 제작하고 의존성을 연결하는 `준비` 과정, 이후의 `런타임 로직`
- 시작 단계 역시 하나의 관심사concern다.
- 시작 단계를 분리하지 않으면... 
    * 런타임 로직이 시작 단계에 의존성을 가짐
    * 테스트하기 어려움
    * SRP 해침
    * 코드가 사용한다고 한 객체가 모든 상황에 적합한가?
- 시스템 생성과 사용을 분리하는 방법들
    * Main 분리: 생성은 모두 main이나 main이 호출하는 모듈에, 나머지 시스템에서는 모든 객체가 생성되었고, 의존성도 연결되었다고 가정
    * 팩토리: 객체 `생성 시점`을 애플리케이션이 결정해야 할 경우 사용할 수 있는 방법
    * 의존성 주입: IoC (제어 역전) 기법을 의존성 관리에 적용한 방법
        + 제어 역전? 한 객체가 맡은 보조 책임을 새로운 객체에게 떠넘김
        + 객체는 의존성 자체를 인스턴스로 만드는 책임을 다른 전담 객체(ex. main, 특수 컨테이너 등)에 넘긴다
        + ex. 스프링 프레임워크: 의존성은 XML 파일에, 코드에서 이름으로 객체 요청 + 초기화 지연(팩토리/프록시)


## 확장
- 확장이 필요 없게 (X) 확장이 쉽게 (O)
    * 처음부터 올바르게 만들 순 없다. 오늘의 요구사항에 대응하는 것이 옳다.
    *  **관심사를 적절히 분리**한 아키텍처는 점진적으로 확장될 수 있다.
- Aspect Oriented Programming은 횡단 관심사에 대처해 모듈성을 확보하는 일반적인 방법이다.
    * for `영속성`(어떠한 상태가 계속 유지되는 것), `보안`, `트랜잭션`, `캐시`, `장애조치` 등
    * 영속적으로 저장할 객체와 속성을 정의하고 책임을 프레임워크에 위임하여 프레임워크로 하여금 코드에 영향을 미치지 않는 쪽으로 동작을 변경하게 함
    * **Aspect**(관점): AOP에서 모듈을 구성하는 개념. 특정 aspect를 지원하려면 시스템에서 특정 지점의 동작 방식을 일관성 있게 바꿔야 함.
        + 자바 프록시: 객체가 아닌 객체를 조작하는 대리 객체로 객체와 상호작용
            * 객체 생성과 관련된 부가적인 처리(흐름제어)를 한다.
            * 흐름제어만 할 뿐 결과값을 조작하거나 변경시키면 안된다.
            * 비지니스 로직의 변경 없이도 기능을 추가하거나 수정할 수 있다. 
            * 프록시 종류?
                1. 가상 프록시 : 필요 시점까지 실제 객체를 생성하지 않고 통제하여 메모리 절약
                2. 원격 프록시 : 다른 머신에 있는 객체 사용
                3. 보호 프록시 : 객체에 대한 액세스 권한 부여
                4. 정교한 참조 : 객체 생성과 관련하여 추가적인 처리 
            * 단점
                1. 코드 양이 많아짐 & 코드 크기가 커짐
                2. 복잡함. 깨끗한 코드를 작성하기 어려움.
                3. 시스템 단위로 실행 '지점'을 명시하기 어려움.
        + 순수 자바 AOP 프레임워크
            * AspectJ를 사용하지 않는 순수 자바 프레임워크(ex. JBoss AOP, Spring AOP 등)는 내부적으로 프록시 사용
            * POJO는 순수하게 도메인에 초점을 맞춤 -> 단순해서 테스트하고 유지보수하기 좋음
            * 프로그래머가 명시한 aspect를 프레임워크가 프록시/바이트코드 라이브러리로 구현
        + AspectJ 언어: 언어 차원에서 관점을 모듈화 구성으로 지원


## 테스트 주도 시스템 아키텍처 구축
- 최선의 시스템 구조는 각기 POJO 객체로 구현되는 `모듈화된 관심사 영역`(domain)으로 구성된다.
- 아키텍처의 관심사 - 엔터프라이즈 관심사 분리: TDD 가능, 모든 것을 처음부터 설계하지 않아도 됨


## 의사 결정을 최적화하라
- 모듈을 나누고 관심사를 분리하면 지엽적인 관리와 결정이 가능해진다.
- 가장 적합한 곳에 책임을 두기 위해 가능한 만큼 미루는 방법이 최선이다.


## 명백한 가치가 있을 때 표준을 현명하게 사용하라
- 장점
    * 아이디어와 컴포넌트 재사용 용이
    * 경험을 가진 사람을 구하기 쉬움
    * 좋은 아이디어를 캡슐화하기 쉬움
    * 컴포넌트를 엮기 쉬움
- 단점
    * 표준을 만드는 시간이 오래 걸려서 기다리지 못함
    * 과장되게 집착하여 원래의 목적을 상실


## 시스템은 도메인 특화 언어가 필요하다
- DSL: 간단한 스크립트나 표준 언어로 구현한 API
- 장점
    * 좋은 DSL은 도메인 개념과 개념을 구현한 코드 사이의 의사소통 간극을 줄인다.
    * 추상화 수준을 관용구/디자인패턴 이상으로 끌어올림
    * 고차원 정책 ~ 저차원 세부사항까지 모든 추상화 수준과 모든 도메인을 POJO로 표현 가능