# 동시성
- 객체는 처리의 추상화다. 스레드는 `일정의 추상화`다.
- 깔끔하게 다중 스레드 코드를 잘 짜는 것은 어렵다


## 여러 스레드를 동시에 돌리는 이유
- 동시성? 
    * 결합coupling을 없애는 전략
    * what, when을 분리하는 전략
        + 분리하면 구조&효율이 아주 나아짐. 시스템이 거대한 루프가 아니라 작은 협력 프로그램 여럿으로 보임. 그래서 이해가 쉽고, 문제 분리도 쉬움.
        + 참고) 스레드가 하나인 경우, what과 when이 밀접해서 디버깅할 때 breakpoint를 사용함.
- 왜 결합을 없애는 것이 좋은가?
    * 구조적 개선 ex. Servlet - 부분적인 동시성 관리, 요청 시 비동기 실행
    * 응답 시간, 작업 처리량 개선 ex. 웹 정보 수집기, 사용자가 많은 시스템
- 꼭 이런 것은 아니다
    * 항상 성능을 높인다                          (-> 특정한 경우 성능 향상)
    * 동시성을 구현해도 설계는 변하지 않는다           (-> 단일 스레드 시스템과 다중 스레드 시스템의 설계는 아주 다르다)
    * 컨테이너를 사용하면 동시성을 이해하지 않아도 된다   (-> 컨테이너 동작 원리, 동시 수정과 데드락을 어떻게 피하는지 알아야 함)
- 다만 이렇다
    * 동시성은 다소 부하를 유발한다 (성능 부하 & 코드량 증가)
    * 동시성은 복잡하다. 간단한 문제라도.
    * 일반적으로 동시성 버그는 재현이 어려워서 일회성 문제로 여겨져 무시당하기 쉽다
    * 동시성을 구현하려면 근본적인 설계 전략을 재고해야 한다


## 난관: 여러 스레드를 동시에 돌리는 어려움
- 두 스레드가 같은 변수를 동시에 참조할 가능성
- 정확히 어디에서 잘못된 처리가 일어날지 확인하기 어려움
- 이유: 바이트 코드를 고려할 때 두 스레드가 어떤 메서드를 실행하는 잠재 경로가 1만 개가 넘을 수도 있음


## 동시성 방어 원칙: 어려움에 대처하고 깨끗한 코드를 작성하는 방법
1. 단일 책임 원칙
    - 동시성 코드를 다른 코드와 분리하라
    - 왜?
        * 동시성 그 자체만으로 복잡하니까
        * 독자적인 개발, 변경, 조율 주기가 있으니까
2. 데이터 범위를 제한하라
    1. 공유 객체를 사용하는 코드 내의 critical section을 `synchronized` 키워드로 보호하라
    - 왜?
        * 서로 다른 스레드가 각자에 간섭하여 예상치 못한 결과를 낼 수 있음
    2. 데이터를 캡슐화하라
    - 왜?
        * critical section과 공유 데이터를 최소화하기 위함
        * 유지보수하면서 빼먹을 수 있고, 확인하는 과정이 어렵고 복잡함
3. 데이터 사본을 사용하라
    - 객체를 복사해서 읽기 전용으로 사용하라
    - 왜? 
        * 공유 데이터를 줄이려면 처음부터 공유하지 않는 것이 제일 좋음
        * 카피 & 가비지 컬렉션 시간 < 내부 lock을 없애 절약한 수행 시간
4. 스레드는 가능한 독립적으로 구현하라
    - 독자적 스레드
    - 가능하면 다른 프로세서에서 돌려도 괜찮도록 독립적으로 데이터를 분리
    - 어떻게?
        * 다른 스레드와 데이터 공유 안 함
        * 1스레드 1리퀘스트
        * 비공유 출처 -> 로컬 변수에 데이터 저장 
5. 라이브러리를 이해하라
    - 언어가 제공하는 클래스 검토하기
        * `java.util.concurrent`
        * `java.util.concurrent.atomic`
        * `java.util.concurrent.locks`
    - 스레드 환경에서 안전한 컬렉션 (자바 5~)
6. 실행 모델을 이해하라
    - 기본 용어
        * 한정된 자원 (bound resource): 다중 스레드 환경에서 사용하는 자원. 크기나 숫자가 제한적. `ex. 데이터베이스 연결, 한정 길이 읽기/쓰기 버퍼`
        * 상호 배제 (mutual exclusion): 한 번에 한 스레드만 공유 자원을 쓸 수 있는 경우
        * 기아 (starvation): 한 스레드 이상이 아주 오래 자원을 기다림
        * 데드락 (deadlock): 여러 스레드가 서로가 끝나기를 기다리면서 진행이 안 됨
        * 라이브락 (livelock): 락을 거는 단계에서 각 스레드가 서로를 방해하여 진행이 안 됨
    - 생산자-소비자 (prducer-consumer)
        * 생산자 스레드가 대기열에 데이터를 넣고 신호를 보내면, 소비자 스레드가 데이터를 가져오면서 신호를 보냄 (대기열은 `한정된 자원`)
        * 단점: 서로가 서로의 신호를 기다릴 수 있음
    - 읽기-쓰기 (readers-writers)
        * 읽기 스레드를 메인으로 공유 자원을 사용하지만, 쓰기 스레드가 가끔 갱신함
        * 처리율을 적절하게 만족하면서 기아를 방지하는 방법이 필요
        * 단점
            + 처리량을 강조하면 `기아` 현상이 발생/오래된 정보가 쌓임
            + 갱신을 허용하면 처리량에 영향이 감 
    - 식사하는 철학자들 (dining philosophers)
7. 동기화하는 메서드 사이에 존재하는 의존성을 이해하라
    - 공유 객체 하나에는 메서드 하나만 사용하는 게 좋다. 공유 클래스 하나에 synchronized 메서드가 여럿이면 구현이 올바른지 점검하라.
    - 여러 메서드가 필요할 땐?
        * 클라이언트에서 잠금
            + 클 > 서: 서버 잠금 메서드 -> 첫번째 메서드 -> ... -> 마지막 메서드 
        * 서버에서 잠금
            + 클 > 서: 서버를 잠그고 모든 메서드를 호출한 후 잠금을 해제하는 메서드
        * 연결 서버
8. 동기화하는 부분을 작게 만들어라
    - critical section 수를 최소화하라.
    - 왜? 
        * synchronized 키워드는 락을 설정하는데, 락은 스레드를 지연시키고 부하를 가중한다
        * 최소화지, 하나만 하라는 게 아니다. critical section의 영역이 너무 커지면 스레드 간 경쟁이 늘고, 성능 저하.
9. 올바른 종료 코드는 구현하기 어렵다
    - 개발 초기부터 어떻게 종료할지 고민하라
    - 가장 흔한 문제, `데드락`


## 동시성을 테스트하는 방법과 문제점
> 문제를 노출하는 테스트 케이스 작성하기, 시스템 설정과 부하, 프로그램 설정을 바꿔가며 테스트하기

1. 말이 안 되는 실패는 잠정적인 스레드 문제로 취급하라
    - 시스템 실패를 일회성으로 치부하지 말라
2. 다중 스레드를 고려하지 않은 순차 코드부터 제대로 돌게 하라
    - 스레드 환경이 아닌 일반 환경에서 제대로 도는지 확인 필수
    - 스레드 환경의 버그와 스레드 환경 밖의 버그를 같이 디버깅하지 마라
3. 다중 스레드를 쓰는 코드 부분을 다양한 환경에 쉽게 끼워 넣을 수 있게 스레드 코드를 구현하라
4. 다중 스레드를 쓰는 코드 부분을 상황에 맞게 조율할 수 있게 작성하라
    - 적절한 스레드 개수를 파악하기 위해 다양한 시행 착오 필요
5. 프로세서 수보다 많은 스레드를 돌려 보라
    - 왜? 시스템이 스레드를 스와핑 할 때도 문제 발생 가능, 일부러 스와핑 발생시켜 확인 위함
    - 스와핑이 잦으면 critical section을 빼먹거나 데드락을 일으키는 코드를 찾기 쉽다
6. 다른 플랫폼에서 돌려 보라
7. 코드에 보조 코드를 넣어 돌려라. 강제로 실패하게 하라.
    - 스레드 코드의 오류 탐지가 어려운 이유는 아주 가끔씩만 실패하기 때문이다 
    - 스레드를 매번 다른 순서로 실행해보기 위한 코드
    * 직접 구현하기
        + 코드에 직접 `wait()`, `sleep()`, `yield()`, `priority()`를 추가
        + 이 부분 때문에 실패했다면, 일단은 그 부분이 기존의 문제를 드러냈다고 여기는 것을 추천
        + 적절한 보조 코드 삽입 위치 / 적당한 함수 호출부 / 배포하지 않도록 주의 등
    * 자동화
        + 보조 코드를 랜덤하게 호출하는 함수 작성
        + ex. `ConTest`


## 정리
- 멀티 스레드 코드를 작성하는 것은 어렵다
- 동시성 방어 원칙을 준수하려고 노력한다
- 테스트를 해보면서 과부하 상황이나 뜬금 없는 오류에 대비한다