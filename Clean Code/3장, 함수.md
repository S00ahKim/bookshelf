# 함수
- 가장 기본적인 프로그램 단위


## 작게 만들기
- 실제 코드 길이가 짧은 것
- if/else, while 문 등 블록 안에 들어가는 코드가 짧은 것 (읽고 이해하기 좋음)


## 한 가지만 하기
- 함수는 한 가지만을 잘 해야 한다
- 의미 있는 이름을 가진 다른 함수를 더 이상 추출할 수 없는 상태
- 함수 당 추상화 수준을 하나로 두기 (전체 페이지 로드 > 렌더링 > 문자열 추가)
    * 코드를 위에서 아래로 읽을 수 있도록 하기 (추상화 수준이 아래로 갈수록 낮아짐)
    * 쉽지 않은 규칙


## switch 문
- 여러 개의 if/else를 포함해, switch를 작게 만드는 것은 어렵다
- 본질적으로 1개 이상의 작업을 하게 됨
- 완전히 없애기는 힘들지만, 반복하지 않는 방법은 다형성을 사용하는 것이다
- ex. case 별로 다르게 작업하는 코드 -> case 별로 다른 작업을 하는 메서드를 가진 클래스를 생성하는 코드
    * 작업을 분기하면 그 작업이 다루는 객체에 대해 또 다른 작업을 하려고 할 때, 그 또 다른 작업에 대한 분기문이 생긴다.
    * 위와 같은 이유로 필연적으로 코드를 변경할 이유가 많아지고, 하나의 함수 안에서 '작업'을 여러 개 하게 된다.


## 서술적인 이름을 사용하라
- 동사+목적어 조합의 서술적 이름은 함수가 하는 일을 더 잘 묘사한다
- 서술적으로 명명하면 개발자의 머릿속에서도 설계가 뚜렷해진다
- 모듈 내에서 함수 이름은 같은 문구, 명사, 동사를 사용하라. 일련의 함수 목록을 보고 이런 함수도 있을 것일지 짐작할 수 있으면 좋다.


## 함수 인수
- 인수 개수는 적을수록 좋고, 아예 없는 것이 최고
    * 인수와 함수 이름 간 추상화 수준이 다름
    * 함수를 읽는 이에게는 인수는 그리 중요하지 않음
    * 테스트하기 어려움. 인수 조합을 만드는 것이 어렵기 때문.
- 많이 쓰는 단항 형식
    * 인수에게 질문을 던지는 경우
    * 인수를 변환해 결과를 만드는 경우
    * (드물게) 이벤트: 입력 인수만 있고 출력 인수가 없는 경우
    * 위 경우들에 대해 **함수 이름을 다르게** 지어야 하고, 일관적 방법으로 사용해야 한다
- 플래그 인수
    * 함수로 부울 값을 넘기지 마라
    * 부울 값을 인수로 넘긴다는 것은 한번에 여러가지(플래그에 따라 참이면 ㅇㅇ, 거짓이면 ㅁㅁ)를 처리하는 것이기 때문
- 이항 함수
    * 이항 함수가 의미상 적절한 경우: 하나의 값을 표현하는 두 요소이거나, 자연적 순서 `ex.좌표`
    * 인수의 개수가 많아서 의미를 이해하기 위해 읽는이가 **주춤**하게 됨
    * 읽으면서 **무시**해야 하는 인수를 넘기는 것은 좋지 못함
    * 인위적으로 인수 넘기는 **순서**를 기억해야 하는 것은 주의를 필요로 함
- 삼항 함수
    * 이항 함수보다 주춤, 무시, 순서 문제가 더 많아짐
- 인수 객체
    * 인수가 2~3개라면 인수를 묶어서 객체로 만들자 `ex. double x, double y -> Point center`
    * 객체로 묶는 과정에서 이름을 붙이면서 개념을 표현하게 됨
- 인수 목록
    * 인수 개수가 가변적인 함수가 필요할 경우, 가변 인수 전부를 동등하게 List 형 인수 하나로 취급할 수 있음
    * ex. `public String format(String format, Object... args)`
    * 가변 인수를 취하는 함수는 단항/이항/삼항/... 함수가 될 수 있음
- 동사와 키워드
    * 함수의 의도, 인수의 의도 및 순서를 제대로 표현하려면 함수 이름이 중요함
    * 단항 함수의 경우 함수와 인수가 동사-명사 쌍을 이뤄야 함 ex. `writeField(name)`
    * 함수 이름에 인수 이름 넣기 ex. `assertExpectedEqualsActual(expected, actual)`


## 사이드 이펙트 피하기
- 함수에서 하나를 하겠다고 약속하고 다른 것까지 하는 것은 거짓말
    * 유저 이름과 비밀번호를 체크하면서 세션 초기화까지 하는 것은 사이드 이펙트
    * 의도치 않게 세션을 초기화할 수 있음 / 함수를 사용할 때 세션 초기화 가능성을 검토하는 것이 필요 etc...
- 출력 인수란?
    * `함수(인수)`에서 인수를 무언가에 함수한다면 입력 인수, 인수에 무언가를 함수한다면 출력 인수
    * 인수가 입력 인수인지 출력 인수인지 파악하기 위해 함수 선언부를 찾아보는 것도 일종의 **주춤**임
    * 객체 지향에서는 출력 인수를 사용할 필요가 없다. 출력 인수로 사용하라고 설계한 변수가 this. 즉, 인수에 무언가를 함수한다면, `인수.함수()`가 되는 것이 맞다.
    * 일반적으로 출력 인수는 피하는 것이 좋음. 상태를 변경하려면 함수가 속한 객체 상태를 바꾸자.


## 명령과 조회를 분리하라
- 함수의 역할: 뭔가 수행 or 뭔가 답함
- 둘 다 하면 안 된다!


## 오류 코드보다 예외를 사용하라
- 오류 코드를 리턴하는 경우
    * 오류 코드에 대한 제어를 else 문으로 해야 하는데, if{if{} else{}}else{} 처럼 복잡해질 수 있음
    * 오류 코드가 있다 = 어딘가에서 오류 코드를 정의했다 = 정의한 곳에 의존성을 가진다 = 수정이 어렵다
- 예외를 throw하는 경우
    * catch에서 경우별 Exception에 대한 처리를 하면서 로직과 분리할 수 있음
    * try-catch 블록 뽑아내기
        + try/catch를 사용하는 것은 혼란스러울 수 있으므로, 별도 함수로 뽑는 것이 좋음
        + 오류 처리 역시 한 가지 작업이고, 함수는 한 가지 작업만 하니까
        + `try{ㄱ ㄴ ㄷ}catch{오류처리}` 를 하기보다, `ㄱ ㄴ ㄷ` 와 `function ㄱ {try{} catch{오류처리}}` 와 `function 오류처리 {}` 를 만드는 게 좋음
    * Spring: [@ExceptionHandler](https://www.baeldung.com/exception-handling-for-rest-with-spring) / exception throw -> global 처리


## 반복하지 마라
- 완전히 똑같지 않고 조금씩 변형되었더라도, 알고리즘이 대부분 중복되는 것은 중복이다
- 코드 길이가 늘어남 & 로직 수정이 어려움 (손볼 곳이 많으므로)
- 중복을 회피/제어하기 위한 많은 기법들: RDB 정규화, 객체지향의 상속, AOP, COP, 구조적 프로그래밍 등
    * 구조적 프로그래밍?
        + 모든 함수와 함수 내 모든 블록은 입구와 출구가 하나만 존재해야 한다 (=return 한 개)
        + 루프 안에서 break, continue 사용 X, goto 금지
        + 작은 함수에서는 큰 이익이 없음 (작을 경우 어느 정도의 break, continue, 다중 return은 오히려 가독성을 좋게 함)


## 함수 짜기
1. 초안 작성: 일단 길고 복잡하고, 구조도 별로고, 중복된 루프도 넣는 등 좋지 않은 상태의 코드를 만든다
2. 초안을 모두 테스트하는 테스트 코드 작성
3. 리팩토링: 다듬기, 이름 바꾸기, 중복 제거 등