# 복제
- 단순함을 유지할 것!!
- 소스-레플리카 구조로 스케일 아웃 지원
- 복제 대부분은 이전 버전과 호환

### 일반적인 사용 방법
- 데이터 분산: 지리적으로 떨어진 위치에 사본 저장
- 읽기 트래픽 확장
- 백업
- 분석/보고
- 고가용성 (SPOF 방지)
- mySQL 버전 업그레이드 테스트

### 복제 작동 방식
1. 소스가 데이터 변경 사항을 바이너리 로그에 이벤트로 기록
2. 레플리카는 소스의 바이너리 로그 이벤트를 자체 로컬 릴레이 로그에 복사
3. 레플리카는 릴레이 로그의 이벤트를 재생하여 자체 데이터에 변경 사항 적용

### 복제의 내부 동작
- 복제 형식 선택 (바이너리 로그에 어떻게 기록되는가)
    * 명령문 기반: 데이터를 변경한 쿼리를 기록
    * 행 기반: 행이 어떻게 변경되었는지 나타내는 이벤트를 기록
    * 혼합: 명령문을 기본값, 필요할 때 행 기반
- 전역 트랜잭션 식별자는 복제 위치를 추적함
- 복제 충돌에 대비하기 위한 설정값이 있음
- 일부러 지연된 레플리카를 만들기도 하지만 성능 이슈 및 여타 복잡한 문제가 있을 수 있음
- 최신 mySQL 버전은 멀티 스레드 복제를 적용함
- 데이터 무결성을 지키려면 반동기 복제를 지양하는 것이 좋음
- 복제 필터 기능으로 서버 데이터의 일부만 복제할 수 있음

### 복제 페일오버
- 승격: 모든 데이터가 있다고 확신하는 레플리카를 소스로 승격할 수 있음
- 복제 토폴로지
    * 액티브/패시브: 모든 읽기/쓰기를 단일 소스로 보내고 소수의 레플리카를 유지함. 복제 지연을 방지함.
    * 액티브/리드: 모든 쓰기를 단일 소스로 보냄. 읽기의 수평적 확장 가능.
    * 비권장: 액티브/액티브, 레플리카가 있는 이중 소스, 링 복제, 다중 소스 복제

### 복제 관리 및 유지
- 모니터링: 디스크 공간, 상태와 오류, 지연 여부 확인
- 복제 지연 측정
- 레플리카-소스 데이터 일치 여부 확인

### 복제 문제와 해법
- 소스의 바이너리 로그 손상: 레플리카 재구성
- 고유하지 않은 서버 ID: 레플리카 설정시 유의
- 정의되지 않은 서버 ID: 에러가 나므로 값을 설정할 것
- 임시 테이블 누락: 행 기반 복제 사용
- 모든 업데이트를 복제하지 않음
- 과도한 복제 지연: 약간의 지연을 허용하도록 애플리케이션 설계
- 소스의 오버사이즈 패킷: 오버사이즈의 패킷을 기록
- 디스크 공간 없음: 모니터링