**Table Of Contents**
- [쿼리 성능 최적화](#쿼리-성능-최적화)
  - [slow query](#slow-query)
    - [데이터 액세스를 최적화하기](#데이터-액세스를-최적화하기)
      - [주요 문제 상황 (1) 애플리케이션이 필요 이상으로 많은 데이터를 검색함 (행/열 모두)](#주요-문제-상황-1-애플리케이션이-필요-이상으로-많은-데이터를-검색함-행열-모두)
      - [주요 문제 상황 (2) 서버가 필요 이상으로 많은 행을 분석함](#주요-문제-상황-2-서버가-필요-이상으로-많은-행을-분석함)
  - [쿼리 재구성 방법들](#쿼리-재구성-방법들)
    - [복잡한 쿼리 1개 vs 간단한 쿼리 다수](#복잡한-쿼리-1개-vs-간단한-쿼리-다수)
    - [쿼리 자르기](#쿼리-자르기)
    - [조인 분해](#조인-분해)
  - [쿼리 실행 기본 사항](#쿼리-실행-기본-사항)
    - [쿼리 실행 단계](#쿼리-실행-단계)
    - [클라이언트/서버 프로토콜](#클라이언트서버-프로토콜)
    - [쿼리 상태](#쿼리-상태)
    - [쿼리 최적화 프로세스](#쿼리-최적화-프로세스)
      - [옵티마이저](#옵티마이저)
      - [테이블과 인덱스 통계](#테이블과-인덱스-통계)
      - [mySQL의 조인 실행 전략](#mysql의-조인-실행-전략)
      - [실행 계획](#실행-계획)
      - [조인 옵티마이저](#조인-옵티마이저)
      - [정렬 최적화](#정렬-최적화)
    - [쿼리 실행 엔진](#쿼리-실행-엔진)
    - [클라이언트에게 결과 반환](#클라이언트에게-결과-반환)
  - [mySQL 쿼리 옵티마이저의 한계](#mysql-쿼리-옵티마이저의-한계)
  - [특정 유형의 쿼리 최적화](#특정-유형의-쿼리-최적화)
    - [COUNT() 쿼리](#count-쿼리)
    - [조인 쿼리](#조인-쿼리)
    - [ROLLUP으로 GROUP BY 최적화](#rollup으로-group-by-최적화)
    - [LIMIT 및 OFFSET 최적화](#limit-및-offset-최적화)
    - [SQL\_CALC\_FOUND\_ROWS 최적화](#sql_calc_found_rows-최적화)
    - [UNION 최적화](#union-최적화)


# 쿼리 성능 최적화
- 쿼리 최적화, 인덱스 최적화, 스키마 최적화는 함께 이루어짐
- 최적화? 문제적 하위 작업 제거 / 문제 발생 횟수 줄이기 / 더 빠르게 수행하게 하기 등


## slow query
> 응답 시간은 중요하다
- 요청 처리 과정? 클라이언트 -> 서버 -> 구문 분석 -> 계획 -> 실행
- 쿼리가 소비하는 것들
    * 스토리지 엔진에 다수의 호출
    * 그룹화/정렬 등 검색 후 작업
    * 네트워크, CPU 및 통계, 계획, 잠금 등의 작업
    * 메모리 작업, CPU 작업, I/O 작업

### 데이터 액세스를 최적화하기
#### 주요 문제 상황 (1) 애플리케이션이 필요 이상으로 많은 데이터를 검색함 (행/열 모두)
- 왜 문제가 되나? 서버에 추가 작업 발생, 필요보다 많은 네트워크 오버헤드, 필요보다 많은 메모리/CPU 리소스 소비
- 필요 이상의 행을 가져옴 => `LIMIT`을 붙여라
- 조인하는 쿼리의 `SELECT`에 *을 씀 => 캐싱 등 특별한 이유가 없으면 필요한 칼럼만 명시하라
- 동일한 데이터를 반복적으로 가져옴 => 캐시하라

#### 주요 문제 상황 (2) 서버가 필요 이상으로 많은 행을 분석함
- 너무 많은 행을 분석하는 부분을 점검하라
- 쿼리 비용 메트릭들
    1. 응답 시간 (서비스 시간+대기열 시간)
        * 서비스 시간은 서버가 실제로 쿼리를 처리하는 데 걸리는 시간
        * 대기열 시간은 서비스 시간을 제외한 응답 시간의 일부 (ex. I/O 및 잠금 대기 등)
        * 적절한지 확인 필요: QUBE
    2. 검사된 행 수 / 반환된 행 수
        * 모든 데이터를 검색하는 대신, 인덱스로 접근하도록 적절한 인덱스 설정 필요
        * `EXPLAIN` 으로 대강 추정 가능
        * 스키마 변경: 요약 테이블 사용
        * 복잡한 쿼리를 옵티마이저가 최적으로 실행할 수 있게 재작성


## 쿼리 재구성 방법들
### 복잡한 쿼리 1개 vs 간단한 쿼리 다수
- 네트워크 비용, 최적화 오버헤드 등으로 전자를 전통적으로 선호했음
- 최신 네트워크와 mySQL의 좋은 설계는 후자를 나쁜 선택이 아니게 도움
- 그러나 연결 응답은 MySQL이 내부적으로 통과할 수 있는 행 수에 비해 여전히 느림

### 쿼리 자르기
- 같은 작업을 한방에 하는 게 아니라 청크 단위로 여러번 실행하는 것
- ex. `DELETE ALL` 보다 `DELETE LIMIT 1000` 을 n번 수행

### 조인 분해
- A랑 B를 조인해서 가져오는 쿼리보다 A를 가져오고 B를 가져와서 애플리케이션에서 조합
- 장점? 캐싱이 효율적, 잠금 경합 줄임, 데이터베이스의 확장이 쉬움, 효율적 쿼리, 불필요한 행 액세스 줄임


## 쿼리 실행 기본 사항
### 쿼리 실행 단계
1. 클라이언트가 SQL을 클라이언트/서버 프로토콜로 보냄
2. 서버는 파서로 SQL을 보냄
3. 파서는 전처리기로 SQL을 보냄
4. 전처리기는 쿼리 옵티마이저로 보내서 쿼리 실행 계획을 만듦
5. 쿼리 실행 엔진이 스토리지 엔진의 API를 호출함
6. 스토리지 엔진이 데이터에 접근함
7. 결과를 클라이언트에 보냄

### 클라이언트/서버 프로토콜
- 반이중: 서버는 한번에 메시지 송/수신 중 하나만 할 수 있음
- 클라는 쿼리를 단일 데이터 패킷으로 보냄
- 서버는 일반적으로 많은 데이터 패킷을 보냄. 이때 조금씩 나눠 받기가 불가능하고 받을 거면 다 받아야 함. 그래서 `LIMIT` 절이 중요.

### 쿼리 상태
- 가장 쉽게 보는 방법: `SHOW FULL PROCESSLIST`
- 쿼리가 어떤 상태에 있는지 알아볼 수 있음
- 상당한 시간이 소요되고 있는 것 같으면 뭔가 잘못된 것

### 쿼리 최적화 프로세스
#### 옵티마이저
- 항상 최상의 계획을 선택하지 않을 수 있음 (다양한 이유 있음)
- 최적화 유형
    * 정적 최적화: 구문 분석 트리를 검사하여 간단히 수행 (=컴파일 타임 최적화)
    * 동적 최적화: 컨텍스트를 기반으로 하며 WHERE 절에 있는 값 또는 인덱스에 있는 행 수와 같은 많은 용인에 따라 달라질 수 있음 (=런타임 최적화)
- 조인 재정렬: 최상의 조인 순서를 결정함
- 아우터 조인을 이너 조인으로 변경: 이너조인이랑 결과가 똑같으면 그렇게 변경
- 대수 등가 규칙 적용: 항상 맞는 말이 조건절에 있으면 생략하고, 복잡한 조건은 단순화함
- COUNT(), MIN(), MAX() 최적화: 테이블이 아니라 인덱스를 활용해서 응답
- 상수 표현식 및 평가 줄이기: 항상 같은 경우에 대해 상수 취급 (행이 1개인 조인 대상 테이블 등)
- 커버링 인덱스: 인덱스가 쿼리에 필요한 모든 열을 가지고 있을 때 인덱스를 사용함
- 서브쿼리 최적화
- 조기 종료: 완료되는 즉시 실행을 중지함
- 등식 전파: 같은 조건절을 조인 테이블에도 적용함
- IN() 목록 비교: IN 안의 목록 값을 정렬해서 바이너리 서치를 함 (`O(n)`->`O(logn)`)

#### 테이블과 인덱스 통계
- 서버 계층은 인덱스에 대한 통계를 저장하지 않음
- 통계는 스토리지 엔진에 요청해야 함
- 통계값(카디널리티, 행/키의 길이 등)으로 옵티마이저는 최적의 실행 계획을 세움

#### mySQL의 조인 실행 전략
- mySQL은 다양한 종류의 쿼리를 조인으로 간주함
- 중첩 루프 조인 -> 해시 조인

#### 실행 계획
- 명령 트리는 대개 left-deep tree 형태
- 하나의 테이블로 시작해서 다음 테이블에서 일치하는 행을 찾는 방식
- 재구성된 쿼리 보기: `EXPLAIN EXTENDED` -> `SHOW WARNINGS`

#### 조인 옵티마이저
- 가장 중요함!!
- 최적의 계획을 갖고 SQL을 쓰는 것도 좋음
- 하지만 조인 옵티마이저가 인간보다 대개 더 낫기 때문에 일단 맡겨두자

#### 정렬 최적화
- 결과를 정렬하는 것은 대개 비용이 많이 드는 작업
- 정렬을 피하거나 더 적은 수의 행에서 수행하여 성능을 향상 도모

### 쿼리 실행 엔진
- 구문 분석 및 최적화 단계는 MySQL의 쿼리 실행 엔진이 쿼리를 처리하는 데 사용하는 쿼리 실행 플랜을 출력함
- 계획에 포함된 많은 작업은 핸들러 API 라고도 하는 스토리지 엔진 인터페이스에 의해 구현된 메서드를 호출함

### 클라이언트에게 결과 반환
- 서버는 결과를 점진적으로 생성하고 발송
- 개별 프로토콜 패킷들은 버퍼링되어 TCP 프로토콜 계층에서 함께 전송


## mySQL 쿼리 옵티마이저의 한계
- 일반적 경우에는 최적화 가능하지만 일부 한계 존재
1. UNION 제한 사항
    * UNION 밖의 조건은 UNION 안에 적용되지 않는다
    * 따라서 `(가) UNION (나) LIMIT 10`의 리밋 조건을 (가), (나)에 적용하고 싶으면 그 안에 써줘야 한다
2. 동등 전파
3. 병렬 실행
    * 여러 CPU에서 단일 쿼리를 병렬로 실행할 수 없음
4. 동일한 테이블에 대한 SELECT와 UPDATE
    * 테이블에서 `UPDATE`를 실행하는 동안 같은 테이블에서의 `SELECT`를 허용하지 않음


## 특정 유형의 쿼리 최적화
### COUNT() 쿼리
- COUNT()는 값 또는 행을 센다.
- 값을 세는 경우에는 NULL은 제외하고 값이 있는 케이스만 세줌
- *이 들어가 행을 세는 경우에는 결과 행의 수를 알려줌
- 단순히 대략적인 양이 얼마나 되나를 알고 싶으면 실제 쿼리를 날리기보다 EXPLAIN으로 확인하기
- 가능한 최적화 방법? 커버링 인덱스를 사용하거나, 캐시를 하거나, 애플리케이션 아키텍처를 변경

### 조인 쿼리
- ON 또는 USING 절의 열에 인덱스가 있는지 확인
- 인덱스를 추가할 때 조인 순서 고려하기
- GROUP BY 또는 ORDER BY가 하나의 테이블의 열만 참조하게 하여 인덱스를 사용하게 하기

### ROLLUP으로 GROUP BY 최적화
- `WITH ROLLUP` 절을 사용하여 결과 내에서 특별히 집계를 수행하도록 요청할 수 있음
- 더 좋은 방법은 해당 기능을 애플리케이션 코드로 옮기는 것

### LIMIT 및 OFFSET 최적화

### SQL_CALC_FOUND_ROWS 최적화
- 페이지 표시를 위해 LIMIT이 있는 쿼리에 SQL_CALC_FOUND_ROWS를 붙이면 총 몇개 행이 있는지를 알려줌
- 비용이 비싼 작업
- 추천하는 대안들
    * LIMIT n이라고 치면 n+1개 가져와서 n개만 보여주고 n+1이 있으면 다음 버튼 노출
    * 필요량보다 많이 가져와서 캐싱하고 그 뒤는 캐시에서 조회
    * EXPLAIN으로 대강 양을 추정

### UNION 최적화
- 중복행을 제거해야 하는 게 아니라면 UNION ALL을 권장
- 생략하면 값을 만들기 위한 임시 테이블에 고유 옵션을 추가하는 등 비용이 비쌈