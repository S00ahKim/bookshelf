# 안정 해시 설계
> - 수평적 규모 확장성을 달성하기 위해 **요청 또는 데이터를 서버에 균등하게 나눌 수 있게** 하는 데 사용.
> - 아마존 다이나모, 카산드라, 디스코드, 아카마이 등에서 사용

## 일반적인 해시
- 해시 함수를 사용해서 나머지 값으로 배치
- Good Case
    * 서버 풀의 크기가 고정되어 있을 때
    * 데이터 분포가 균등할 때
- Bad Case
    * 서버가 추가될 때
    * 기존 서버가 삭제될 때
    * => 대부분의 키가 재분배되어 대규모 캐시 미스 발생

## 안정 해시
1. 해시 공간의 처음과 끝을 연결하여 해시 링 생성
2. 서버를 해시 링에 배치
3. 링 위의 어느 지점에 해시 키 배치
4. 조회하려면 키의 위치로부터 시계 방향으로 링을 탐색해 가장 먼저 나오는 서버에서 조회
5. 서버가 추가되거나 제거되어도 링의 일부분만 재배치하면 됨

## 안정 해시의 장점
- 서버가 추가되거나 삭제될 때 재배치되는 키의 수가 최소화된다.
- 데이터가 보다 균등하게 분포 -> 수평적 규모 확장성 달성이 용이
- 특정 샤드에 지나치게 접근하는 핫스팟 키 문제를 줄인다

## 안정 해시의 문제점과 해결책
- 문제점
    * 파티션(인접한 서버 사이의 해시 공간)의 크기를 균등하게 유지하기 불가능
    * 키의 균등 분포를 달성하기 어렵다
- 해결책
    * 가상 노드 라고 특정 서버를 가리키는 노드를 해시 링에 배치함
    * 가상 노드의 개수를 늘리면 표준 편차가 작아져 데이터가 고르게 분포됨
    * 단, 가상 노드가 많아질수록 저장 공간도 많이 필요해져서 tradeoff가 필요

## 질문
- cf. 5줄로 된 구글의 CONSISTENT HASHING
    ```C++
    int32_t JumpConsistentHash(uint64_t key, int32_t num_buckets) {
        int64_t b = 1,   j = 0;
        while (j < num_buckets) {
                b = j;
                key = key * 2862933555777941757ULL + 1;
                j = (b + 1) * (double(1LL << 31) / double((key >> 33) + 1));
            }
            return b;
    }
    ```