# 처리율 제한 장치의 설계

## 처리율 제한 장치
- 클라이언트/서비스가 보내는 트래픽의 처리율을 제어하기 위한 장치
- http의 경우, 특정 기간 내에 전송되는 요청 횟수 제한 & 일정 임계치 넘으면 처리 블록
- 장점
    * DOS 공격에 의한 자원 고갈 방지
    * 비용 절감 (우선 순위가 높은 쪽에 자원을 더 할당, 과한 서버 증설 방지 등)
    * 서버 과부하 방지

## 설계 인터뷰 대응
1. 문제 이해 및 설계 범위 확정
    * 종류, 제한 기준, 규모, 기능 스펙 등을 질문
2. 개략적 설계안 제시 및 동의 구하기
    * 어디에 둘 것인가?
        + 정답은 없지만, 이 장치를 클라이언트에 두는 것은 안정적이지 못하다. 클라이언트 요청은 쉽게 위/변조할 수 있고, 구현을 통제하기 어렵기 때문.
        + 서버 측에 두거나, 미들웨어를 사용하는 것이 좋다.
        + 클라우드 마이크로서비스의 경우, 보통 API 게이트웨이라는 컴포넌트에 구현된다.
    * 처리율 제한 알고리즘
        + 토큰 버킷
            - `특정 시간`마다 `특정 크기`의 토큰이 지급됨. 모든 요청을 실제로 처리하려면 토큰이 필요함.
            - `값` 튜닝의 까다로움
        + 누출 버킷
            - `특정 시간`마다 큐(고정된 `크기`)에 쌓여 있는 요청을 처리한다.
            - 단시간에 많은 트래픽이 몰리면 오래된 요청 때문에 신규 요청이 거부됨 & `값` 튜닝의 까다로움
        + 고정 윈도 카운터
            - 시간 단위를 윈도로 나누어 한 윈도가 처리할 수 있는 최대 요청 처리량을 정한다.
            - 윈도의 경계 부근에 일시적으로 트래픽이 몰리면 더 많은 요청을 처리하게 됨
        + 이동 윈도 로그
            - 시간 크기의 윈도를 갖는 건 맞지만, 현재 시각 기준으로 계산한다. 처리량에 도달하지 않았을 경우 요청을 보내고, 도달했을 경우 로그만 남기고 보내지 않는다.
            - 어느 순간의 윈도를 보더라도 허용되는 요청 수는 처리율 한도를 넘지 않음
        + 이동 윈도 카운터
            - 고정+이동
    * 개략적인 아키텍처
        + 추적 대상? 사용자 / API 엔드포인트 / IP주소 / 서비스 단위 등
        + 위 추적 대상에 대한 카운터 두기
        + 카운터의 보관? 메모리가 좋다. 빠르고 시간 기반 만료 정책을 지원하므로. redis 등.
3. 상세 설계
    * 처리율 제한 규칙은 어떻게 만들어지고 어디에 저장되는가? 보통 설정 파일 형태로 디스크에 저장됨
    * 처리가 제한된 요청들은 어떻게 처리되는가? 429 too many requests 응답을 보냄 + 헤더에 관련 정보 세팅
    * 분산 환경에서의 처리율 제한 기법은?
        + 경쟁 조건 문제? 락 / 루아 스크립트 / 정렬 집합 자료구조
        + 동기화 문제? 레디스 같은 중앙 집중형 데이터 저장소
    * 성능 최적화 방안? 세계 곳곳에 엣지 서버 두기, 동기화할 때 최종 일관성 모델 사용
    * 모니터링은 왜? 알고리즘이 효과적인지, 처리율 제한 정도가 효과적인지 확인
4. 마무리
    * 경성/연성 처리율 제한 (요청 개수가 잠시라도 임계치를 넘어설 수 있는지)
    * 다양한 계층에서의 처리율 제한 (앞의 예시는 7계층 / IP의 경우 3계층에서 처리 가능)
    * 처리율 제한을 회피하기 위한 클라이언트 설계 (클라이언트 캐시/임계치 자체 설정/우아한 에러로부터의 복구/재시도 시 백오프 시간 두기 등)


## 질문
- 레디스의 '정렬 집합' 자료구조란? 
    * 정렬 집합이란 score:value 형태로, value는 unique해야 하고, score로 정렬한다. 같은 score에서는 순서를 보장하지 않는다. 그러니까 시간:요청 으로 기록하지 않을까?
    * 원문에 따르면 atomic한 처리를 레디스가 지원해서 여러 요청을 아토믹하게 잡아서 동시성을 보장 & 그리고 그 안에서 제한을 하는 식으로, 2번의 호출은 필요한 방식으로 구현했다고 한다.
- 연성 처리율 제한은 언제 사용하면 좋을까?
    * A soft rate limit allows the call to complete but logs a warning message. 라는 IBM 문서가 있는데, 완전 처리율 제한이 필요한 것까진 아니지만 워닝 로그는 필요할 경우?
- 같은 서비스끼리도 처리율 제한이 필요?
    * 비슷한 맥락으로 서킷 브레이커를 사용한다