# 채팅 시스템 설계

## 채팅 시스템
- 이미 많은 기존 서비스가 있는 만큼, 사람들이 떠올리는 것도 제각각
- 기능 요구 사항을 확실히 할 것 (1:1? 그룹? 인원 제한? 중요 기능?)
- 기본 기능
    * 클라이언트로부터 메시지 수신
    * 메시지 수신자 결정 및 전달
    * 수신자가 접속 상태가 아니면 접속할 때까지 메시지 보관

## 설계
### 주요 통신 프로토콜: 웹소켓
- 송신할 때 클라이언트가 연결을 만드는 HTTP는 나쁘지 않은 선택.
    * `keep-alive` 헤더 사용해서 접속하면 연결을 유지 & TCP단의 핸드셰이크 횟수 줄일 수 있음
- 그러나 수신할 때에는 서버가 연결을 만드는 것처럼 해야 한다.
    * 폴링
      + 클라이언트가 주기적으로 서버에게 새 메시지가 있는지 묻는 방법
      + 리소스가 낭비될 여지 있음
    * 롱 폴링
      + 메시지가 새로 오거나 타임아웃 전까지는 연결을 유지하는 방법
      + 송신자와 수신자가 다른 서버에 있을 가능성: 메시지를 받은 서버가 수신자와 롱 폴링 상태가 아닐 수 있음
      + 클라이언트가 연결을 계속 하고 있는지 알 수 없음
      + 여전히 비효율적
    * 웹소켓
      + 항구적이며 양방향인 연결
      + 서버 -> 클라이언트로 비동기 메시지를 보낼 때 가장 많이 쓰임
      + 클라이언트가 HTTP 연결을 맺으면, 특정 핸드셰이크 절차 이후 웹소켓 연결로 업그레이드됨

### 구성
1. 무상태 서비스
    * 로그인, 회원가입, 사용자 프로필 표시 등
    * 앞단에 로드밸런서가 있어 특정 요청을 특정 서버로 전달함
    * 특이사항
        + **서비스 탐색 서비스**
            - 클라이언트가 접속할 채팅 서버의 DNS 호스트명을 클라이언트에게 알려줌
            - 기준: 클라이언트의 지리적 위치, 서버 용량
            - 구현: by 아파치 주키퍼
        + **접속 상태 서버**
            - 사용자의 접속 여부 관리
            - 실시간 서비스의 일부
            - 로그인/로그아웃/접속 장애 시 상태가 변경될 수 있음
            - 접속 장애의 관리는 heartbeat를 관측하는 식으로 관리
            - pub-sub 방식으로 친구들에게 알릴 수 있음
            - 대규모 그룹 채팅의 경우에는 채팅방 입장 시에만 확인하게 하거나, 수동으로 갱신하게 하기
    * 저장소
        + RDB
        + 사용자 프로필, 설정, 친구 목록
        + 안정성을 보장
2. 상태 유지(stateful) 서비스
    * 채팅 (클라이언트가 채팅 서버와 독립적인 네트워크 연결을 유지해야 함)
    * 서비스 탐색 서비스는 채팅 서비스와 협력하여 과부하를 방지함
    * 저장소
        + 키-값 저장소
        + 채팅 이력 (데이터량이 엄청남, 최근에 주고받은 메시지에 대한 hit율이 높음, 읽기:쓰기=1:1, 무작위 데이터 접근)
        + 수평적 규모 확장에 용이, 낮은 latency, 무작위 접근에 대한 비용이 비교적 낮음
        + ex) 페이스북(HBase), 디스코드(카산드라)
3. 제 3자 서비스 연동
    * 푸시 (앱이 실행 중이 아니더라도 알림을 받아야 함)
    * 규모 확장성? 서버 한 대로 처리하면 SPOF 문제가 가능하므로, 다중 서버 필요

## 밑줄
- 채팅 수신인이 접속 중인 경우 메시지는 수신인이 접속 중인 채팅 서비스로 전송됨. 수신인이 접속 중이 아니면 푸시 알림 메시지를 푸시 알림 서버로 보냄 (p.213)
- 여러 단말 사이의 메시지 동기화: 전화기와 랩톱의 두 대 단말 각각에 대해 웹소켓 연결이 만들어지고, 각 연결에서 마지막으로 읽은 메시지 id를 추적한다. (p.214)

## 질문
- 관계형 데이터베이스가 잘 처리하지 못한다는 롱 테일이 의미하는 것?