# 키-값 저장소 설계
- 비관계형 DB
- 고유 식별자를 키로 가짐 (짧을수록 좋음)
- ex. 아마존 다이나모, memcached, 레디스 등

## 단일 서버 키-값 저장소
- 간단한 해결책: 모든 값을 메모리에 해시 테이블로 저장
- 하지만: 모든 데이터를 두기 불가능할 수 있음
- 개선책: 데이터 압축 / 자주 쓰는 것만 메모리, 나머지는 디스크
- 하지만 언젠가 부족할 때가 온다..

## 분산 키-값 저장소
#### 분산 시스템 설계의 기본 개념: CAP 구조
- C (일관성) : 모든 노드에서 같은 데이터
- A (가용성) : 어떤 노드가 죽어도 응답은 받음
- P (파티션 감내) : 통신 장애가 있어도 응답은 받음
- 셋을 한번에 만족시킬 순 없고, 통신 장애는 반드시 발생하므로, CP/AP 구조가 가능
- 요구사항에 따라 어떤 구조를 선택할지 정하면 된다
    * 예를 들면, 온라인 뱅킹 시스템은 CP 구조일 경우 문제가 됨

#### 시스템 컴포넌트
- 데이터 파티션: 안정 해시
    * 안정 해시를 사용하는 이유
        + 데이터를 여러 서버에 고르게 분산할 수 있는가?
        + 노드가 추가되거나 삭제될 때 데이터의 이동을 최소화할 수 있는가?
    * 장점
        + 규모 확장 자동화
        + 다양성 (가상 노드 수 조정)
- 데이터 다중화
    * 해시 링을 순회하면서 만나는 첫 N개 서버에 데이터 사본을 보관
    * 같은 물리 서버를 선택하면 데이터센터 이슈에 같이 영향받을 수 있음
- 일관성
    * 읽기/쓰기 연산 일관성을 보장하기 위해 성공으로 간주할 수 있을 만큼의 성공 응답 수를 정한다 (=정족수)
    * 정족수를 정하는 것은 응답 지연과 데이터 일관성 사이의 타협점을 찾는 것이다
    * 일관성 모델: 일관성 수준을 결정함
- 일관성 불일치 해소
    * 데이터 버저닝 & 벡터 시계
    * 버저닝 = 변경할 때마다 새로운 버전을 생성함 & 각 버전은 immutable
    * 벡터 시계
        + (서버, 버전) 쌍을 저장해서 비교하며, 충돌 시 해소한다. 
        + 일부 구성요소가 값이 작다 = 충돌 / 모두 작다 = 이전 버전
- 장애 처리
    * 장애 감지: 주기적으로 heartbeat를 갱신하게 하고, 일정 주기 동안 갱신이 없으면 장애로 취급
    * 일시적 장애 처리: 일관성 모델에 따라 방법이 다름 (아예 연산 금지 / 장애 서버 무시)
    * 영구적 장애 처리: 머클 트리 (루트 노드부터 해시값을 비교 -> 아래로 내려가면서 동기화)
    * 데이터 센터의 장애는 다중화가 중요
- 시스템 아키텍처 다이어그램
    * 클라이언트는 API로 서버와 통신
    * coordinator는 클라이언트와 서버 간 프록시 역할을 하는 노드
    * 노드는 안정 해시의 해시 링 위에 분포
    * 노드를 자동으로 추가/삭제 가능하도록 완전히 분산됨
    * 데이터는 여러 노드에 다중화됨
    * 모든 노드는 기능 모두를 지원하여 같은 책임을 지므로 SPOF는 없음
- 쓰기 경로
    * 메모리 캐시에 기록 -> 넘치면 디스크의 SSTable에 기록 시작
- 읽기 경로
    * 메모리에서 일단 읽음 -> 블룸 필터로 SSTable 어디에 있는지 검색

## 질문
- 많이 쓰이는 키-값 저장소간의 차이는 뭘까?