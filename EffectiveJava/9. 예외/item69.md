# 예외는 진짜 예외 상황에만 사용하라

## 일상적인 제어 흐름으로 쓰지 마라
```java
// 표준관용구 이용 작성
for (Mountain m : range)
	m.climb();

// Exception 잘못된 사용 예
// 무한루프를 돌다가 배열의 끝에 도달해 예외가 발생하면 끝을 내는 로직
try {    
	int i = 0;
  while(true)
    	range[i++].climb();
} catch (ArrayIndexOutOfBoundsException e) {
}
```
- 예외는 예외 상황에 쓸 용도로 설계됨. 여타 최적화 고려 안되어 있음 (표준 관용구는 JVM 이 알아서 최적화함)
    * 저 이상한 코드를 짠 이유: 표준 관용구는 JVM이 경계를 넘는지 확인하니까 while에서도 검사하면 중복 검사겠지? 라고 생각해서
    * 과하게 머리를 쓰는 기법은 자제하라. 실제로 성능이 개선되더라도 자바 플랫폼이 꾸준히 개선되므로 상대적 성능 우위가 오래 가지 않을 수 있다.
- 예외를 제어용으로 쓰려고 코드를 try-catch 블록 안에 넣으면 JVM이 적용할 수 있는 최적화가 제한됨
- 예외를 사용한 쪽이 표준 관용구보다 훨씬 느림. 위 코드 기준 2배 가량
- 만약 제어 목적의 예외가 아니라 진짜 버그로 발생한 예외가 생기면 catch에 걸려 디버깅이 어려워짐

## API 설계 시에도 고려할 것
### 상태 검사 메서드
```java
for (Iterator<Foo> i = collection.iterator(); i.hasNext(); ) {
    Foo foo = i.next();
    ...
}
```
- next: 특정 상태에서만 호출할 수 있는 '상태 의존적' 메서드
- hasNext: 상태 검사 메서드 (상태의존적 메서드와 함께 제공됨)
    * 없었으면 클라이언트가 예외 체크 해가면서 순회해야 함

### 상태 검사 메서드 대신 사용할 수 있는 선택지
> Optional 또는 특정한 값
- 외부 동기화 없이 여러 스레드가 동시에 접근할 수 있는 경우
- 외부 요인으로 상태가 변할 수 있는 경우
- 성능이 중요한 상황에서 상태 검사 메서드가 상태 의존적 메서드의 작업 일부를 중복 수행하는 경우
- **다른 모든 경우엔 상태 검사 메서드 방식이 조금 더 낫다**
    * 가독성 좋음
    * 버그 발견이 쉬움 (특히 특정 값을 사용하는 방식과 비교해서)