# 복구할 수 있는 상황에는 검사 예외를, 프로그래밍 오류에는 런타임 예외를 사용하라

## 예외의 종류
> 예외는 throwable 타입
1. 검사 예외 (Checked Exception) 예외 처리를 강제
2. 비검사 예외 (Unchecked Exception) 예외 처리를 강제하지 않음
    * 런타임 예외 (Runtime Exception)
    * 에러 (Error)

## 예외별 사용 지침
### 1. 검사 예외
- 호출하는 쪽에서 복구하리라 여겨지는 상황에 사용
    * 호출자가 catch로 잡아 처리 / 더 바깥으로 전파하도록 강제
    * 복구할 수도 있으므로 복구에 도움이 되는 여러 메서드들을 제공해주면 좋음 (item75)
        + ex. 통장 잔고가 부족하다면, 얼마가 부족한지 알려줌
    * 메서드 선언에 포함된 검사 예외 각각은 해당 메서드를 호출했을 때 발생할 수 있는 결과이므로 API 사용자에게 회복하라고 요구하는 것

### 2. 비검사 예외
- 비검사 throwable(런타임 예외, 에러)의 공통점
    * 프로그램에서 잡을 필요가 없거나 혹은 통상적으로 잡지 말아야 한다.
    * 프로그램에서 해당 예외를 던졌다는 것은 복구가 불가능하거나 더 실행해봐야 득보다는 실이 많다는 뜻
    * 만약, 비검사 예외를 잡지 않은 스레드는 오류 메시지를 내뱉으며 중단됨
- 런타임 에러
    * 프로그래밍 오류를 나타낼 때
        + ex. 클라이언트가 해당 API의 명세에 기록된 제약을 지키지 못했을 때 ex. ArrayIndexOutOfBoundsException


## 복구할 수 있는 상황인지 프로그래밍 오류인지 명확히 구분되지 않는다?
- ex. 자원 고갈
    * [복구가능] 일시적인 자원 부족 / 순간적으로 수요가 몰림
    * [복구불가능] 말도 안 되는 크기의 배열을 할당함
- 복구 가능 여부는 API 설계자의 판단에 달림
    * [복구가능] 검사 예외
    * [복구불가능] 비검사 예외
    * 확신하기 어렵다면, 비검사 예외를 던지는게 나을 것 (item71)


## 에러를 사용하는 상황
- 보통 JVM이 자원 부족 등 더 이상 수행을 할 수 없는 상황을 나타낸다. 
- Error 클래스를 상속해 하위 클래스를 만드는 일은 자제하자
- 우리가 구현하는 비검사 예외는 모두 RuntimeException의 하위 클래스여야 한다. (AssertionError 제외)