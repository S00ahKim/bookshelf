# 생성자 대신 정적 팩터리 메서드를 고려하라
> 무조건 생성자를 쓰지 말라는 게 아니라, 장점이 있으니 필요한 경우에는 정적 팩터리 메서드를 사용하는 것이 좋다.

## 생성자, 정적 팩터리 메서드
- 생성자
    * 인스턴스를 얻는 전통적인 수단 (ex. `new Animal()`)
- 정적 팩터리 메서드
    * 인스턴스를 얻을 수 있는 메서드 (ex. `Animal.fish()`)

## 정적 팩터리 메서드의 장점
1. 이름을 가질 수 있다
    * `Animal salmon = new Animal(100);` 보다 `Animal salmon = Animal.fish(100)` 이 이 객체는 `물고기`라는 특성을 갖는 `동물` 객체임을 알기 쉽게 함
    * 같은 시그니처를 갖는 생성 메서드를 만들 수 있음 (ex. `Animal.fish(int kg)`, `Animal.bird(int kg)`)
2. 인스턴스를 통제할 수 있다
    * 호출될 때마다 인스턴스를 새로 생성하지 않아도 된다. 예를 들어 불변 클래스에서 인스턴스를 `미리` 만들어 두거나 생성한 인스턴스를 `캐싱`하여 재활용 가능하다. (ex. `Boolean.valueOf()`) 그러면 자주 호출되는 경우 시간/공간 비용을 아낄 수 있다.
    * 필요할 경우 `싱글턴`이나 `인스턴스화 불가`하게 만들 수 있다.
3. 리턴 타입의 하위 타입 객체를 반환할 수 있다
    * 무조건 해당 클래스를 리턴해야 하는 생성자보다 좀 더 유연하다
        + ex. `public Animal getAnimalByLocation(Location location)`을 외부에 공개해야 할 때, 구체적으로 어떤 Animal이 있는지 공개할 필요가 없음
        + ex. Collections 라이브러리는 구현체를 Collections의 정적 팩터리 메서드를 통해 얻도록 한다.
            - `Collections.emptyList()` 불변 빈 리스트. 내부에서는 EmptyList 구현체를 리턴. 
            - `Collections.unmodifiableList(list)` 변경할 수 없는 리스트를 리턴함. 내부에서는 UnmodifiableList 구현체를 리턴.
    * 자바 8부터 인터페이스가 정적 메서드를 가질 수 있게 되어 정적 팩터리 메서드의 사용처에서 구현이 아닌 인터페이스로 다루기 쉽게 되었다.
4. 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다
    * ex. EnumSet의 정적 팩터리 메서드는 원소의 수가 64개 이하면 long 변수 하나로 관리하는 RegularEnumSet의 인스턴스를, 65개 이상이면 long 배열로 관리하는 JumboEnumSet의 인스턴스를 리턴
5. 정적 팩터리 메서드를 작성하는 시점에는 리턴할 객체의 클래스가 없어도 된다
    * 서비스 제공자 프레임워크를 만드는 근간이 됨

## 정적 팩터리 메서드의 단점
1. 정적 팩터리 메서드만 제공할 경우, 하위 클래스를 만들 수 없다
    * 상속하려면 public / protected 생성자가 필요하기 때문
    * 상속보다 컴포지션을 사용(item18)하고 불변타입(item17)을 만들게 한다는 점에서 장점일 수 있음
2. 정적 팩터리 메서드는 프로그래머가 찾기 어렵다
    * API 문서를 잘 쓰고, 이름도 범용적으로 짓는 식으로 보완할 것
    * 범용적 이름의 예
        + `from`: 매개변수를 하나 받아서 해당 타입의 인스턴스를 반환
        + `of`: 여러 매개변수를 받아서 적절한 타입의 인스턴스를 반환
        + `valueOf`: from과 of의 좀 더 자세한 버전
        + `instance`, `getInstance`: 매개변수에 명시한 인스턴스를 반환 (같은 인스턴스임을 보장 안함)
        + `create`, `newInstance`: 매개변수에 명시한 인스턴스를 반환 (항상 새로운 인스턴스임을 보장)
        + `getType`: (=getInstance) 단, 다른 클래스에 팩터리 메서드가 있음 (ex. Files.getFileStore)
        + `newType`: (=newInstance) 단, 다른 클래스에 팩터리 메서드가 있음 (ex. Files.newBufferedReader)
        + `type`: getType, newType의 간단한 버전 (ex. Collections.list)

## 더 알아보기
- 박싱 클래스
    * boxed class, a.k.a. wrapper class
    * 기본 자료형을 인스턴스로 만들기 위해 사용하는 클래스
    * 기본 자료형을 사용하기 어렵거나 (제네릭 등) 내부 메소드를 활용하고자 하는 등의 이유로 사용
- 시그니처
    * 메소드 이름, 파라미터의 순서/타입/갯수
- 서비스 제공자 프레임워크
    * ex. JDBC, 브릿지 패턴, 의존 객체 주입 프레임워크 등
    * 애플리케이션에서 구현체를 명시적으로 참조하지 않고도 런타임 시에 구현체를 동적으로 찾아 사용할 수 있게 도와줌
    * 핵심요소1. `서비스 인터페이스`: 구현체의 동작 정의 (ex. Connection)
    * 핵심요소2. `제공자 등록 API`: 제공자가 구현체를 등록할 때 사용 (ex. DriverManager.registerDriver)
    * 핵심요소3. **`서비스 접근 API`**: 정적 팩터리 메서드가 사용되는 곳! 클라이언트가 서비스의 인스턴스를 얻을 때 사용. 원하는 구현체의 조건을 명시할 수 있음. (ex. Driver.getConnection)
    * 컴포넌트4. `서비스 제공자 인터페이스`: 서비스 인터페이스의 인스턴스를 생성하는 팩터리 객체 (ex. Driver)
        + 구현체를 사용처에 제공하는 역할을 프레임워크가 통제하여 사용처와 구현체를 분리함
    * 자바6부터 java.util.ServiceLoader 클래스를 사용하여 프레임워크를 직접 만들 필요는 거의 없어졌지만, JDBC는 자바6 전에 등장하여 이를 사용하지 않음.