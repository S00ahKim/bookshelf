# 불필요한 객체 생성을 피하라

## 똑같은 기능의 객체를 매번 생성하지 말고 재사용하자
- 불변 객체(item17)는 언제든 재사용할 수 있다.
- 파라미터로 문자열을 넘기는 String 을 새로 생성하기보다 문자열 리터럴을 사용하자. (이후 같은 가상 머신 안에서 이와 똑같은 문자열 리터럴을 사용하는 모든 코드가 같은 객체를 재사용함을 보장함)
- 정적 팩터리 메서드를 활용하자. ex. `Boolean.valueOf("false")`


## 생성 비용이 아주 비싼 객체는 캐싱해서 재사용하자
```java
// "^(?=.)M*(C[MD]|D?C{0,3})(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$"이 isRomanNumeral 호출시마다 생성됨
static boolean isRomanNumeral(String s) {
	return s.matches("^(?=.)M*(C[MD]|D?C{0,3})"
                    + "(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$");
}

// 최초 호출시 캐싱하고 이후 호출시 저장해둔 ROMAN을 재사용함
public class RomanNumerals {
	private static final Pattern ROMAN = pattern.compile(
		...
		);
	
	static boolean isRomanNumeral(String s) {
		return ROMAN.matcher(s).matches();
	}
}
```
- 호출될 때마다 새로 생성되는 객체이지만, 애플리케이션 런타임에서 그 내용이 변하지 않는 경우, 해당 객체를 최초 호출시에 생성해두고 이후 호출에서는 계속 사용하는 것이 좋다.
- 하지만 지연 초기화는 예외적 경우를 제외하고 코드는 복잡해지고 성능은 그닥 향상되지 않으므로 비추한다. (item67)


## 오토박싱을 주의하자
- 의미상으로 기본타입과 박싱타입의 차이는 별로 없지만, 성능에서는 다르다 (item61)
- 필요한 경우가 아니라면 기본 타입을 사용하자


## 객체 생성을 무조건 피하라는 것이 아니다
- 자체 풀을 만드는 것은 생성 비용이 정말 비싼 데이터베이스 연결 같은 경우를 제외하면 큰 이득이 없다
- 최근의 JVM이 제공하는 GC는 꽤 성능이 좋다
- cf. 방어적 복사(item50)
    * item06: 기존 객체를 재사용해야 한다면 새로운 객체를 만들지 마라 (for 클린 코드, 성능)
    * item50: 새로운 객체를 만들어야 한다면 기존 객체를 재사용하지 마라 (for 버그 방지, 보안)
    * 방어적 복사가 되어야 하는데 못 되었을 때의 피해 >>>> 불필요한 객체를 반복 생성했을 때의 피해