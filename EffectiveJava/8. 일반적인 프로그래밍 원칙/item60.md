# 정확한 답이 필요하다면 float와 double은 피하라

## 설계 의도부터 근사치를 구하기 위함이다
```java
System.out.println(1.03 - 0.42); // 0.6100000000000001
System.out.println(1.00 - 9 * 0.10); // 0.09999999999999998
```
- for 과학, 공학 계산 (**not** 금융 계산)
    * cf. 대부분의 물리학적, 수학적 모델이 실제 세계를 근사적으로 표현하는 데 부동소수점이 적합하기 때문
- for 빠르게 정밀한 근사치 구하기
    * cf. 계산의 효율성을 위함
- cf. 부동소수점
    * 고정소수점 대비 장점
        + 고정소수점은 이미 할당된 비트보다 크거나 작은 범위가 들어오면 처리하지 못함
        + 고정소수점은 특정 범위(정해진 자릿수)에 대한 정확한 계산만 가능함
    * 왜 저런 현상이?
        + 1.03과 0.42의 이진 부동소수점 표현
            - 1.03
                1. 정수부: 1은 이진으로 그대로 1
                2. 소수부: 0.03을 이진으로 변환. 소수를 이진수로 변환할 때에는 2를 곱해서 정수부를 취하는 식. 이 예시에서는 소수 부분을 2로 곱하면 0.06이 되고, 이를 다시 2로 곱하면 0.12가 됨. 이 과정을 반복하면 다음과 같은 이진 소수가 됨: 00001100110011001100110011001100110011001100110011...
                3. 최종적으로 이진 부동소수점으로 약 `1.00001100110011001100110011001100110011001100110011...`를 갖게 됨
            - 0.42
                1. 정수부: 0은 이진으로 그대로 0
                2. 소수부: 위와 같은 방식으로 하면: 01101010111100001010001111010111000010100011110101...
                3. 최종적으로 이진 부동소수점으로 약 `0.01101010111100001010001111010111000010100011110101...`를 갖게 됨 
        + 이진 부동소수점 뺄셈 (각 비트 위치에서 뺄셈을 수행)
        + 누적 오차 발생 (반올림 오차 등)
        + 최종 결과: `0.6100000000000001` (미세한 오차가 누적되면서 최종 결과에 영향을 미침)


## 정밀 계산이 필요하면...
1. int 또는 long 사용
    * 성능이 중요
    * 소수점을 직접 관리 (ex. `/10` 등, 달러 계산을 센트로 수행)
    * 숫자가 너무 크지(18자리 이상) 않음
2. BigDecimal 사용
    * 코딩 시의 불편함, 성능 저하를 고려하지 않아도 됨
        + 나눗셈을 할 땐 소수점 처리 방법을 필수로 지정해야 함
        + 다른 타입의 수와 비교하려면 그 타입을 BigDecimal로 형변환해야 함
    * 소수점을 알아서 다뤄줌 (ex. `new BigDecimal("1.00")`)
    * 소수점을 직접 관리하고자 했는데 18자리 이상의 수임