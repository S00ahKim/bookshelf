# Serializable을 구현할지는 신중히 결정하라

## implements Serializable 의 역할
- 어떤 클래스의 인스턴스를 직렬화
    * 직렬화한다는 의도만 표시하는 마커 인터페이스
- 자바 직렬화 장점 (JSON/CSV에 비해)
    * 해당 데이터 타입을 처리해주기 위한 추가 프레임워크가 불필요함
    * 직렬화는 자바의 고유 기술인 만큼 당연히 자바 시스템에서 개발에 최적화되어 있음
    * 기본 타입 외에도 별다른 파싱 없이 사용 가능함

## Serializable 구현의 문제점들
### (1) 릴리스한 후에 수정하기 어렵다
> 길게 보고 고품질의 직렬화 형태를 함께 설계해야 한다 (item87, item90)
- 왜? 직렬화된 바이트 스트림 인코딩도 하나의 공개 API가 됨
- 공개 API는 영원히 지원해야 한다
    * 내부 구현을 바꾸면 구버전 인스턴스를 직렬화하는 쪽에서 에러 발생
        + `serialVersionUID`가 달라서
    * 에러가 발생하지 않도록 명시적으로 조정해줄 수 있으나, 어렵고 지저분해짐
        + `ObjectOutputStream.putFields` 
        + `ObjectInputStream.readFields`
    * 클래스 개선을 방해하는 예: [InvalidClassException](https://techblog.woowahan.com/2551/)
- 공개하지 않으려고 했던 인스턴스 필드가 노출된다 (`private`, `package-private`)
    * 캡슐화 깨짐, 정보 은닉 불가 (item15)

### (2) 버그와 보안 구멍이 생길 위험이 높아진다
- item85
- 언어 규칙은 생성자로 객체를 만드는 것. 그러나 직렬화는 일종의 숨은 생성자.
- 따라서 불변식 깨짐 / 허가되지 않은 접근에 쉽게 노출됨 (item88)

### (3) 해당 클래스의 신버전을 릴리스할 때 테스트할 것이 늘어난다
> 커스텀 직렬화 형태를 잘 설계하면 테스트 부담을 줄일 수 있다 (item87, item90)
- 신버전 인스턴스를 직렬화한 후 구버전으로 역직렬화할 수 있는가?
- 구버전 인스턴스를 직렬화한 후 신버전으로 역직렬화할 수 있는가?
- 의도한 대로 객체의 데이터 전부를 충분히 전달하는가?

## Serializable 구현은 언제?
### 이럴 땐 하세요
- 객체 전송/저장시 자바 직렬화를 이용하는 프레임워크 용으로 만든 클래스인 경우
    * ex. `Apache Kafka`, `Apache Storm` 등
    * 값 클래스(ex. `BigInteger`)는 구현 O, 동작하는 클래스(ex. `쓰레드풀`)는 구현 X
- 보호된 환경에서만 쓰일 클래스인 경우
    * 한 클래스의 여러 버전이 상호작용하지 않음
    * 서버가 신뢰할 수 없는 데이터에 노출될 가능성이 없음

### 이럴 땐 하지 마세요
- 확장하는 쪽에 부담을 지우게 될 경우
    * 상속용으로 설계된 클래스 (item19)
    * 대부분의 인터페이스
    * 부모 클래스가 직렬화를 지원하지 않는 경우, 자식 클래스만 직렬화되기 때문
    * 단, 프레임워크가 오직 Serializable만 지원한다면 예외
        + ex. `Throwable` RMI를 통해 클라이언트로 예외를 보내기 위해
            - RMI(Remote Method Invocation) 원격 시스템 간의 메시지 교환을 위해서 사용하는 자바에서 지원하는 기술
        + ex. `Component` GUI를 전송하고 저장하고 복원하기 위해
        + 단, 두 클래스가 상기 목적으로 쓰인 경우는 극히 드물었다
- 내부 클래스인 경우
    * item24
    * 내부 클래스는 바깥 인스턴스 참조, 유효 범위의 지역변수를 저장하기 위해 컴파일러가 만든 필드가 자동으로 추가됨
    * 그러나 뭐가 추가되는지 분명하게 정의되었다고 보기 어려운 상황
    * 단, 정적 멤버 클래스는 예외

### 이런 점을 주의하세요
- 인스턴스 필드 값 중 불변식을 보장해야 한다면 반드시 하위 클래스에서 finalize 메서드를 재정의하지 못하게 해야 함
    * 어떻게? finalize 메서드를 재정의하면서 final로 선언
    * 왜? finalizer 공격을 당할 수 있음 (item8)
- 인스턴스 필드 중 기본값으로 초기화되면 위배되는 불변식이 있다면 클래스에 조치를 취해야 함
    * 기본값? 할당 안 했을 때 자동으로 들어가는 값. 0, false, null 등.
    * 어떻게? readObjectNoData 메서드 추가
        ```java
        private void readObjectNoData() throws InvalidObjectException {
            throw new InvalidObjectException("스트림 데이터가 필요합니다.");
        }
        ``` 
    * 왜? 기존의 직렬화 가능 클래스에 직렬화 가능 상위 클래스를 추가하는 드문 경우를 위함
- 구현하지 않기로 했다면 상속할 클래스를 위해 매개변수 없는 생성자를 제공하는 것이 좋음
    * 직렬화 미지원 클래스를 상속해서 직렬화를 지원하려면 부담이 생김
    * 매개변수 없는 생성자가 없다면 직렬화 프록시 패턴(item90)을 사용해야 함