# 배열보다는 리스트를 사용하라

## 배열 대 제네릭
- 배열
    1. 공변(함께 변한다) 타입
        * A가 B의 하위 타입일 때, A[]는 B[]의 하위 타입
        * Object[]를 Long[]으로 초기화한 뒤 문자열을 넣으면 컴파일되고 런타임 오류가 남
    2. 실체화(reify)됨
        * 런타임에도 자기가 담기로 한 원소의 타입을 인지하고 확인함
- 제네릭
    1. 불공변 타입
        * A가 B의 하위 타입일 때, List<A>는 List<B>의 하위 타입이 아님. 상속 관계와 무관하게 아예 다른 타입으로 간주됨.
        * List<Object>를 ArrayList<Long>으로 초기화한 뒤 문자열을 넣으면 컴파일 실패함 (Better!)
    2. 실체화 불가 타입
        * 제네릭은 런타임에 타입 정보가 소거되어 알 수 없음


## 제네릭 배열을 만들 수 없다
- 배열은 제네릭, 매개변수화 타입, 타입 매개변수(T)로 사용할 수 없다
    * 즉 이런 코드는 불가능하다: `E[]`, `List<E>[]`, `List<String>[]`
- 왜? 타입 안전하지 않기 때문이다
- 귀찮은 경우
    * 제네릭 컬렉션에서는 대개 자기의 타입을 담은 배열을 반환할 수 없다 (대처법: item33)
    * 제네릭 타입과 가변 인수 메서드를 함께 쓰면 경고를 얻는다 (item32)
- 일반적인 해결책
    * 배열로 형변환할 때 제네릭 배열 생성 오류/비검사 형변환 경고가 뜨는 경우 대부분 배열 E[] 대신 컬렉션 List<E>를 쓰면 해결된다.
    * 배열을 리턴한다면 사용처에서 매번 형변환해줘야 하며 비검사 형변환 경고가 뜨지만, 리스트를 리턴하면 그럴 필요도 없고 타입 문제로 런타임 오류가 날 일도 없다.