# 한정적 와일드카드를 사용해 API 유연성을 높이라

## 매개변수화 타입의 불공변성 때문에 발생하는 문제
- A가 B의 하위 타입이라고 해서 List<A>가 List<B>의 하위 타입인 것은 아니다 (item28)
- 그러므로 List<B>를 매개변수로 받는 메서드가 있을 때, List<A>를 넣을 순 없다


## 해결책은 한정적 와일드카드
- B를 상속하는 아이템들은 허용할 수 있다면 `List<? extends B>`
- A의 상위 타입 아이템들을 허용할 수 있다면 `List<? super A>`
- 장점: 유연성 극대화
- 규칙: PECS (producer-extends, consumer-super)
    * 매개변수가 생산자라면 <? extends T> 를 사용하라
        + 생산자: 매개변수가 T 타입의 값을 제공하거나 읽게 한다.
    * 매개변수가 소비자라면 <? super T> 를 사용하라
        + 소비자: 매개변수는 T 타입의 값을 소비(자신에게 추가하는 등)한다.
        + cf. `Comparable`과 `Comparator`는 소비자다. 매개변수를 자신이 사용하기 때문임.
    * 생산자이자 소비자라면, 와일드카드 타입을 쓸 때가 아니라 명시적으로 타입을 써줘야 함
    * 리턴 타입에는 사용하지 마라. 클라이언트도 써줘야 한다. **사용자가 신경써야 하는 와일드카드 타입은 잘못되었을 확률이 높다.**