# equals는 일반 규약을 지켜 재정의하라

## 재정의를 하지 않는 것이 최선인 경우
- 각 인스턴스가 본질적으로 고유함: 싱글톤, Enum, 쓰레드 등
- 인스턴스의 논리적 동치성을 검사할 일이 없음: 비교하는 것이 값이 아니라 참조(객체 식별성)인 경우 등
- 상위에서 재정의한 equals가 하위에도 들어맞음: Set 구현체는 AbstractSet이 구현한 equals를 씀
- 클래스가 private이거나 해서 equals를 호출할 일이 없음

## 재정의하는 것이 최선인 경우
- 논리적 동치성을 검사해야 함 && 상위 클래스에서 오버라이딩 안해뒀음
- ex. String 등 값 클래스
- 장점: 사용할 때 기대에 맞게 동작함 & 다른 객체에서 제네릭 등으로 활용 가능

## equals를 위한 규약
> 참조값이 null인 경우는 고려하지 않음
1. 반사성: `x.equls(x)는 true`
2. 대칭성: `x.equals(x)가 true면 y.equals(x)도 true`
    * ex. CaseInsensitiveString이 타입별로 나눠 비교하면 다른 타입에선 그렇게 안 해줘서 문제가 될 수 있음
    * ㄴ> 같은 타입끼리만 비교하도록 하는 등의 방법 사용
3. 추이성: `x.equals(y)가 true이고 y.equals(z)도 true면 x.equals(z)도 true`
    * ex. Point(좌표)를 상속하는 ColorPoint는 비교할 때 좌표만 비교할 수 있음
    * ㄴ> 상속된 객체끼리는 규약을 만족하는 재정의가 어려움. 컴포지션(item18)으로 Point, Color 변수를 갖는 ColorPoint를 만들어서 equals 재정의.
    * cf. **[유명한 실수]** Timestamp는 Date를 확장해 nanoseconds를 추가했는데, 이 때문에 대칭성이 위배된다. 둘을 혼용할 때 주의해야 함.
4. 일관성: `x.equals(y)를 반복해서 호출하면 항상 같은 결과`
    * 메모리에 존재하는 객체만을 사용한 결정적 계산만 해야 함
    * cf. **[유명한 실수]** URL은 주어진 url과 매핑된 호스트의 ip 주소를 이용하여 비교하는데, 호스트를 ip 주소로 변경하는 것이 네트워크를 통해야 하고 이 결과가 늘 같음을 보장할 수 없어서 문제가 일어남.
5. null아님: `x.equals(null)은 false`
    * 이를 충족하기 위해 `==null` 처럼 명시적 null 체크를 하기보다
    * `instanceof` 를 활용해서 타입 체크를 하는 식으로 묵시적 null 체크를 하자.

## 좋은 equals 만들기
1. ==으로 자기 자신의 참조인지 확인하기 (성능 최적화)
2. instanceof으로 입력의 타입이 올바른지 확인하기
    * 단, 파라미터 타입이 해당 타입이면 안 됨. 다중정의(item52)임. Object 여야 함.
3. 입력을 올바른 타입으로 형변환하기
4. 입력 객체와 자기 자신의 대응되는 핵심 필드들이 모두 일치하는지 검사하기
    * float는 Float.compare, double은 Double.compare로 비교
        + [소수를 이진법으로 표현하는 과정에서 약간의 오차가 생기며](https://inpa.tistory.com/entry/JAVA-%E2%98%95-%EC%8B%A4%EC%88%98-%ED%91%9C%ED%98%84%EB%B6%80%EB%8F%99-%EC%86%8C%EC%88%98%EC%A0%90-%EC%9B%90%EB%A6%AC-%ED%95%9C%EB%88%88%EC%97%90-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0)
        + Float.NaN, -0.0f 등의 특이한 값을 다룰 필요가 있기 때문
        + Float.equals 같은 걸 쓸 수 있는데, 오토박싱이 동반되어 성능상 좋지 않음
    * 그 외의 기본 타입 필드는 == 비교
    * 참조 타입 필드는 각각의 equals로 비교
    * 비교하기 복잡한 필드를 갖고 있다면 비교하기 위한 표준형을 두고 그 표준형을 비교 (불변일 때 특히 좋음)
    * 최상의 성능을 위해 (다를 가능성이 더 큼 || 비교하는 비용이 싼) 필드를 비교
5. 규약을 만족하는지 단위 테스트를 작성해서 확인하기
6. equals를 재정의할 땐 hashCode도 재정의하기 (item11)
7. equals 재정의가 귀찮다면 AutoValue 프레임워크를 사용해서 애너테이션으로 만들기