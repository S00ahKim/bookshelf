# equals를 재정의하려거든 hashCode도 재정의하라

## 규약
1. 애플리케이션 실행 중 호출된 객체의 hashCode는 **몇 번을 호출하든 일관된 값**을 반환해야 함
2. **equals가 두 객체를 같다고 판단했다면, 두 객체의 hashCode는 같은 값을 반환**해야 함
    * = 논리적 동치인 객체는 같은 해시코드를 반환해야 함
    * 이 규약을 지키기 위해 equals를 재정의한 클래스 모두는 hashCode도 재정의해야 함
    * 다른 값을 반환한다면 `HashMap`, `HashSet`의 원소로 정상적으로 사용 불가
3. equals가 두 객체를 다르다고 판단했더라도, 두 객체의 hashCode가 다른 값을 반환해야 할 필요는 없음
    * 그러나 다른 객체에 대해서는 다른 값을 주는 게 해시 테이블의 성능이 좋음
    * ㄴ 만약 hashCode 안에서 상수를 반환하는 식으로 다른 객체인데 같은 값을 주면, 모든 객체가 해시 테이블의 버킷 하나에 담겨서 사실상 연결 리스트처럼 동작하게 됨


## 구현
```java
@Override public int hashCode() {
    int result = Short.hashCode(areaCode);
    result = 31 * result + Short.hashCode(prefix);
    result = 31 * result + Short.hashCode(lineNum);
    return result;
}
```
1. int 변수 result를 선언하고, 첫번째 핵심 필드의 해시코드를 할당한다.
    * 핵심 필드 = equals 비교에 사용되는 필드
2. 해당 객체의 나머지 핵심 필드들에 대해 해시코드를 계산한다.
    * 해시코드 계산법 1: 기본 타입 필드
        - type의 박싱 클래스 Type의 hashCode 호출
        - ex. `Type.hashCode(elem)`
    * 해시코드 계산법 2: 참조 타입 필드
        - 재귀적으로 호출하거나 표준형의 hashCode 호출
        - 만약 null 이면 0 사용
    * 해시코드 계산법 3: 배열 타입 필드
        - 핵심 원소 각각을 필드처럼 다루어 계산법 1~2를 적용
        - 만약 빈 배열이면 0 사용
        - 만약 모든 원소가 핵심 원소라면 `Arrays.hashCode` 사용
    * cf. 파생 필드(다른 필드로 만들어낼 수 있는 필드)는 해시코드 계산에서 제외해도 된다
    * cf. equals에 사용되지 않는 필드는 **반드시** 제외해야 한다
3. 계산한 해시코드를 사용해 result를 갱신한다.
    * ex. `result = 31 * result + c`
    * 왜 31을 사용하는가? 홀수이면서 소수이기 때문.
        - 짝수라면... 오버플로 발생시 정보를 잃음. [시프트 연산](https://velog.io/@indongcha/hashCode%EC%99%80-31)과 같은 결과를 내기 때문.
        - 소수인 이유는 명확하지 않지만 전통적으로 그렇게 사용했다. lombok 역시 소수 59 사용.
4. result를 반환한다.


## 기타 tips
- 해시 충돌이 아주 적은 방법을 꼭 사용해야 한다면, Guava 라이브러리가 제공하는 Hashing 참고
- 클래스가 불변이고 해시코드 계산 비용이 클 경우, 매번 새로 계산하기보다 캐싱하라
    * 해시 키로 사용될 것 같다면... 인스턴스가 만들어질 때 해시코드 계산
    * 해시 키로 사용되지 않는다면... 나중에 계산되도록 지연 초기화 전략 사용 (단, 스레드 안전해야 함)
- 성능을 위해 핵심 필드를 생략하면 안 된다! 해시 품질이 아주 저하될 것이다.
- hashCode 값을 만드는 규칙을 사용자는 모르게 하라. 그래야 그들이 규칙에 의존하지 않게 되고, 변경도 자유롭게 할 수 있다.