# 익명 클래스보다는 람다를 사용하라

## 익명 클래스
```java
Collections.sort(words, new Comparator<String>()){ // 추상적 정렬 전략
    public int compare(String s1, String s2) { // 구체적 정렬 전략
        return Integer.compare(s1.length(), s2.length());
    }
}
```
- item24
- 함수 타입을 만들기 위해 자바에서 사용해왔던 전략 = `함수형 인터페이스`로 `함수 객체` 만들기
    * 함수형 인터페이스 = 추상 메서드 1개만 가진 인터페이스
    * 함수 객체 = 함수형 인터페이스의 인스턴스
- `익명 클래스` = 함수 객체를 만드는 주요 수단
- 단점
    * 코드가 길어진다

### 여전히 익명 클래스가 필요할 때
- 추상 클래스의 인스턴스를 만들 때
- 추상 메서드가 여러 개인 인터페이스의 인스턴스를 만들 때
- 함수 객체가 자신을 참조해야 할 때 (익명 클래스의 this는 자신을 가리킴)
    * 람다는 불가능함 (람다의 this는 바깥 인스턴스를 가리킴)


## 람다
```java
Collections.sort(words, 
    (s1, s2) -> Integer.compare(s1.length(), s2.length()));
```
- 자바8~
- 함수 객체를 람다식으로 만들 수 있음
- 컴파일러의 타입 추론
    * 타입을 명시해야 코드가 더 명확할 때를 제외하면 람다의 모든 매개변수 타입은 생략
    * 컴파일러의 타입 추론에 제네릭이 큰 역할을 하므로, 제네릭 규칙을 준수하자 (item26, item29, item30)
- 장점
    * 코드가 획기적으로 간결해짐
- 단점
    * 이름이 없고 문서화하지 못함 (한눈에 무슨 일을 하는지 알아보기 어렵거나 길어지면 람다 사용 X)\


## 주의
- 람다든 익명 클래스든 직렬화하는 일을 삼가라. 구현별로 다를 수 있다.
- 함수 객체를 직렬화해야 한다면 private 정적 중첩 클래스(item24)의 인스턴스를 사용하자.