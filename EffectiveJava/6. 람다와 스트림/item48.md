# 스트림 병렬화는 주의해서 적용하라

## 자바와 동시성의 역사
- 최초 릴리스
    * 스레드, 동기화, wait/notify를 지원
        + wait : 갖고 있던 고유 락을 해제하고, 스레드를 잠들게 한다.
        + notify :잠들어 있던 스레드 중 임의로 하나를 골라 깨운다.
- 자바5~
    * 동시성 컬렉션인 java.util.concurrent 라이브러리
    * 실행자(Executor) 프레임워크
- 자바7~
    * 고성능 병렬 분해 프레임워크, 포크-조인(fork-join) 패키지
        + 분할 정복 알고리즘을 통해서 재귀적으로 처리함
- 자바8~
    * parallel 메서드만 한 번 호출하면 파이프라인을 병렬 실행할 수 있는 스트림을 지원
        + 병렬 스트림은 요소들을 병렬 처리하기 위해 포크조인(ForkJoin) 프레임워크를 사용
- 동시성 VS 병렬성
    * 동시성은 동시에 실행되는 것 같이 보이는 것이고, 병렬성은 실제로 동시에 실행되는 것
    * 동시성은 싱글코어에서 멀티 쓰레드를 동작시키는 방식이고, 병렬성은 멀티코어에서 멀티 쓰레드를 동작시키는 방식
- 더 쉽게 지원하고는 있으나, 올바르고 빠르게 작성하는 것은 여전히 어렵다!
    * 동시성 프로그래밍에서 중시하는 것은 **안전성**(safety)와 **응답 가능**(liveness) 상태
        + 안전성: 공유 자원을 안전하게 관리하고, 다른 스레드에게 간섭받지 않는 원자적인 연산이 필요
        + 응답가능상태: 데드락이 일어나지 않고, 프로그램이 멈추면 안 됨 (진행 보장) 


## 스트림에서 parallel()을 써도 성능 보장이 안 되는 경우
> 스트림 라이브러리가 병렬화하는 방법을 찾지 못하는 경우
- 데이터 소스가 Stream.iterate인 경우
    * Stream.iterate는 현재 값에서 다음 값을 계산하는 데 함수를 사용하여 무한한 요소를 생성하는 스트림을 만듦
    * 이러한 스트림은 **각 요소가 직전 요소에 의존하기 때문에** 파이프라인 병렬화가 어려울 수 있음
- **중간 연산으로** limit 을 사용하는 경우
    * 스트림 라이브러리는 limit를 다룰 때 CPU 코어가 남는다면 원소를 몇 개 더 처리한 후 제한된 개수 이후의 결과를 버려도 아무런 해가 없다고 가정
- 종단 연산으로 파이프라인 전체 작업에서 상당 비중을 차지하고 순차적인 연산을 사용할 경우


## 스트림에서 parallel()을 써서 성능 보장이 되는 경우
- 독립적인 작업을 수행하는 경우
- 효과적인 자료구조 = 스트림의 소스가 `ArrayList`, `HashMap`, `HashSet`, `ConcurrentHashMap`의 인스턴스 / `배열`, `int` 범위, `long` 범위일 때
    * 나눔의 편리함
        + 데이터를 원하는 크기로 정확하고 쉽게 나눌 수 있음
        + 일을 다수의 스레드에 분배하기 좋음
        + cf. 분배 작업은 Spliterator가 담당
    * 순차적 실행시 참조 지역성이 좋음
        + 데이터가 메모리에 물리적으로 가까이 있음
        + 다량의 데이터일 수록 이 특성이 중요
        + 기본 타입 배열은 참조가 아닌 진짜 데이터가 메모리에 연속 저장되므로 가장 효율적
- 종단 연산 중 병렬화에 효과적인 연산 = reduction
    * reduction? 파이프라인에서 만들어진 모든 원소를 하나로 합치는 작업 (ex. reduce, min, max, count, sum 등)
    * anyMatch, allMatch, noneMatch처럼 조건에 맞으면 바로 반환되는 메서드
    * cf. 가변 축소(mutable reduction)를 수행하는 메서드는 적합하지 않음 (ex. collect)


## 스트림에서 병렬 처리를 할 때 주의하라
- 잘못 병렬화하면 성능이 나빠질 뿐 아니라 결과가 잘못되거나 예상치 못한 동작을 할 수 있다
- 스트림은 병렬 파이프라인을 위한 함수 객체에 대한 규약을 정의해뒀다
    * ex. 스트림의 reduce연산에 건네지는 accumulator, combiner는 결합법칙을 만족하고, 간섭받지 않고, 상태가 없어야 함
    * 규약을 지키지 않으면 순차 실행할 땐 문제가 없을지라도 병렬 실행시 문제가 될 수 있다
- 병렬화에 드는 비용이 너무 큰 경우 성능 향상이 미미할 수 있다
    * 효과적인 경우: 스트림 안의 원소 수 * 수행되는 코드 라인 수 >= 수십만
- **변경 전후로 성능을 테스트**하여 가치 있는 병렬 처리인지 확인할 것
    * 운영 환경과 유사한 조건에서 성능지표 관찰하자
- 무작위 수로 이뤄진 스트림을 병렬화하려면 그런 상황을 위해 디자인된 SplittableRandom을 사용하라
    * Random은 모든 연산을 동기화하므로 최악의 성능일 것