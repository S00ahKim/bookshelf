# 표준 함수형 인터페이스를 사용하라

## 람다의 등장과 코딩 패턴의 변화
- 템플릿 메서드 패턴의 매력이 줄다
    * 상위 클래스의 기본 메서드 재정의
- 함수 객체를 받는 정적 팩터리나 생성자를 제공
    * 함수 객체를 매개변수로 받는 생성자/메서드 작성
    * 이때, 타입에 주의해야!!


## 필요한 용도에 맞는 게 있다면, 직접 구현하지 말고 표준 인터페이스를 사용하라
- java.util.function 패키지에 다양한 표준 함수형 인터페이스를 제공함
- 종류
    1. Operator : 반환값과 인수의 타입이 같은 함수
        * 인수가 1개인 UnaryOperator(String::toLowerCase), 2개인 BinaryOperator(BigInteger::add)
    2. Predicate : 인수 1개를 받아 boolean을 반환하는 함수
        * Collection::isEmpty
    3. Function : 인수와 반환 타입이 다른 함수
        * Arrays::asList
    4. Supplier : 인수를 받지 않고 값을 반환(혹은 제공) 하는 함수
        * Instant::now
    5. Consumer : 인수를 하나 받고 반환값은 없는(특히 인수를 소비하는) 함수
        * System.out::println
- 기본 인터페이스는 기본 타입인 int, long, double용으로 각 3개씩 변형이 생겨 난다.
    * 이름도 기본 인터페이스의 이름 앞에 해당 기본 타입 이름을 붙여 지음 (ex. int를 받는 Predicate ⇒ IntPredicate)
- 기본 함수형 인터페이스에 박싱된 기본 타입을 넣어 사용하지는 말자
    * 표준 함수형 인터페이스 대부분은 기본 타입만 지원
    * 특히, 계산량이 많을 때 성능이 느려질 수 있다


## 직접 작성해야 하는 경우
- 표준 인터페이스 중 필요한 용도에 맞는 게 없다면 직접 작성
- 표준 인터페이스가 있더라도 직접 작성해야 하는 경우가 있음. 아래 예시의 특성 중 1개 이상 만족시 새로 작성.
    * ex. Comparator<T> 인터페이스는 구조적으로  표준 인터페이스인 ToIntBiFunction<T, U>와 동일
        + API에서 굉장히 자주 사용됨(이름 자체가 그 용도를 잘 설명해줌)
        + 구현하는 쪽에서 반드시 지켜야 할 규약을 담고 있음
        + 유용한 디폴트 메서드들을 많이 담고 있음
- 직접 만든 함수형 인터페이스에는 항상 @FunctionalInterface 애너테이션을 사용하자
    * 해당 인터페이스가 람다용으로 설계된 것임을 알려줌
    * 해당 인터페이스가 추상 메서드를 오직 하나만 가지고 있어야 컴파일 되게 해줌
    * 유지보수 과정에서 누군가 실수로 메서드 추가를 하지 못하게 막아줌


## furthermore
- 직접 구현하지 않는데 어떻게 해당 함수형 인터페이스인지 아는 거지?
    * 물론 필요한 경우 직접 구현해서 사용할 수 있다 (ex. [예시코드](https://colevelup.tistory.com/10))
    * 기본적으로 필요한 곳에 파라미터 타입으로 두고, 거기에 람다로 넘기면, 컴파일러가 타입 추론을 해준다! (자바8~)
    * 위의 예시도, Predicate을 파라미터 타입으로 둔 데에 Collection::isEmpty를 줄 수 있다는 의미
- 왜 함수형 인터페이스를 도입했을까?
    * 내부 상태를 갖지 않고, 같은 입력에 대해 항상 같은 출력을 보장하는 순수 함수를 지원해주기 위해
    * 그렇게 하면 검증이 쉽고, 캐싱 등 최적화가 가능하며, 동시성 문제에서 비교적 자유롭고, 함수 재사용성이 높다